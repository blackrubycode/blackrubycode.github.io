<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>웹 엔지니어 - PHP | Blackruby Code</title>
	<meta name="description" content="PHP">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/blackruby-code/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/blackruby-code/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/blackruby-code/web/2017/12/24/Web2.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="Blackruby Code" href="/blackruby-code/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- Main -->
	<script src="/blackruby-code/assets/js/main.js"></script>

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
</head>

  <body>
    <header class="site-header">
	<div class="inner">
		<div class="branding">
			<h1 class="site-title">			
			<!-- 
			<a href="/blackruby-code/">
				<img class="avatar" src="/blackruby-code/assets/img/blackruby_logo.png" alt=""/>
			</a>
			 -->
				<a href="/blackruby-code/">Blackruby Code</a>				
			</h1>
		</div>
		<nav class="site-nav">
			<ul>
				<li>
					<a href="https://blackruby.studio/">About</a>
				</li>
				<li class="dev-tab">
					<span>Dev</span>
					<ul>
						<li>
							<a href="/blackruby-code/back.html">back</a>
						</li>
						<li>
							<a href="/blackruby-code/front.html">front</a>							
						</li>
					</ul>
				</li>
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				<li>
					<a class="page-link" href="/blackruby-code/tags.html">
						Tags
					</a>
				</li>
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
							            
				<!-- Search bar -->
				
				<li class="search-bar">
				<form action="/blackruby-code/search.html" method="get">
					<input type="text" id="search-box" name="query" placeholder="Search" class="">
					<button type="submit" class="">
						<i class="fa fa-fw fa-search"></i>
					</button>
				</form>
				</li>
				
			</ul>
		</nav>
	</div>	    
</header>

    <div class="content">
      <!-- <div class="inner"> -->
          <article >
  <header style="background-image: url('/blackruby-code/')">
    <h1 class="title">웹 엔지니어 - PHP</h1>
    
    <p class="meta">
      December 24, 2017
       - Yoonkh
    </p>
  </header>  
  <section class="post-content"><h2 id="php">PHP</h2>

<h3 id="최근-php">최근 PHP</h3>

<p>5.0의 객체 지향 기능 강화, 5.3의 네임 스페이스와 익명 함수, 5.4의 트레이트, 5.5의 제너레이터 지원 등 PHP는 버전이 올라가면서 다양한 기능을 추가하고 있습니다.</p>

<p>또, 예전부터 보안 문제로 추천하지 않았던 기능, 함수 등은 하위 호환성을 버리면서 개량을 거듭하는 중으로, 예전 스타일의 작성법이나 현재는 권장하지 않는 오래된 정보가 많이 발견됩니다.</p>

<h3 id="php-프레임워크">PHP 프레임워크</h3>

<h4 id="풀-스택-프레임워크">풀 스택 프레임워크</h4>

<p>풀스택 프레임워크에서는 ORM이나 인증, 템플릿 등 웹 애플리케이션에 필요한 기능을 제공합니다. 주요 풀 스택 프레임워크는 다음과 같습니다.</p>

<ul>
  <li>Aura</li>
  <li>CakePHP</li>
  <li>FuelPHP</li>
  <li>Laravel</li>
  <li>Lithium</li>
  <li>Phalcon</li>
  <li>Symfony</li>
  <li>Yii</li>
  <li>Zend framework</li>
  <li>CodeIgniter</li>
</ul>

<p>위의 항목중에서 Symfonu, laravel, phalcon 세 가지 프레임워크가 강력했습니다.</p>

<h5 id="symfony">Symfony</h5>

<p>Symfony는 2005년부터 개발하여 현재 최신 버전은 2.6입니다. 원래 Ruby on Rails에 영향을 받아 만든 프레임워크였지만, 버전 2에서 설계부터 코드까지 완전히 다른 프레임워크로 다시 태어났습니다. 각 기능을 느슨하게 결합하도록 철저하게 설계되어 있고, 개발자는 프레임워크로 규칙, 제약을 그다지 받지 않은 채 아주 유연하게 개발할 수 있습니다.</p>

<h5 id="laravel">Laravel</h5>

<p>Laravel(라라벨)은 2012년부터 개발한 비교적 새로운 프레임워크입니다. 해외에서는 2014년 가장 유망한 PHP 프레임워크로 뽑히는 등 상당히 인기가 있습니다.</p>

<p>Laravel은 앞선 기능을 많이 갖추고 있으며, 프레임워크 방식을 따르기에 Rails처럼 궤도에 오르는 느낌으로 개발할 수 있는 PHP 프레임워크입니다.</p>

<h5 id="phalcon">Phalcon</h5>

<p>Phalcon(팔콘) 공식 도큐먼트에 나온 것처럼 ‘중요한 것은 성능’이라는 견해를 바탕으로, 다른 프레임워크와는 달리 PHP 확장 모듈을 C언어로 구현했습니다. Phalcon은 PHP를 실행할 때 일어나는 구문 해석, Opcode 변환 단계를 날려 버려 뛰어난 성능과 압도적인 속도를 자랑합니다.</p>

<h4 id="마이크로-프레임워크">마이크로 프레임워크</h4>

<ul>
  <li>Silex</li>
  <li>Slim</li>
</ul>

<p>풀스택 프레임워크와 달리 기본 기능은 한정되어 있지만 학습 비용이 낮아서 간단한 기능이나 소규모 개발에서는 마이크로 프레임워크를 선택하는 것도 좋은 방법입니다.</p>

<h3 id="php-실행-환경-구축">PHP 실행 환경 구축</h3>

<h4 id="php-설치">PHP 설치</h4>

<p>rbenv처럼 PHP에도 버전을 관리하는 phpenv, 빌드와 인스톨을 담당하는 php-build 도구가 있으니 이를 사용해서 환경을 구축합니다.</p>

<p>우선은 가상 머신에 SSH로 로그인합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ vagrant ssh
</code></pre></div></div>

<p>PHP 빌드에 필요한 라이브러리를 미리 yum 커맨드로 설치</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo yum install -y epel-release
$ sudo yum install -y --enablerepo=epel libxml2-devel readline-devel libcurl-
debel libjpeg-turbo-devel libpng-devel libmcrypt-devel libtidy-devel libxslt-devel re2c bison
</code></pre></div></div>

<p>phpenv 설치</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl https://raw.githubusercontent.com/CHH/phpenv/master/bin/phpenv-install.sh | sh
</code></pre></div></div>

<p>phpenv 사용에 필요한 설정을 .bash_profile에 추가하고 설정을 반영합니다</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo 'export PATH="/home/vargrant/.phpenv/bin:$PATH"' &gt;&gt; ~/.bash_profile
$ echo 'eval "$(phpenv init -)"' &gt;&gt; ~/.bash_profile
$ source ~/.bash_profile
</code></pre></div></div>

<p>phpenv 버전의 확인</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phpenv -v 
</code></pre></div></div>

<p>configure 옵션을 변경하지 않고, php-build의 기본 configure로 설치를 진행합니다.</p>

<p>PHP 5.6.13의 설치</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ phpenv install 5.6.13
</code></pre></div></div>

<p>설치된 PHP버전 목록 확인</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phpenv versions
</code></pre></div></div>

<p>기본 버전의 지정</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phpenv install 5.6.13
</code></pre></div></div>

<p>php 커맨드의 사용</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ php -v
</code></pre></div></div>

<h4 id="phpini-설정">php.ini 설정</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/.phpenv/versions/5.6.13/etc
$ cp php.ini php.ini.old # 원본 파일 백업
$ vi php.ini # php.ini 수정

# 다음 변경된 부분을 참고하여 수정한다

$ git diff --no-index php.ini.old php.ini
</code></pre></div></div>

<h3 id="composer-사용">Composer 사용</h3>

<p>Composer는 PHP 프로젝트의 의존관계를 관리하는 도구입니다. 프로젝트에 필요한 라이브러리의 이름과 버전을 정의하면, 다운로드부터 설치, 버전 관리, 클래스 자동 로딩 문제를 해결합니다.</p>

<h4 id="composer-설치">Composer 설치</h4>

<p>Composer를 사용함녀 프로젝트에 필요한 라이브러리를 관리할 수 있고, PHP 개발 전반에 사용하는 커맨드라인 도구 등 라이브러리도 설치할 수 있습니다.</p>

<h3 id="psr-알아보기">PSR 알아보기</h3>

<p>PHP로 개발할 때 지켜야 할 규약으로 PSR(PHP Standard Recommendations)이 있습니다. PSR은 PHP의 다양한 프레임워크와 라이브러리 개발 커뮤니티인 PHP-FIG(PHP Framework interop Group)가 참여하여 제창한 표준 가이드라인입니다. 현재 PSR-0~PSR-4까지 공개되어 있습니다.</p>

<p>PSR은 이름 규칙과 디렉터리 구조, 코딩 스타일 같은 작성법을 비롯하여 로거처럼 필수적이고. 중요한 기능의 인터페이스 정의도 포함하여 표준화를 진행합니다.</p>

<h3 id="php-애플리케이션-개발-환경-구축">PHP 애플리케이션 개발 환경 구축</h3>

<h4 id="프로젝트-만들기">프로젝트 만들기</h4>

<p>Composer를 사용하여 Silex를 설치할 수 있습니다. ‘/vagrant’ 디렉터리를 프로젝트 루트로 합니다.</p>

<ul>
  <li>Composer.json에 라이브러리 정보를 기술합니다. require 부분에는 패키지 이름과 버전을 지정합니다.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ 
	"require" : {
		"silex/silex": "~1.2"
	}
}
</code></pre></div></div>

<p>composer install을 실행하면 composer.json의 내용을 바탕으로 Silex가 의존하는 모듈을 다운로드하기 시작합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ composer install
</code></pre></div></div>

<p>설치가 끝나면 composer.lock 파일을 만들고, vendor 디렉터리 아래에는 설치한 라이브러리를 저장합니다.</p>

<p>Git 등으로 애플리케이션 버전을 관리할 때는 composer.json, composer.lock 파일 모두 커밋하도록 합니다. composer.lock 파일이 없으면 자신의 로컬 환경과 다른 팀 멤버의 환경, 실제 서비스 환경에서 설치하는 라이브러리 버전이 다를 수 있으므로 반드시 커밋.</p>

<p>Silex 매뉴얼에 있는 ‘Hello World’ 애플리케이션을 만들어 보자. 시작할 때 Composer가 생성한 ‘vendor/autoload.php’를 제일 먼저 읽어 들여 라이브러리를 자동으로 로딩 할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">'/vendor/autoload.php'</span><span class="p">;</span>

<span class="nv">$app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Silex</span><span class="o">/</span><span class="nx">Application</span><span class="p">();</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'/hello/{name]'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="nx">user</span> <span class="p">(</span><span class="nv">$app</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s1">'Hello'</span> <span class="o">.</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">escape</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="o">.</span> <span class="nx">PHP_EOL</span><span class="p">;</span>
<span class="p">});</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="api-만들기">API 만들기</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 요청한 IP 주소를 반환한다
$ curl -s http://httpbin.org/ip

# 요청한 사용자 에이전트를 반환한다
$ curl -s http://httpbin.org/user-agent

# GET 요청에 HTTP 헤더, 요청 파라미터를 반환한다
$ curl -s 'http://httpbin.org/get?foo=bar&amp;baz=qux'
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="k">use</span> <span class="nx">Symfony\Componet\HttpFoundation\Request</span><span class="p">;</span>

<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">'/vendor/autoload.php'</span><span class="p">;</span>

<span class="nv">$app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Silex</span><span class="o">/</span><span class="nx">Application</span><span class="p">();</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'/ip'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$app</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
		<span class="s1">'origin'</span> <span class="o">=&gt;</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getClientIp</span><span class="p">(),</span>
	<span class="p">]);</span>
<span class="p">});</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'/user-agent'</span><span class="p">,</span> <span class="nx">fuction</span> <span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$app</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
		<span class="s1">'user-agent'</span> <span class="o">=&gt;</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'User-Agent'</span><span class="p">),</span>
	<span class="p">]);</span>
<span class="p">});</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'/get'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$app</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">//헤더의 키를 '-'로 구분해 대문자로, user-agent -&gt; User-Agent</span>
	<span class="nv">$headers</span> <span class="o">=</span> <span class="p">[];</span>
	<span class="k">foreach</span> <span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$key</span> <span class="o">=&gt;</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$key</span> <span class="o">=</span> <span class="nb">preg_replace_callback</span><span class="p">(</span><span class="s1">'/\w+/'</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="nv">$matches</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">ucfirst</span><span class="p">(</span><span class="nv">$matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">},</span> <span class="nv">$key</span><span class="p">);</span>
		<span class="nv">$headers</span><span class="p">[</span><span class="nv">$key</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
		<span class="s1">'args'</span> <span class="o">=&gt;</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">query</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">(),</span>
		<span class="s1">'headers'</span> <span class="o">=&gt;</span> <span class="nv">$headers</span><span class="p">,</span>
		<span class="s1">'origin'</span> <span class="o">=&gt;</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getClientIp</span><span class="p">(),</span>
		<span class="s1">'user-agent'</span> <span class="o">=&gt;</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'User-Agent'</span><span class="p">),</span>
		<span class="p">]);</span>
<span class="p">});</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="개발에-편리한-도구">개발에 편리한 도구</h3>

<h4 id="repl">REPL</h4>

<p>Ruby의 Pry와 같은 REPL은 PHP에서는 그다지 활발하게 사용하지 않는 것 같습니다. php -a 옵션으로도 대화식 모드를 이용하여 PHP를 실행할 수 있지만, 아주 간단한 기능만 제공하므로 기능이 풍부한 PsySH를 도입해서 사용해보자.</p>

<p>PsySH는 composer를 사용해서 환경 전체에 설치할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ composer global require psy/psysh:@stable
</code></pre></div></div>

<p>설치를 완료하면 psysh 커맨드로 Psy 셸을 사용할 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ psysh
</code></pre></div></div>

<p>’~/.psysh’ 아레에 사전 파일을 저장하면, PsySH 안에서 PHP 메뉴얼을 참조할 수 있습니다. 사전 파일은 다음과 같이 설치한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -O http://psysh.org/manual/en/php_manual.sqlite
$ mkdir ~/.psysh
$ mv php_manual.sqlite ~/.psysh
</code></pre></div></div>

<p>이제 ‘doc 함수 이름’으로 PHP 메뉴얼의 함수 정의를 참조할 수 있습니다. 다시 한 번 doc 커맨드를 테스트하는 명령어.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ psysh

&gt;&gt;&gt; $d = new Datetime
...
&gt;&gt;&gt; doc $d-&gt;getOffser
</code></pre></div></div>

<p>PsySH를 시작할 때 autoload 파일을 지정하면, PsySH 안에서 프로젝트에서 이용하는 라이브러리에도 액세스할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /vendor
$ psysh vendor/autoload.php
</code></pre></div></div>

<p>index.php 소스 코드에서 /get 시작 부분에 다음처럼 브레이크 포인트를 삽입한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="nx">user</span> <span class="nx">Symfony\Component\HttpFoundation\Request</span><span class="p">;</span>

<span class="o">...</span> <span class="nx">중략</span> <span class="o">...</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'/get'</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span> <span class="nx">user</span> <span class="p">(</span><span class="nv">$app</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// 브레이크 포인트 </span>
	<span class="nx">\Psy\Shell</span><span class="o">::</span><span class="na">debug</span><span class="p">(</span><span class="nb">get_defined_vars</span><span class="p">());</span>
	
	<span class="c1">// 헤더의 키를 '-'로 구분하여 대문자로, user-agent -&gt; User-Agent</span>
	<span class="nv">$headers</span> <span class="o">=</span> <span class="p">[];</span>
	
	<span class="o">...</span> <span class="nx">중략</span> <span class="o">...</span>
	
<span class="p">});</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">();</span>
</code></pre></div></div>

<p>호스트 운영체제에서 HTTP 요청을 보내면, PHP 빌트인 웹 서버를 실행한 콘솔에서 PsySH를 시작한다.</p>

<h4 id="코딩-규칙-점검-분석">코딩 규칙 점검, 분석</h4>

<p>PHP Coding Standards Fixer는 PSR-0~2와 Symfony 코딩 규칙 등을 따르는지 분석하고, 규칙을 따르지 않는 코드를 수정합니다.</p>

<p>Composer로 설치할 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ composer global require fabpot/php-cs-fixer
</code></pre></div></div>

<p>앞서 소개한 API를 PSR 규칙에 반하도록 수정해본다.</p>

<ul>
  <li>PHP의 예약어를 대문자로 지정한다.</li>
  <li>함수 정의 사이의 공백을 없앤다.</li>
  <li>함수 이름과 () 사이에 공백을 넣는다.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="nx">user</span> <span class="nx">Symfony\Component\HttpFoundation\Request</span><span class="p">;</span>

<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">'/vendor/autoload.php'</span><span class="p">;</span>

<span class="nv">$app</span> <span class="o">=</span> <span class="nx">NEW</span> <span class="nx">Silex</span><span class="o">/</span><span class="nx">Application</span><span class="p">();</span>
	
<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'/ip'</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span><span class="k">use</span><span class="p">(</span><span class="nv">$app</span><span class="p">){</span>
	<span class="k">return</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
		<span class="s1">'origin'</span> <span class="o">=&gt;</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getClientIp</span><span class="p">(),</span>
	<span class="p">]);</span>
<span class="p">});</span>

<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">();</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>php-cs-fixer는 기본적으로 Symfony의 코딩 규약으로 검사한다. 변경사항을 표시하려고 diff 옵션을 지정하고, 검사할 수준은 PSR-2로 지정하여 실행한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ php-cs-fixer fix index.php --diff --level=psr2
</code></pre></div></div>

<h4 id="나머지-도구">나머지 도구</h4>

<p>이외에도 PHP 개발에는 Git의 커밋 전에 훅을 호출하거나 CI와 연계하면 편리한 정적 분석 도구가 있습니다.</p>

<h5 id="phpmd">PHPMD</h5>

<p>PHPMD는 정적으로 코드를 분석하여 거대한 클래스와 함수 등 복잡하고 버그가 생기기 쉬운 곳이나 개선하는 편이 나은 곳을 탐지하여 보고합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ composer global require phpmd/phpmd
</code></pre></div></div>

<h5 id="phploc">PHPLOC</h5>

<p>PHPLOC는 코드의 행 개수나 클래스, 함수의 개수 등 프로젝트의 구성을 분석합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ composer global require 'phploc/phploc=*'
</code></pre></div></div>

<h5 id="phpcpd">PHPCPD</h5>

<p>PHPCPD는 복사하여 붙여 넣은 코드를 찾아서 보고합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ composer global require 'sebastian/phpcpd=*'
</code></pre></div></div>

<h3 id="정리">정리</h3>

<p>Facebook이 HHVM이라는 PHP 실행 환경과 HHVM에서 동작하는 PHP 확장 언어인 Hack을 개발 중이다.</p>

<p>HHVM에서 동작하는 Hack은 PHP에 없는 다음과 같은 강력한 기능을 추가하면서 기존 PHP 코드와 공존하여 동작시킬 수 있다.</p>

<ul>
  <li>정적 타입</li>
  <li>제네릭스</li>
  <li>비동기 처리</li>
</ul>
</section>
  
<footer>
  <div class="tags">
    
    <a class="tag" href="/blackruby-code/tags#Web">#Web</a>
    
    <a class="tag" href="/blackruby-code/tags#PHP">#PHP</a>
    
  </div>
</footer>


</article>

<!-- Disqus -->


<!-- Post navigation -->


      <!-- </div>      -->
    </div>
    
<script src="/blackruby-code/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
