<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | Blackruby Code</title>
	<meta name="description" content="A website with blog posts and pages">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/blackruby-code/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/blackruby-code/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/blackruby-code/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="Blackruby Code" href="/blackruby-code/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- Main -->
	<script src="/blackruby-code/assets/js/main.js"></script>

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
</head>

  <body>
    <header class="site-header">
	<div class="inner">
		<div class="branding">
			<h1 class="site-title">			
			<!-- 
			<a href="/blackruby-code/">
				<img class="avatar" src="/blackruby-code/assets/img/blackruby_logo.png" alt=""/>
			</a>
			 -->
				<a href="/blackruby-code/">Blackruby Code</a>				
			</h1>
		</div>
		<nav class="site-nav">
			<ul>
				<li>
					<a href="https://blackruby.studio/">About</a>
				</li>
				<li class="dev-tab">
					<span>Dev</span>
					<ul>
						<li>
							<a href="/blackruby-code/back.html">back</a>
						</li>
						<li>
							<a href="/blackruby-code/front.html">front</a>							
						</li>
					</ul>
				</li>
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				<li>
					<a class="page-link" href="/blackruby-code/tags.html">
						Tags
					</a>
				</li>
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
							            
				<!-- Search bar -->
				
				<li class="search-bar">
				<form action="/blackruby-code/search.html" method="get">
					<input type="text" id="search-box" name="query" placeholder="Search" class="">
					<button type="submit" class="">
						<i class="fa fa-fw fa-search"></i>
					</button>
				</form>
				</li>
				
			</ul>
		</nav>
	</div>	    
</header>

    <div class="content">
      <!-- <div class="inner"> -->
          <article >
  <header style="background-image: url('/blackruby-code/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>
<script>
  window.store = {
    
      "python-2018-01-15-study-html": {
        "title": "재미그래밍 - 스터디자료",
        "tags": "Python",
        "date": "January 15, 2018",
        "author": "Yoonkh",
        "category": "",
        "content": "스터디 자료 2018_01_15RESTful 파이썬 웹 서비스 제작스터디 자료플라스크를 이용한 레스트풀 API 개발간단한 리스트에서 CRUD 작업을 수행하는 레스트풀 API를 만들기 위해 다음의 과정이 필요합니다.  플라스크 레스트풀 확장을 사용해 플라스크에서 CRUD 연산을 수행하는 레스트풀 API 설계  각 HTTP 메서드가 수행하는 작업 이해  플라스크와 플라스크 레스트풀 확장을 사용해 가상 환경 설정하기  응답용 상태 코드 선언  자원을 나타내는 모델의 생성  딕셔너리를 저장소로 사용  직렬화된 응답에 대한 출력 필드 구성  플라스크 플러거블 뷰의 맨 위에서 풍부한 라우팅으로 작업  자원 라우팅과 엔드포인트에 대한 구성  플라스크 API에 대한 HTTP 요청 작성  플라스크 API와 대화하는 명령 행 도구에서의 작업간단한 데이터 소스와 대화하는 레스트풀 API 설계IoT(사물 인터넷)장치에 유선으로 연결된 OLED 디스플레이에 나타낼 메시지를 구성해야 한다고 상상해봅시다. IoT 장치에서는 파이썬 3.5, 플라스크 및 기타 파이썬 패키지를 실행할 수 있다고 합시다. 딕셔너리에서 문자열 메시지를 얻고 이를 IoT 장치에 연결된 OLED 디스플레이에 나타내는 코드를 작성하는 팀이 있을 것입니다. 문자열 메시지로 CRUD 작업을 수행하는 레스트풀 API와 대화할 웹 사이트와 모바일 웹에 대한 작업을 시작해야합니다.먼저, 주 자원인 메시지에 대한 요구사항을 지정해야 합니다. 메시지에 대해서는 다음 속성 또는 필드가 필요합니다.  정수 식별자  문자열 메시지  메시지가 OLED 디스플레이에 표시돼야 하는 시간을 나타내는 초 단위의 지속 시간  생성 날짜 및 시간 - 컬렉션에 새 메시지를 추가할 때 타임 스탬프가 자동으로 추가될 것이다.  “경고”및 “정보”와 같은 메시지 카테고리 설명  메시지가 OLED 디스플레이에 표시된 시간을 나타내는 정수 카운터  메시지가 적어도 한 번 OLED 디스플레이에 표시 됐는지 나타내는 bool 값다음 표에서는 첫 번째 API 버전에서 지원해야하는 HTTP, 동사, 범위, 의미를 보여줍니다. 각 메서드는 HTTP 동사와 범위로 구성되며 모든 메서드는 모든 메시지와 컬렉션에 대해 잘 정의된 의미를 갖습니다. API에서는 각 메시지마다 고유한 URL이 있습니다.            HTTP 동사      범위      의미                  GET      메시지 컬렉션      컬렉션 내에 저장된 모든 메시지를 얻어 이름의 오름차순으로 정렬합니다.              GET      메시지      단일 메시지를 받아옵니다.              POST      메시지 컬렉션      컬렉션 내에 새 메시지를 생성합니다.              PATCH      메시지      기존 메시지의 필드를 업데이트 합니다.              DELETE      메시지      기존 메시지를 삭제합니다.      각 HTTP 메서드가 수행하는 작업 이해http://localhost:5000/api/messages/가 메시지 컬렉션의 URL이라고 합시다. 이 URL에 숫자를 추가하면 지정된 숫자 값과 같은 id의 특정 메시지를 식별합니다. 예를 들어, http://localhost:5000/api/messages/6 id가 6인 메시지를 식별합니다.POST Method다음과 같이 POST HTTP 동사와 http://localhost:5000/api/messages/라는 요청 URL을 사용해서 HTTP 요청을 작성해 보내면 새 메시지를 작성할 수 있습니다. 또한 JSON 키-값 쌍에 필드 이름과 값을 제공해 새 메시지를 만들어야 합니다. 요청의 결과로 서버는 필드에 대해 제공된 값의 유효성을 검사하고 유효한 메시지인지 확인하고나서 메시지 딕셔너리에 이를 유지합니다.서버는 최근에 추가된 메시지와 함께 201 Created 상태 코드와 JSON으로 직렬화된 JSON 본문을 반환하는데, 이때 메시지 객체에는 서버가 자동으로 생성한 할당 ID가 들어갑니다.POST http://localhost:5000/api/messages/GET Method다음과 같이 GET HTTP 동사와 http://localhost:5000/api/messages/{id} 요청 URL을 사용해서 HTTP 요청을 작성해 보내면 id가 {id}의 자리에 지정된 숫자 값과 일치하는 메시지를 받을 수 있습니다. 예를 들어, 요청 URL인 http://localhost:5000/api/messages/82를 사용하면 서버는 id가 82와 일치하는 게임을 검색합니다. 이 요청의 결과로 서버는 딕셔너리에서 지정된 id를 가진 메시지를 찾을 것입니다.메시지가 발견되면 서버는 메시지 객체를 JSON으로 직렬화하고 200 OK 상태 코드와 직렬화된 메시지 객체가 들어간 JSON 본문을 반환할 것입니다. 지정된 id 또는 기본 키와 일치하는 메시지가 없으면 서버는 404 Not Found 상태를 반환합니다.GET http://localhost:5000/api/messages/{id}PATCH Method다음과 같이 PATCH HTTP 동사와 http://localhost:5000/api/messages/{id} 요청 URL을 사용해서 HTTP 요청을 작성해 보내면 id가 {id}의 자리에 지정된 숫자 값과 일치하는 메시지의 필드를 하나 이상 업데이트할 수 있습니다. 또한 JSON 키-값 쌍에 업데이트할 필드 이름과 새 값을 제공해야 합니다. 이 요청의 결과로 서버는 필드에 대해 제공된 값의 유효성을 검사하고 지정된 id와 일치하는 메시지에서 이 필드를 업데이트할 것이며 유효한 메시지라면 딕셔너리에 있는 해당 메시지를 업데이트합니다.서버는 200 OK 상태 코드와 최근 업데이트된 게임이 JSON으로 직렬화된 JSON 본문을 반환할 것입니다. 업데이트할 필드에 유효하지 않은 데이터를 제공하면 서버는 400 Bad Request 상태 코드를 반환합니다. 서버가 지정된 id를 가진 메시지를 찾지 못하면 서버는 404 Not Found 상태만 반환합니다.PATCH http://localhost:5000/api/messages/{id}DELETE Method다음과 같이 DELETE HTTP 동사와 http://localhost:5000/api/messages/{id} 요청 URL을 사용해서 HTTP 요청을 작성해 보내면 {id}의 자리에 지정된 숫자 값과 일치하는 id의 메시지를 제거할 수 있습니다. 예를 들어, http://localhost:5000/api/messages/15라는 요청 URL을 사용하면 서버는 id가 15와 일치하는 메시지를 삭제할 것입니다. 이 요청의 결과로 서버는 딕셔너리에서 지정된 id를 가진 메시지를 찾을 것입니다.메시지가 있으면 서버는 딕셔너리에게 이 메시지 객체와 관련된 항목을 삭제할 것을 요청하고 204 No Content 상태 코드를 반환합니다. 지정된 id와 일치하는 메시지가 없으면 서버는 404 Not Found 상태를 반환합니다.DELETE http://localhost:5000/api/messages/{id}플라스크와 플라스크 레스트풀 확장을 사용해 가상 환경 설정하기다음의 명령을 실행하고 가상 환경을 만듭니다.python3 -m venv ~/PythonREST/Flask01그리고 나서 다음의 명령을 실행하여 가상 환경을 활성화 시켜야합니다.source ~/PythonREST/Flask01/bin/activate이렇게 가상환경을 만들고 활성화 시켰다면 pip를 사용해서 다음과 같이 설치해야 합니다.pip install flask-restful응답용 상태 코드 선언from flask import jsonifyfrom app.exceptions import ValidationErrorfrom . import apidef bad_request(message):    response = jsonify({'error': 'bad request', 'message': message})    response.status_code = 400    return responsedef unauthorized(message):    response = jsonify({'error': 'unauthorized', 'message': message})    response.status_code = 401    return responsedef forbidden(message):    response = jsonify({'error': 'forbidden', 'message': message})    response.status_code = 403    return response@api.errorhandler(ValidationError)def validation_error(e):    return bad_request(e.args[0])  플라스크나 플라스크 레스트풀 모두에는 각 HTTP 상태 코드에 대한 변수 선언이 들어 있지 않습니다. 위의 예는 flasky(플라스크 기본서의 예제코드)의 HTTP 상태 코드입니다.모델의 생성이제, 메시지를 나타내는 데 사용할 간단한 MessageModel 클래스를 만들어야합니다. api 폴더에 새 models.py 파일을 생성합니다.class MessageModel:\tdef __init__(self, message, duration, creation_date, message_category):\t# We will automatically generate the new id\tself.id = 0\tself.message = message\tself.duration = duration \tself.creation_date = creation_date\tself.message_category = message_category\tself.printed_times = 0\tself.printed_once = FalseMessageModel클래스는 생성자, 즉, __init__ 메서드를 선언합니다. 이 메서드는 많은 인자를 받아 이를 사용해 message, duration, creation_date, message_category와 같은 이름의 속성을 초기화 합니다. id 속성은 0, printed_times도 0, print_once는 False로 설정됩니다. API 호출로 발생된 각 새 메시지의 식별자는 자동으로 증가할 것 입니다.딕셔너리를 저장소로 사용이제, MessageModel 인스턴스를 메모리 내장 딕셔너리에 유지하는데 사용할 MessageManager 클래스를 생성합니다. API 메서드는 MessageModel 인스턴스를 얻기, 삽입, 업데이트, 삭제하기 위해 MessageManager 클래스의 메서드를 호출합니다.from flask import Flaskfrom flask_restful import abort, Api, fields, marshal_with, reqparse, Resourcefrom datetime import datetimefrom models import MessageModelimport statusfrom pytz import utcclass MessageManager():    last_id = 0    def __init__(self):        self.messages = {}    def insert_message(self, message):        self.__class__  .last_id += 1        message.id = self.__class__.last_id        self.messages[self.__class__.last_id] = message    def get_message(self, id):        return self.messages[id]    def delete_message(self, id):        del self.messages[id]MessageManager 클래스는 last_id 클래스 속성을 선언하고 0으로 초기화합니다. 이 클래스 속성은 딕셔너리에 저장된 MessageModel 인스턴스에 대해 생성돼 할당된 최근 id를 저장합니다. 생성자, 즉, __init__메서드는 message 속성을 생성하고 빈 딕셔너리로 초기화합니다.      insert_message: 이 메서드는 message 인자에서 최근에 생성된 MessageModel 인스턴스를 받습니다. 이 코드는 last_id 클래스 속성의 값을 증가시키고 나서 그 결과 값을 수신된 메시지의 id에 대입합니다. 이 코드는 self.__class__를 사용해 현재 인스턴의 타입을 참조합니다. 마지막으로, message를 self.message 딕셔너리에 생성된 id인 last_id로 식별되는 키에 값으로 추가합니다.        get_message: 이 메서드는 self.message 딕셔너리에서 검색해야 하는 메시지의 id를 수신합니다. 이 코드는 데이터 소스로 사용 중인 self.message 딕셔너리에서 수신 id와 일치하는 키와 관련된 값을 반환합니다.        delete_message: 이 메서드는 self.message 딕셔너리에서 제거해야 하는 메시지의 id를 수신합니다. 이 코드는 데이터 소스로 사용 중인 self.message 딕셔너리에서 수신 id와 일치하는 키-값 쌍을 삭제합니다.  출력 필드 구성message_fields = {    'id': fields.Integer,    'uri': fields.Url('message_endpoint'),    'message': fields.String,    'duration': fields.Integer,    'creation_date': fields.DateTime,    'message_category': fields.String,    'printed_times': fields.Integer,    'printed_once': fields.Boolean}message_manager = MessageManager()\t위의 코드는 flask_restful.fields 모듈에 선언된 문자열과 클래스의 키-값 쌍을 가진 message_fields 딕셔너리(dict)를 선언한 것입니다.      field.Integer: 정수 값을 출력합니다.        fields.Url: URL의 문자열 표현을 생성합니다. 기본적으로 이 클래스는 요청되는 자원에 대해 상대 URI를 생성합니다. 이 코드는 endpoint 인자에 ‘message_endpoint’를 지정합니다. 그러면 클래스는 지정된 엔드포인트 이름을 사용할 것입니다.        fields.DateTime: UTC로 형식화된 datetime 문자열을 출력하는데 기본 RFC 822 형식입니다.        fields.Boolean: bool 값의 문자열 표현을 생성합니다.  플라스크 플러거블 뷰의 맨 위에서 풍부한 라우팅으로 작업플라스크 레스트풀은 플라스크 플러거블 뷰(Flask pluggable views) 위에 빌드된 자원을 레스트풀 API의 주요 구성 블록으로 사용합니다. 우리는 flask_restful.Resource 클래스의 서브 클래스를 만들어 지원되는 각 HTTP 동사의 메서드를 선언하면 됩니다. flask_restful.Resource의 서브 클래스는 레스트풀 자원을 나타내므로 메시지 컬렉션을 나타내는 클래스 하나와 메시지 자원을 나타내는 클래스를 선언해야 합니다.class Message(Resource):    def abort_if_message_doesnt_exist(self, id):        if id not in message_manager.messages:            abort(                status.HTTP_404_NOT_FOUND,                 message=\"Message {0} doesn't exist\".format(id))    @marshal_with(message_fields)    def get(self, id):        self.abort_if_message_doesnt_exist(id)        return message_manager.get_message(id)    def delete(self, id):        self.abort_if_message_doesnt_exist(id)        message_manager.delete_message(id)        return '', status.HTTP_204_NO_CONTENT    @marshal_with(message_fields)    def patch(self, id):        self.abort_if_message_doesnt_exist(id)        message = message_manager.get_message(id)        parser = reqparse.RequestParser()        parser.add_argument('message', type=str)        parser.add_argument('duration', type=int)        parser.add_argument('printed_times', type=int)        parser.add_argument('printed_once', type=bool)        args = parser.parse_args()        if 'message' in args:            message.message = args['message']        if 'duration' in args:            message.duration = args['duration']        if 'printed_times' in args:            message.printed_times = args['printed_times']        if 'printed_once' in args:            message.printed_once = args['printed_once']        return message      get: 이 메서드는 id 인자로 얻어야 하는 메시지의 id를 수신합니다. 요청된 id를 가진 메시지가 없는 경우에는 self.abort_if_message_doesnt_exist 메서드를 호출해 중단시킵니다. 해당 메시지가 존재하는 경우에는 message_manager.get_message 메서드가 반환한 id와 일치하는 id를 갖는 MessageModel 인스턴스를 반환합니다. get 메서드는 message_fields가 인자로 들어간 @marshal_with 데커레이터를 사용합니다. 이 데커레이터는 MessageModel 인스턴스를 가져와서 message_fields에 지정된 필드 필터링 및 출력 형식을 적용합니다.        delete: 이 메서드는 id 인자로 삭제해야 하는 메시지의 id를 받습니다. 요청된 id를 가진 메서드가 없는 경우에는 self.abort_if_message_doesnt_exist 메서드를 호출해 중단시킵니다. 해당 메시지가 존재하는 경우에는 수신된 id를 인자로해서 message_manager.delete_message 메서드를 호출해 데이터 저장소에서 MessageModel 인스턴스를 제거합니다. 그리고 나서 빈 응답 본문과 204 Not Content 상태 코드를 반환합니다.        patch: 이 메서드는 id 인자로 업데이트하거나 패치해야 하는 메시지의 id를 받습니다. 요청 된 id의 메시지가 없는 경우에는 self.abort_if_message_doesnt_exist 메서드를 호출해 중단시킵니다. 해당 메시지가 존재하는 경우에는 message_manager.get_message 메서드가 반환한 id와 일치하는 id를 가진 MessageModel 인스턴스를 메시지 변수에 저장합니다. 그 다음 행에서는 parser라는 이름의 flask_restful.reqparse.RequestParser 인스턴스를 생성합니다. RequestParser 인스턴스를 사용하면 이름과 타입을 인자로. 추가하고 나서 요청과 함께 받은 인자를쉽게 파싱할 수 있습니다. 이 코드는 파싱할 이름과 타입을 인자로 해서 parser.add_argument를 4번 호출합니다. 그러고 나서 parser.parse_args 메서드를 호출해 요청의 모든 인자를 파싱하고 반환된 딕셔너리를 args 변수에 저장합니다. 이 코드는 MessageModel 인스턴스의 args 딕셔너리에 새 값을 갖는 모든 속성을 업데이트 합니다. 요청에 특정 필드의 값이 포함되지 않은 경우에는 realted 속성을 변경하지 않습니다. 요청에는 값으로 업데이트할 수 있는 4개의 필드가 포함될 필요가 없습니다. 이 코드는 업데이트 된 message를 반환합니다. patch 메서드는 message_fields를 인자로 가진 @marshal_with 데커레이터를 사용합니다. 이 데커레이터는 MessageModel 인스턴스인 message를 가져와서 message_fields에 지정된 필드 필터링 및 출력 형식을 적용합니다.  이제 메시지 컬렉션을 나타내는 데 사용할 MessageList 클래스를 만들어봅시다.class MessageList(Resource):    @marshal_with(message_fields)    def get(self):        return [v for v in message_manager.messages.values()]    @marshal_with(message_fields)    def post(self):        parser = reqparse.RequestParser()        parser.add_argument('message', type=str, required=True, help='Message cannot be blank!')        parser.add_argument('duration', type=int, required=True, help='Duration cannot be blank!')        parser.add_argument('message_category', type=str, required=True, help='Message category cannot be blank!')        args = parser.parse_args()        message = MessageModel(            message=args['message'],            duration=args['duration'],            creation_date=datetime.now(utc),            message_category=args['message_category']            )        message_manager.insert_message(message)         return message, status.HTTP_201_CREATED      get: 이 메서드는 message_manager.messages 딕셔너리에 저장된 모든 MessageModel 인스턴스가 있는 리스트를 반환합니다. get 메서드는 message_fields를 인자로 가진 @marshal_with 데커레이터를 사용합니다. 이 데커레이터는 반환된 리스트의 각 MessageModel 인스턴스를 가져와서 message_fields에 지정된 필드 필터링 및 출력 형식을 적용합니다.        post: 이 메서드는 parser라는 flask_restful.reqparse.RequestParser 인스턴스를 생성합니다. RequestParser 인스턴스를 사용하면 이름과 타입을 인자로 추가하고 나서 POST 요청으로 받은 인자를 쉽게 파싱해 새 MessageModel 인스턴스를 만들 수 있습니다. 이 코드는 파싱할 3개의 인자로 이름과 타입을 넣어 parser.add_argument를 3번 호출합니다. 그러고 나서 parser.parse_args 메서드를 호출해 요청의 모든 인자를 파싱하고 반환된 딕셔너리를 args 변수에 저장합니다. 이 코드는 딕셔너리의 파싱된 인자를 사용해 message, duration, message_category 속성 값을 지정해 새 MessageModel 인스턴스를 생성하고 message 변수에 저장합니다. creation_date 인자의 값은 시간대 정보가 있는 현재 datetime으로 설정되므로 요청에서 파싱되지 않습니다. 그러고 나서 새 MessageModel 인스턴스(message)로 message_manager.insert_message 메서드를 호출해 이 새 인스턴스를 딕셔너리에 추가합니다. post 메서드는 message_fields를 인자로 가진 @marshal_with 데커레이터를 사용합니다. 이 데커레이터는 최근에 생성돼 지정된 MessageModel 인스턴스인 message를 취해 message_fields에 지정된 필드 필터링 및 출력 형식을 적용합니다. 이 코드는 HTTP 201 Created 상태 코드를 반환합니다.  다음의 표는 HTTP 동사와 범위의 각 조합에 대해 실행할 앞서 만든 클래스의 메서드를 보여줍니다.            HTTP 동사      범위      클래스와 메서드                  GET      메시지 컬렉션      MessageList.get              GET      메시지      Message.get              POST      메시지 컬렉션      MessageList.post              PATCH      메시지      Message.patch              DELETE      메시지      Message.delete      자원 라우팅과 엔드포인트에 대한 구성적절한 메서드를 호출하고 URL 규칙을 정의해 필요한 모든 인자를 전달하기 위해서는 필요한 자원 라우팅 구성을 만들어야 합니다.app = Flask(__name__)api = Api(app)api.add_resource(MessageList, '/api/messages/')api.add_resource(Message, '/api/messages/&lt;int:id&gt;', endpoint='message_endpoint')if __name__ == '__main__':    app.run(debug=True)위의 코드는 flask_restful.Api 클래스의 인스턴스를 생성하고 이를 api 변수에 저장합니다. api.add_resource 메서드를 호출할 때마다 자원, 특히 flask_restful.Resource 클래스의 이전에 선언된 서브 클래스 중 하나로 URL 경로가 잡힙니다. API에 대한 요청이 있고 URL이 api.add_resource 메서드에 지정된 URL 중 하나와 일치하면 플라스크는 지정된 클래스에 대한 요청에서 HTTP 동사와 일치하는 메서드를 호출합니다. 이 메서드는 표준 플라스크 라우팅 규칙을 따릅니다.플라스크 API에 대한 HTTP 요청 작성명령 행 도구에서의 작업 - curl과 httpiePOSTcurl -iX POST -H \"Content-Type: application/json\" -d '{\"message\": \"Welcome to IoT\", \"duration\": 10, \"message_category\": \"Information\"}' :5000/api/messages/위의 요청은 /api/messages/를 지정하므로 ‘/api/messages/’를 적용해 MessageList, post 메서드를 실행합니다. URL 경로에 매개 변수가 없기 때문에 이 메서드는 인자를 받지 않습니다. 요청에 대한 HTTP 동사가 POST이므로 플라스크는 post 메서드를 호출합니다. 새 MessageModel이 딕셔너리에 성공적으로 유지되면, 이 함수는 HTTP 201 Created 상태 코드와 함께 응답 본문에 JSON으로 직렬화된 최근 유지된 MessageModel을 반환합니다.GET이제 모든 메세지를 얻는 HTTP 요청을 작성해서 보내봅시다.curl -iX GET -H :5000/api/messages/404 Not Found이제 존재하지 않는 메세지를 얻을 HTTP 요청을 작성해서 보내봅시다.curl -iX GET :5000/api/messages/800서버는 id 인자 값으로 800을 사용해서 Message.get 메서드를 실행합니다. 이 메서드는 인자로 받은 id값과 일치하는 id의 MessageModel 객체를 얻는 코드를 실행하게 됩니다. 하지만 지정된 id값을 가진 메시지가 없기 때문에 MessageList.get 메서드의 첫 번째 행은 딕셔너리 키에서 id를 찾지 못하는 abort_if_message_doesnt_exist 메서드를 호출하고 flask_restful.abort 함수가 실행될 것입니다. 따라서 코드는 HTTP 404 Not Found 상태 코드를 반환합니다.PATCH이제 기존 메시지를 업데이트하는 HTTP 요청, 즉 두 필드의 값을 업데이트하라는 메시지를 작성해 보내봅시다.curl -iX PATCH -H \"Content-Type: application/json\" -d '{\"printed_once\": \"true\", \"printed_times\": 1}' :5000/api/messages/2지정된 id를 가진 MessageModel 인스턴스가 존재하고 성공적으로 업데이트된다면, 이 메서드 호출은 HTTP 200 OK 상태 코드와 함께 응답 본문 속에 JSON으로 직렬화시킨 최근 업데이트의 MessageModel 인스턴스를 반환합니다.DELETE이제 기존 메시지, 특히 마지막으로 추가한 메시지를 삭제하는 HTTP 요청을 작성해봅시다.curl -iX DELETE :5000/api/message/2이 요청은 /api/messages/ 뒤에 숫자가 있으므로, ‘/api/messages/'가 적용돼 Message.delete 메서드, 즉 Message 클래스의 delete 메서드를 실행합니다. 지정된 id를 가진 MessageModel 인스턴스가 존재하고 성공적으로 삭제됐다면, 이 메서드 호출은 HTTP 204 No Content 상태 코드를 반환합니다.",
        "url": "/blackruby-code//python/2018/01/15/study.html"
      }
      ,
    
      "web-2018-01-06-fungramming-html": {
        "title": "fungramming - 환경구축 자동화와 서버구축",
        "tags": "Web, Docker",
        "date": "January 6, 2018",
        "author": "Yoonkh",
        "category": "",
        "content": "재미그래밍 스터디 자료웹 환경 구축 자동화환경구축을 왜 자동화해야 할까요?보통 서버는 한 번 구축하면, 이후로는 특별힐 건드릴 일이 없으니 수동으로 대처해도 충분하다고 생각할 지 모르지만, 실제로는 새로 서버를 추가하거나 서비스 중인 환경에 새로운 라이브러리와 미들웨어를 설치하거나, 신기술을 검증하려고 개발 환경을 따로 준비해야하는 상황은 반드시 발생하기 마련입니다. 그때마다 매번 수동으로 환경을 구축한다는 것은 시간이 아무리 많아도 부족합니다. 하지만 절차를 자동화했다면 누구든 짧은 시간에 간단히 구축할 수 있습니다.      가상화 기술 도구                  Vagrant                    Docker                  프로비저닝 도구          Ansible            서버의 상태 테스트 도구          Serverspec      프로비저닝이란??프로비저닝이란, 비즈니스의 요구에 따라 시스템 자원을 자동으로 할당/회수, 재배치하여 시스템 자원을 최적화 하는 기능입니다.      서버자원 프로비저닝          서버의 CPU, Memory 등의 자원을 할당 또는 적절하게 배치해서 운영할 수 있도록 준비해 놓는 것을 서버자원 프로비저닝이라고 합니다.            OS 프로비저닝          OS를 서버에 설치하고, 구성 작업을 해서 OS가 기동되도록 준비해 놓는 것을 OS 프로비저닝이라고 합니다.            소프트웨어 프로비저닝          소프트웨어를 시스템에 설치/배포하고 필요한 구성 셋팅 작업을 해서 실행 할 수 있도록 해 놓는 것을 소프트웨어 프로비저닝이라고 합니다.      수동 환경 구축의 위험성환경 구축을 자동화하면 어떤 점이 좋을까??      수동으로 환경을 구축할 때는 다음과 같은 상황에서 문제점이 발생할 수 있습니다.                  서버를 새로 추가한다.                    서버에 라이브러리나 미들웨어를 설치한다.                    개발 환경을 가볍게 구축한다.            새로운 서버 추가      서버를 보강하는 방법                  스케일 업: 서버의 CPU와 메모리를 고성능 제품으로 업그레이드하여 처리 성능을 올리는 방법.                    스케일아웃: 서버 수를 늘려서 성능을 올리는 방법.            접속이 늘어나서 웹 서버나 애플리케이션 서버의 처리 성능이 부족하여 스케일아웃 방식으로 대처하는 경우가 있습니다.스케일 아웃 방식을 사용하면 비용면에서 유리하고, 서버가 한 대 정도 정지해도 서비스를 계속 제공할 수 있다는 장점이 있습니다. 하지만 웹 서버와 애플리케이션 서버를 새로 추가해야 한다는 단점도 있습니다.서버를 새로 추가할 때, 환경 구축이 자동화되어 있으면 간단한 커맨드로 서버를 추가할 수 있습니다. 하지만 환경 구축이 자동화 되어 있지 않으면, 서버를 추가하는 데 손이 많이 가고 실수를 하기도 쉽습니다.수동환경구축의 문제점을 회피하고 환경구축을 자동화하는 구체적인 방법을 알아보겠습니다.가상화 기술 도구 / 가상머신(VM): Vagrant가상화는 실제 운영체제 위에 가상화 소프트웨어를 설치한 후에 소프트웨어를 통해 하드웨어를 에뮬레이션한 후 이 위에 운영체제를 설치하는 것을 의미합니다. 가상화 해주는 소프트웨어를 하이퍼바이저라고합니다.다음 그림에서 보이는 가상화 부분에 해당하는 하이퍼바이저 설치, 운영체제 설치, 애플리케이션 설치 및 설정은 모든 개발자가 다 똑같이 해줘야 하는 작업입니다.  가상화의 개념Vagrant는 이런 문제를 해결하기 위한 솔루션으로 설정 스크립트를 기반으로 특정 환경의 가상 머신을 만들어서 신속하게 개발 환경을 구축하고 공유할 수 있게 만들어진 솔루션입니다.      Box 파일                  가상머신 시작시 기반이되는 이미지 파일                    가상환경을 만드는데 필요함                    일반적으로 OS 이미지에서 작성한다.                    Vagrant를 사용할 때 최소한의 설정 조건                              Vagrant 사용자                                sshd 시작                                프로비저닝 도구                                    Vagrantfile          가상머신의 사양이나 프로비저닝 도구의 지정 등 가상 머신의 구성              Ruby 기반으로 작성            기본적으로 파일과 프로비저닝 도구 설정으로 2개의 파일이 있다면 동일한 환경 구성이 가능      가상화 기술 도구 / Docker컨테이너 기반(프로세스)의 오픈소스 가상화 플랫폼(OS가상화와 조금은 다른 개념)      Docker의 주요 개념                  컨테이너                    도커이미지                    오버레이 네트워크                    유니온 파일 시스템            도커 이미지란??  컨테이너 실행에 필요한 파일과 설정값 등을 포함하고 있는 것으로 상태값을 가지지 않고 변하지 않음도커에서 가장 중요한 개념은 컨테이너와 함께 이미지라는 개념입니다이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것으로 상태값을 가지지 않고 변하지 않습니다. 컨테이너는 이미지를 실핸한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.도커 이미지 관리  URL방식으로 태그를 붙일 수 있음컨테이너란??  도커 이미지를 실행한 상태, 추가되거나 변하는 값을 컨테이너에 저장도커이미지와 컨테이너관계      도커이미지에서 여러개의 컨테이너를 생성가능        컨테이너의 상태가 바뀌거나 삭제되어도 도커이미지는 변하지 않고 그대로 남아 있음  오버레이 네트워크란?  오버레이 네트워크(Overlay network)는 물리 네트워크 위에 성립되는 가상의 컴퓨터 네트워크입니다. 이 오버레이 네트워크 안의 노드는 가상, 논리 링크로 연결될 수 있으며, 각 링크는 네트워크 안에서 많은 물리적 링크를 통하지만 물리적 링크를 고려하지는 않습니다.유니온 파일 시스템이란?  Unionfs는 Linux, FreeBSD 및 NetBSD를 위한 파일 시스템 서비스로, 다른 파일 시스템을 위한 통합 마운트를 구현 합니다. 분기라고하는 별도의 파일 시스템의 파일과 디렉토리를 투명하게 겹쳐서 하나의 일관된 파일 시스템으로 만듭니다. 병합 된 분기 내에서 동일한 경로를 갖는 디렉토리의 내용은 새로운 가상 파일 시스템 내의 단일 병합 된 디렉토리에서 함께 볼 수 있습니다.Command와 API도커 클라이언트의 커맨드 명령어는 정말 잘 만들어져 있습니다. 대부분의 명령어는 직관적이고 사용하기 쉬우며 컨테이너의 복잡한 시스템 구성을 이해하지 못하더라도 편하게 사용할 수 있습니다. 또한 http기반의 Rest API도 지원하여 확장성이 굉장히 좋고 훌륭한 3rd party 툴이 나오기 좋은 환경입니다.도커의 훌륭한 생태계도커는 굉장히 큰 생태계를 가지고 있고 커다란 기업과 협력하여 사실상 클라우드 컨테이너 세계의 사실상 표준이 되었습니다. 로깅, 모니터링, 스토리지, 네트워크, 컨테이너 관리, 배포 등 다양한 분야에서 다양한 툴들이 존재하며 아예 도커를 위한 OS도 존재합니다. 현재 도커를 기반으로한 오픈소스 프로젝트는 10만개가 넘고 굉장히 활발하게 진행중입니다.프로비저닝 도구 / Ansible      테스트 환경을 구축하는 데 사용되는 툴 Provision &amp; configuration management tool        python으로 개발되고 YAML이라는 언어를 통해 정의할 수 있고 json으로 통신          python github project중 상위 랭킹(6위)            해커 뉴스 분석을 보면 ansible이 많이 Mention이 되어지고 있음        오픈 소스 버전 (GPL)  Asible 장점 및 지원      빠른 SSH 통신, 빠른 provision이 가능        추후 상용 환경에서 사용할 때 agent 기반이면 방화벽 이슈, agent 데몬 관리라는 불편한 점이 존재(agent 방식은 확장성, 대규모 provision을 할 경우 매우 효과적이지만 서버와 통신하는 부분이 고도화되기 때문에 빠르고 간단한 provision을 할 수 없음)        자동 배포 환경이 쉬움        개발 가능성이 높은 오픈소스        대부분이 멱등성을 제공        playbook        ad-hoc 지원        병렬 provisioning 지원.        vagrant        jinja2  멱등성      여러 번 적용해도 결과는 바뀌지 않음        바뀌는 것이 없으면 당연히 배포되어도 바뀌지 않음        바뀌는 부분이 있으면 그 부분만 반영        shell, command, file module은 보장 되지 않는다  Ansible에서 멱등성이란??여러번 ansible 툴을 사용하더라도 동일한 결과값이 나올 수 있도록 제공되는 형태여야 합니다. 매번 다른 결과가 나오거나 에러가 나온다면 비 멱등성하다고 할 수 있습니다. ansible 툴의 거의 대부분의 모듈은 멱등성을 제공합니다.playbook플레이북은 애드훅 테스트 실행 모드와는 완벽하게 다른 사용방법이며 특히 강력한 사용 방법입니다. 간단히 말해 플레이북은 정말 간단하게 설정을 관리하고 다수의 머신에 대한 배포 시스템에 대한 기본적인 단위입니다. 기존에 존재해왔던 것과 달리 복잡한 어플리케이션 형태의 배포에 매우 적절합니다. 플레이북은 설정을 정의 할 수 있으며 특정 머신의 집합을 오가며 다른 작업을 수행하도록 수동으로 작업 순서를 설정하는 것도 가능합니다.ad-hocAdhoc이라는 의미는 임시적으로 수행하는 의미. ansible의 playbook을 작성하여 수행하는 것이 아니라 임시적으로나 또는 특별하게 어떤 작업을 수행하기 위해서 사용할 수 있는 실행방법이라고 할 수 있습니다.Ansible의 한계      시스템의 초기 설치 수행은 불가능 (kickstart, pxe 등을 사용해야함)        시스템 모니터링은 지원하지 않음        시스템 변경사항은 추적하지 않음  서버의 상태 테스트 도구 / serverspecServerspec은 루비 테스트 프레임워크인 RSpec 형식으로 인프라 계층을 테스트할 수 있으며, 주로 통합 테스트를 지원합니다. 특정 구성 관리 도구에 의존하지 않으므로 어떤 도구를 사용해도(또는 어떤 도구도 사용하지 않고 직접 인프라를 구축했다고 해도) 테스트를 작성할 수 있다는 장점이 있습니다.Serverspec으로 테스트해야 하는 대상은 단위 테스트 수준보다 통합 테스트 수준, 조건 분기 등을 포함해 복잡한 구성이 필요한 경우에 사용하면 좋습니다.Serverspec의 원래 목적은 ‘인프라의 상태를 테스트’하는 것이 아니라 ‘인프라의 상태를 기술한 코드를 테스트’하는 것입니다. 코드 리팩터링을 지원하며 코드의 불안정한 부분을 테스트하는 기능도 지원합니다. 따라서 코드화를 가속시키는 성격의 도구입니다.웹서버 구축웹 브라우저로 표시할 HTML이나 이미지 데이터 등을 모아 두었다가 요청에 따라 전송하는 서버를 웹 서버라고 합니다. 웹 브라우저에서 HTTP를 사용해서 웹 서버에 요청을 보내면, 웹 서버는 그 요청을 받아서 필요한 처리를 합니다. 웹 서비스를 제공하려면 서버에 웹 서버 프로그램을 설치해야 합니다. 대표적인 것으로는 아파치와 Nginx등이 있습니다.아파치아파치는 1995년 NCSA httpd1.3을 기반으로 개발을 시작한 후로 20년 가까이 높은 시장 점유율을 유지하며 1위 자리를 지켜 왔습니다. 최근 몇 년은 계속 점유율이 떨어지는 추세이지만, 오랜 역사를 이어 온 만큼 안정적이며 많은 사용자에게 사랑받는 웹서버입니다.워낙 다양한 추가기능에, 구축이 쉽다는 이유 때문에 많이 쓰고 있습니다. 하지만 Apache자체만으로 엄청 무거운데다가, Squid와 함께 Slowloris취약점이 발견되었기에, 보통 프로그래밍 능력이 능숙한 사람들이나, 대형사이트 운영자는 Nginx,IIS를 주로 쓰고 있습니다.오픈소스(open source) 라이선스에 따라 무료로 배포되어 원하는 사람들이 자유롭게 사용할 수 있습니다.유닉스·윈도 등을 비롯해 거의 모든 운영체제와 시스템에서 운용이 가능합니다.Apache의 특징      쓰레드 / 프로세스 기반 구조로 요청 하나당 쓰레드 하나가 처리하는 구조        사용자가 많으면 많은 쓰레드 생성, 메모리 및 CPU 낭비가 심함        하나의 쓰레드 : 하나의 클라이언트 라는 구조  Apache의 특징      정적 컨텐츠의 효율적인 제공        Tomcat보다 10% 더 향상된 속도        클러스터링을 제공        보안문제의 해결        다중 웹사이트 호스팅을 제공        다양한 모듈을 제공  Nginx트래픽이 많은 웹사이트를 위해 확장성을 위해 설계한 비동기 이벤트 기반구조의 웹서버 소프트웨어입니다.더 적은 자원으로 더 빠르게 서비스한다가벼움과 높은 성능을 목표로 만들어 졌으며, 러시아의 프로그래머,이고르 시쇼브가 Apache의 C10K Problem(하나의 웹서버에 10,000개의 클라이언트의 접속을 동시에 다룰 수 있는 기술적인 문제)를 해결하기 위해 만든 Event-driven구조의 HTTP, Reverser Proxy, IMAP/POP PROXY server를 제공하는오픈소스 서버 프로그램입니다.Apache는 전 세계 서버에 70%의 점유율(2015.7기준)을 차지하고 있던 무지막지한 서버였지만, 지금은 다릅니다.nginx의 특징      비동기 Event-Driven 기반 구조.        다수의 연결을 효과적으로 처리가능.        대부분의 코어 모듈이 Apache보다 적은 리소스로 더 빠르게 동작가능        더 작은 쓰레드로 클라이언트의 요청들을 처리가능  Nginx의 장점      보안앞 단의 nginx로 리버스 프록시로 사용하고 뒷단에는 WAS를 설치하여 외부에 노출되는 인터페이스에 대해 Nginx WAS 부분만 노출 가능합니다. 익명의 사용자가 직접적인 Web Server로의 접근을 한다라고 하면 문제가 발생할 수 있기 때문에 직접적이지 않고 한 단계를 더 거침으로써 보안적인 부분을 처리할 수 있습니다.        Backend-service 장애 대응 처리Backend-service 에 대해 max fails, fail timeout시 백업 서버로 진입할 수 있도록 처리 가능합니다.        빠른 속도  ",
        "url": "/blackruby-code//web/2018/01/06/fungramming.html"
      }
      ,
    
      "code-2018-01-03-list-array-html": {
        "title": "List와 array의 차이점",
        "tags": "Python, Code, Algorithm, Array",
        "date": "January 3, 2018",
        "author": "Yoonkh",
        "category": "",
        "content": "List와 Array의 차이점  배열의 장점: 인덱스가 있어서 데이터의 접근이 빠르다.  배열의 단점: 인덱스 &lt;-&gt; 데이터 매핑 구조이기 때문에, 데이터가 삭제되면 해당 공간이 낭비된다.List는 배열의 index라는 장점을 버리고, 빈틈없는 데이터의 적재라는 장점을 취한 자료구조이다.배열에 데이터를 추가하려면 기존에 있는 데이터 혹은 인덱스와 매핑된 자리에만 데이터를 삽입할 수 있다. 리스트의 경우,인덱스가 하나씩 밀리면서 순서를 유지한다.결론적으로 List에서는 인덱스보다, 데이터들 간의 순서를 더 중요시한다.",
        "url": "/blackruby-code//code/2018/01/03/List&amp;Array.html"
      }
      ,
    
      "python-2017-12-31-pythonapi-html": {
        "title": "RESTful 파이썬 웹 제작",
        "tags": "Python, Django, RESTfulAPI",
        "date": "December 31, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "RESTful 파이썬 웹 서비스 제작장고를 이용한 레스트풀 API의 개발간단한 SQLite 데이터 베이스와 대화하는 레스트풀 API 디자인우리는 가장 적절한 객체 관계형 매핑을 선택하고 구성하는 데 시간을 낭비하고 싶지 않다. 가능한 한 빨리 레스트풀 API를 완성하고 모바일 앱을 통해 대화를 시작하길 원한다. 우리는 게임을 데이터베이스로 운영하길원하는데, 제작 준비가 필요하지 않으므로 복잡한 설치 또는 구성에 시간을 낭비하지 않고 가능하면 가장 단순한 관계형 데이터베이스를 사용할 수 있다.DRF라는 장고 레스트 프레임워크를 사용하면, 이 작업을 쉽게 완료해서 레스트풀 웹 서비스의 첫 번째 버전에 대한 HTTP 요청을 시작할 수 있다. 여기서는 새로운 장고 레스트 프레임 워크 프로젝트의 기본 데이터베이스인 매우 간단한 SQLite 데이터베이스로 작업할것이다.주요 자원에 대한 요구사항을 지정해야 한다. 다음 속성 또는 필드가 필요하다.  정수 식별자  이름 또는 타이틀  출시일  3D RPG 또는 2D 모바일 아케이드와 같은 게임 카테고리 디스크립션  플레이어가 적어도 한 번 게임을 했는지 여부를 나타내는 bool 값다음의 표는 첫 번째 API 버전에서 지원해야 하는 HTTP 동사, 범위, 그 메서드에 대한 의미를 보여준다.            HTTP동사      범위      의미                  GET      게임 컬렉션      컬렉션의 모든 저장도니 게임을 얻고, 이름에 따라 오름차순으로 정렬한다.              GET      게임      게임 하나만 얻는다.              POST      게임 컬렉션      컬렉션에 새 게임 생성              PUT      게임      기존 게임 업데이트              DELETE      게임      기존 게임 삭제      각 HTTP 메서드가 수행하는 작업 이해새 게임을 만들려면 HTTP 동사(POST)와 요청 URL로 HTTP 요청을 작성해 보내야한다. 더욱이 JSON 키-값 쌍으로 필드 이름과 값을 제공해 새 게임을 만들어야 한다. 요청 결과, 서버는 필드에 제공된 값의 유효성을 검사하고 유효한 게임인지 확인한 후 데이터베이스에 저장한다.서버는 적절한 테이블에 새 게임이 들어간 새 행을 삽입하고, JSON으로 직렬화된 최근 추가 게임의 JSON 본문과 201 Created 상태 코드를 반환하는데, 여기에는 데이터베이스가 자동으로 생성하고 게임 객체에 지정한 할당 id 또는 기본 키가 포함된다.POST http://localhost:8000/games/id 또는 기본 키가 지정된 숫자 값과 일치하는 게임을 얻으려면 HTTP 동사(GET)와 요청 URL을 사용해서 HTTP 요청을 작성해 보내야 하는데, 여기서 {id}에는 id나 기본 키에 해당하는 숫자 값을 저장한다.GET http://localhost:8000/games/{id}/id 또는 기본 키가 지정된 숫자 값과 일치하는 게임을 업데이트하려면 HTTP 동사(PUT)와 요청 URL을 사용해 HTTP 요청을 작성해 보내야 하는데, 여기서 {id} 자리에는 제공된 데이터로 생성된 게임의 해당 값으로 대체한다.PUT http://localhost:8000/games/{id}/id 또는 기본 키가 지정된 숫자 값과 일치하는 게임을 제거하려면 HTTP 동사(DELETE)와 요청 URL을 사용해서 HTTP 요청을 작성해 보내야 하는데, 여기서 {id} 자리에 해당 숫자를 적는다.DELETE http://localhost:8000/games/{id}/경량 가상 환경에서의 작업먼저, 가상 환경을 위한 대상 폴더 또는 디렉터리를 선택해야 한다.~/PythonREST/Django터미널을 열고, 다음 명령을 실행해 가상 환경을 만든다.python3 -m venv ~/PythonREST/Django01맥 OS 또는 리눅스에서 bash 셸을 사용하게 터미널을 구성한 경우, 다음 명령을실행해 가상 환경을 활성화해야한다.source ~/PythonREST/Django01/bin/activate가상환경이 활성화 되면 Yoon-MacBook-Pro:~ project$ 에서 (Django) Yoon-MacBook-Pro:~ project$으로 프롬프트가 변경된다.장고 레스트 프레임워크에서의 가상 환경 설정이제 다음의 명령을 실행해 장고 웹 프레임워크를 설치해야 한다.pip install Django장고 웹 프레임워크를 설치했으므로 장고 레스트 프레임워크를 설치할 수 있다.pip install djangorestframework이제 다음 명령을 실행해 gamesapi라는 새 장고 프로젝트를 만든다.django-admin.py startproject gamesapi그리고 나서 다음 명령을 실행해 gamesapi 장고 프로젝트 내에 games라는 새 장고 앱을 만든다.python manage.py startapp games위의 명령으로 다음 파일들이 들어간 새 gamesapi/games 서브 폴더가 생성되었다.  __init__.py  admin.py  apps.py  models.py  tests.py  views.pyapps.py파일의 파이썬 코드 ex)From django.apps import AppConfigClass GamesConfig(AppConfig):\tname='games'이제 gamesapi/settings.py 파일을 열고 설치된 앱 선언의 문자열 리스트를 지정하는 행인 INSTALLED_APPS행을 찾아 다음의 내용을 추가한다.  ‘rest_framework’  ‘games.app.GamesConfig’모델 제작games/models.py 파일을 연다. 아래 행은 이 파일의 초기 코드를 보여주는데, 하나의 import문과 모델을 생성해야 함을 나타내는 주석이 있다.아래 행은 Game 클래스, 특히 games/models.py 파일에 있는 Game 모델을 만들기 위한 새 코드를 보여준다.From django.db import models Class Game(models.Model):\tCreated = models.DateTimeField(auto_now_add=True)\tName = models.CharField(max_length=200, blank=True, default='')\trelease_date = models.DateTimeField()\tgame_category = models.CharField(max_length=200, blank=True, default='')\tplayed = models.BooleanField(default=False)\t\tclass Meta:\t\tordering = ('name',)다음으로는 새 Game 모델의 초기 마이그레이션을 만들어야 한다. 장고는 SQLite 데이터베이스를 사용한다.python manage.py makemigrations games이제 생성된 마이그레이션을 적용하기 위해 다음 파이썬 스크립트를 실행한다.python manage.py migrate위의 명령을 실행하면 gamesapi 프로젝트의 루트 폴더에 db.sqlite3 파일이 생긴 것을 볼 수 있다. 장고가 생성한 테이블을 보려면 SQLite 명령 행 또는 SQLite 데이터베이스의 테이블을 쉽게 점검할 수 있게 해주는 애플리케이션을 사용하면 된다.다음의 명령을 실행해 생성된 테이블을 나열해 볼 수 있다.sqlite3 db.sqlite3 '.tables'SQLite 데이터베이스 엔진과 데이터베이스 파일 이름은 gamesapi/settings.py 파이썬 파일에 지정돼 있다. 다음 행은 장고가 사용하는 모든 데이터베이스에 대한 설정을 담고 있는 DATABASE 딕셔너리의 선언을 보여준다.DATABASES = {\t'default': {\t\t'ENGINE': 'django.db.backends.sqlite3',\t\t'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\t}}마이그레이션을 실행한 후, SQLite 데이터베이스에는 다음 테이블이 생겼을 것이다.  auth_group  auth_group_permissions  auth_permission auth_user  auth_user_groups  auth_user_groups_permissions  django_admin_log  django_content_type  django_migrations  django_session  games_game  sqlitesequencegames_game 테이블에는 SQLite 형식의 다음 행(필드라고도 함)이 있으며, 그 중 모두가 null 값도 가능한 것은 아니다.  id: The integer primary key, an autoincrement row  created: datetime  name: varchar(200)  release_date: datetime  game_category: varchar(200)  played: bool다음 행은 우리가 마이그레이션을 실행했을 때 장고가 생성한 SQL 생성 스크립트다.CREATE TABLE \"games_game\" {\t\"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\t\"created\" datetime NOT NULL,\t\"name\" varchar(200) NOT NULL,\t\"release_date\" datetime NOT NULL,\t\"game_category\" varchar(200) NOT NULL,\t\"played\" bool NOT NULL}",
        "url": "/blackruby-code//python/2017/12/31/PythonAPI.html"
      }
      ,
    
      "web-2017-12-25-web7-html": {
        "title": "웹 엔지니어 - 환경구축의 자동화",
        "tags": "Web, Docker",
        "date": "December 25, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "환경 구축 자동화수동 환경 구축의 위험성환경 구축을 자동화 하려면 어떤 점이 좋을까요? 일단 수동으로 환경을 구축할 때는 다음과 같은 상황에서 문제가 생길 수 있습니다.  서버를 새로 추가한다  서버에 라이브러리나 미들웨어를 설치한다  개발 환경을 가볍게 추구한다새로운 서버 추가  서버를 보강하는 방법            방법      설명                  스케일업      서버의 CPU와 메모리를 고성능 제품으로 업그레이드하여 처리 성능을 올리는 방법              스케일아웃      서버 수를 늘려서 성능을 올리는 방법      서버에 라이브러리나 미들웨어 설치서버에 라이브러리나 미들웨어를 추가하는 상황을 생각해봅시다. 당연히 라이브러리의 미들웨어를 설치할 때 시간이 걸리고, 서버 수가 늘어나면 어떤 서버에는 설치하고 어떤 서버에는 설치하지 않는 상황도 발생합니다. 서버마다 같은 라이브러리와 미들웨어를 사용할 때, 같은 버전을 설치했는지 확인하고 싶어도 여러 서버의 버전을 관리해야 하므로 이 또한 큰일입니다.하지만 환경 구축을 자동화하고, 관리작업을 ansible등 프로비저닝 도구와 서버 상태를 테스트하는 Serverspec에 맡기는 편이 안심할 수 있고 안전합니다.간단한 개발 환경 구축지금까지 소개한 사례로 환경 구축을 수동으로 할 때 여러 가지 번거로운 문제가 생길 수 있음을 알 수 있었습니다. 그래서 이런 문제들을 회피하고 환경 구축을 자동화하는 방법을 사용해야 합니다.VagrantVagrant는 한마디로 VirtualBox나 VMWare, Amazon EC2와 같은 가상화 소프트웨어의 프런트 엔드라고 할 수 있습니다. CUI로 간단히 서버를 시작하거나 정지할 수 있습니다.Vagrant 도입$ vagrant --versionVirtualBox 설치$ VBoxManage -vVagrant로 가상 머신 실행 ( CentOS7의 예 )$ vagrant box add centos7 \\&gt; https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/ \\ &gt; centos-7.0-x86_64.boxvagrant box list 커맨드로 사용할 수 있는 Box 목록을 확인할 수 있습니다.$ vagrant box listBox를 사용하여 Vagrant를 초기화합니다.$ mkdir -p ~/work/vagrant/sample$ cd ~/work/vagrant/sample$ vagrant init centos7가상머신 관리가상 머신을 일시정지할 때는, vagrant suspend 커맨드, 일시정지에서 복귀할 때는 vagrant resume 커맨드, 셧다운할 때는 vagrant halt 커맨드를 사용합니다. 서버를 다시 실행하려면 vagrant up이라고 하면 됩니다.$ vagrant suspend$ vagrant halt커맨드와 셸 스크립트 실행이제 가상 머신의 시작, 일시정지, 셧다운 등 작업을 할 수 있습니다. 이외에도 Vagrant를 사용하면 여러 가지 동작을 할 수 있습니다.예를 들어, 시작할 때 간단한 커맨드를 실행시켜 봅시다. Vagrantfile의 내용에 프로비저닝 처리를 추가해서 vagrant up 합니다.VAGRANTFILE_API_VERSION = \"2\"Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|\tconfig.vm.box = \"centos7\"\tconfig.vm.provision :shell, inline: \"echo foobar\"end프로비저닝은 처음 시작할 때만 실행합니다. 처리가 필요할 때는 명시적으로 vagrant up –provision으로 지정하거나 프로비저닝만 실행하는 vagrant provision 커맨드를 사용합니다.프로비저닝을 실행해봅시다.$ vagrant provision터미널에 foobar가 출력되었을 것입니다. 이처럼 가상 머신을 시작할 때 임의의 커맨드를 실행 할 수 있습니다. 게다가 단순 커맨드뿐만 아니라 셸 스크립트를 사용할 수도 있습니다.여러 대의 가상 머신을 한 번에 실행두 대의 가상 머신 (web1과 web2)을 한 번에 실행해 보겠습니다. 생각보다 간단해서 다음처럼 private_network 설정에서 각각 다른 IP를 지정하면 됩니다. 하지만 이렇게 하면 시작할 때마다 ssh의 포트포워드 포트 번호가 바뀌어서 불편합니다. forwarded_port 설정을 변경해서 호스트 쪽 포트 번호를 임의의 포트 번호로 고정해둡시다.VAGRANTFILE_API_VERSION = \"2\"Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|\tconfig.vm.define :web1 do |node|\t\tnode.vm.box=\"centos7\"\t\tnode.vm.network \"rivate_network\", ip: \"192.0.0.1\"\t\tnode.vm.network \"forwarded_port\", guess: 22, host: 2000, id: \"ssh\"\tend\t\t\tconfig.vm.define :web2 do |node|\t\tnode.vm.box=\"centos7\"\t\tnode.vm.network \"private_network\", ip: \"192.0.0.1\"\t\tnode.vm.network \"forwarded_port\", guess: 22, host: 2001, id: \"ssh\"\tendend가상 머신에 ssh로 로그인vagrant ssg-config 커맨드는 ‘~/.ssh/config’용 설정을 생성하므로, 이 커맨드를 사용해서 ssh 커맨드로 로그인할 수 있게 하면 편리합니다.$ vagrant ssh-config$ vagrant ssg-config &gt;&gt; ~/.ssh/config$ ssh web1Amazon EC2 인스턴스 실행Amazon EC2를 사용해서 AWS에 서버를 실행 해 봅시다.먼저 Vagrantfile을 작성합니다. 이번에는 vagrant init 커맨드를 실행할 때 인수를 지정하지 않습니다.$ mkdir ~/work/vagrant/ec2$ cd !!:$cd ~/work/vagrant/ec2$ vagrant initProvider로 VirtualBox가 아니라 AWS를 사용하려면 vagrant-aws 플러그인이 필요합니다. vagrant plugin install 커맨드로 플러그인을 설치합니다.$ vagrant plugin install vagrant-aws$ vagrant box add dummy https://github.com/mitchellh/vagrant-aws/raw/master/dummy.boxdummy라는 이름의 Box를 추가했습니다.$ vagrant box listcentos7 (virtualbox, 0)dummy (aws, 0)나머지 편리한 플러그인 소개Vagrant 편리한 플러그인을 소개합니다.sahara 플러그인sahara는 샌드박스 모드를 유효하게 하는 플러그인입니다.$ vagrant plugin install sahara# 샌드박스 모드 실행 $ vagrant sandbox on # 롤백하고 싶을 때 $ vagrant sandbox rollback# 확장하고 싶을 때 $ vagrant sandbox commit# 샌드박스 모드 종료(커밋하지 않은 변경은 취소된다)$ vagrant sandbox off# 샌드박스의 상태 확인$ vagrant sandbox statusvagrant-cachier 플러그인프로비저닝 등에서 다운로드한 yum 등 패키지를 캐싱하여 다음부터 다운로드 시간을 줄여 주는 플러그인 입니다.$ vagrant plugin install vagrant-cachierglobal-statusvagrant global-status 커맨드도 꽤 편리합니다. 이전에는 플러그인으로 제공했지만, 최근에는 Vagrant에 포함됐습니다. 이 플러그인을 사용하면 Vagrant에서 다루는 모든 가상 머신의 현재 상태를 표시합니다. 어느 가상 머신이 어느 경로에서 실행 중인지 알 수 있으므로 가상 머신 관리에 사용할 수 있습니다.Vagrant 가상화 이미지하드웨어 위에 호스트 OS가 있고, 그 위에 하이퍼바이저라는 가상 머신을 에뮬레이트하는 기능이 있습니다. 하이퍼바이저 위에서 가상 머신을 실행하고, 그 안에서 게스트 OS를 동작합니다. 하이퍼바이저에 해당하는 것이 VirtualBox나 VMware, Amazon EC2 등 가상화 소프트웨어입니다.AnsibleAnsible은 프로비저닝 도구 중 하나로, 매우 문턱이 낮아 간편하게 도입할 수 있는 것이 특징입니다. ssh 로그인만 할 수 있으면 대상 서버에는 아무것도 필요 없습니다.Ansible 도입$ vagrant init centos7그리고 다음처럼 Vagrantfile을 설정합니다.VAGRANTFILE_API_VERSION = \"2\"Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|\tconfig.vm.define :server1 do |node|\t\tnode.vm.box=\"centos7\"\t\tnode.vm.network \"rivate_network\", ip: \"192.0.0.1\"\t\tnode.vm.network \"forwarded_port\", guess: 22, host: 2000, id: \"ssh\"\tend\t\t\tconfig.vm.define :server2 do |node|\t\tnode.vm.box=\"centos7\"\t\tnode.vm.network \"private_network\", ip: \"192.0.0.1\"\t\tnode.vm.network \"forwarded_port\", guess: 22, host: 2001, id: \"ssh\"\tendend나머지는 vagrant up 커맨드를 실행하면 됩니다. 이것으로 server1과 server2라는 가상 머신 두 대를 시작합니다. 다음처럼 ssh로 로그인할 수 있게 합시다.$ vagrant ssg-config &gt;&gt; ~/.ssh/config$ ssh server1이 상태로는 어느 서버에 접속했는지 쉽게 알 수 없어 불편하므로, 가상 머신을 시작할 때 프로비저닝으로 호스트 이름을 설정하는 처리를 추가하겠습니다.VAGRANTFILE_API_VERSION = \"2\"change_hostname = &lt;&lt;SCRIPTsudo hostname $1sudo echo HOSTNAME=$1 &gt;&gt; /etx/sysconfig/networksudo service network restartSCRIPTVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\tconfig.vm.define :server1 do |node|\t\tnode.vm.box=\"centos7\"\t\tnode.vm.network \"rivate_network\", ip: \"192.0.0.1\"\t\tnode.vm.network \"forwarded_port\", guess: 22, host: 2000, id: \"ssh\"\t\tnode.vm.provision :shell so |s|\t\t\ts.inline = change_hostname\t\t\ts.args = ['server1']\t\tend\tend\t\t\tconfig.vm.define :server2 do |node|\t\tnode.vm.box=\"centos7\"\t\tnode.vm.network \"private_network\", ip: \"192.0.0.1\"\t\tnode.vm.network \"forwarded_port\", guess: 22, host: 2001, id: \"ssh\"\t\tnode.vm.provision :shell do |s|\t\t\ts.inline = change_hostname\t\t\ts.args = ['server2']\t\tend\tendend인벤토리 파일 준비이번에는 host 이름으로 인벤토리 파일을 만들었습니다. 임의의 그룹을 정의할 수도 있으므로, server1과 server2 양쪽을 포함하는 그룹을 ‘all-server’로, server1만 포함하는 그룹을 ‘dev-servers’로 했습니다.[all-server]server[1:2][dev-servers]server1간단한 처리 실행예를 들어, Ansible을 사용해서 server1에 ping을 날려 봅시다. -i 옵션으로 인벤토리 파일을 지정하고, 그 다음에 대상으로 할 서버를 지정합니다.$ ansible -i hosts server1 -m pingserver1뿐만 아니라 server2에서도 한꺼번에 ping을 실행하려면, 인벤토리에 지정한 그룹 이름인 all-servers나 all이라는 특별한 키워드를 지정해야합니다.$ ansible -i hosts all-servers -m pingplaybook으로 복잡한 처리 실행좀 더 복잡한 처리를 실행하려면, ansible-playbook 커맨드를 사용합니다.MySQL을 설치하는 상황을 생각해 보겠습니다. 우선 MySQL을 설치해서 실행하는 설정 파일을 준비합니다. 예를 들어 mysql-playbook.yml이라고 합시다.---- hosts: dev-servers # 대상 서버를 지정한다   sudo: yes  tasks:   - name: add repository    yum: name=http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm state-present        - name: install mysql    yum: name=mysql-server enablerepo=epel,rpmforge state-installed # 설치된 상태로 한다  - name: start mysql    service: name=mysqld state=running enabled=yes # 시작된 상태로 한다실행 커맨드$ ansible-playbook -i hosts mysql-playbook.yml멱등성 확보이번에는 server2에도 MySQL을 설치하는 경우를 생각해보겠습니다.---- hosts: all-servers # 이곳을 변경한다   sudo: yes  tasks:  - name: add repository    yum: name=http://repo.mysql.com/mysql-community-release-el7-t.noarch.rpm state=present          - name: install mysql    yum: name=mysql-server enablerepo=epel,rpmforge state=installed # 설치된 상태로 한다   - name: start mysql     service: name=mysqld state=running enabled=yes # 시작된 상태로 한다실행 커맨드$ andible-playbook -i hosts mysql-playbook.yml파일 끝 추가yum 모듈과 service 모듈을 사용한 경우라면 멱등성을 확보하므로 괜찮지만, shell 모듈로 임의의 커맨드를 실행할 때는 멱등성을 확보하지 않으므로 구현하는 쪽에서 멱등성을 확보할 필요가 있습니다. 예를 들어, 다음 playbook을 실행하면 실행할 때마다 파일 끝에 test라는 출력을 추가합니다.---- hosts: dev-servers  tasks:   - shell: echo test &gt;&gt; /tmp/foobar이래서는 곤란합니다. 그래서 이때는 다음처럼 register 모듈과 when 모듈을 사용합니다.---- hosts: dev-servers  tasks:   - shell: echo test &gt;&gt; /tmp/foobar    register: result  - shell: echo test &gt;&gt; /tmp/foobar    when: result.stdout.find('test') == -1다음에서는 테스트에서 when 모듈을 사용하여 여기서 지정한 조건을 만족할 때만 /tmp/foobar 끝에 test라는 문자열을 추가하도록 지정했습니다. result.stdout.find(‘test’)는 표준 출력 안에 test 문자열이 포함되어 있으면 그 인덱스를, 포함되어 있지 않으면 -1을 반환합니다. 이렇게 지정하면 /tmp/foobar에 test 문자열이 없을 때만 끝에 test를 추가하는 조건부 처리가 가능합니다.먼저 /tmp/foobar에 test가 없을 때를 확인해 보자. 테스트를 위해 server1에 /tmp/foobar라는 이름으로 빈 파일을 하나 만듭니다.$ ssh server1 # server1에 접속해서 $ touch /tmp/foobar # 빈파일을 만든다$ logout$ ansible-playbook -i hosts shell-playbook.yml나머지 편리한 모듈 소개changed_when 모듈은 어떤 때 changed로 표시할지 조건을 지정합니다. 또, debug 모듈은 특정 변수 이름의 내용과 메시지를 출력할 수 있습니다.--- - hosts: dev-servers  tasks:  - shell: cat /tmp/foobar    register: result    changed_when: False  - shell: echo test &gt;&gt; /tmp/foobar    when: result.stdout.find('test') == -1  - debug: var=Serverspec서버의 상태를 테스트하는 프레임워크인 Serverspec은 프로비저닝 결과를 제대로 설정했는지 확인할 때 도움을 줍니다. Ruby로 구현되어 있으며, Ruby 테스트 프레임워크인 RSpec에 따른 형태로 기술할 수 있습니다.Serverspec 도입$ gem install serverspec테스트 드리븐 프로비저닝아파치용 테스트 템플릿을 생성했지만, 이번에는 아파치가 아니라 Nginx를 사용할 것이므로 다음처럼 httpd를 nginx로 변경합니다.require 'spec_helper'# Nginx가 설치되어 있을 것describe package('nginx') do \tit { shoud be_installed }end# Nginx가 자동 실행하도록 설정되어 있을 것# Nginx가 실행 중일 것describe service('nginx') do \tit { should be_enabled }\tit { should be_running }end # 80번 포트가 열려 있을 것describe port(80) do \tit { should be_listening }end테스트의 실행$ rake spec모든 테스트가 실패할것입니다. server1에는 아직 Nginx가 설치되어 있지 않으니 당연한 결과입니다.그럼, Nginx를 설치하고 그상태에서 테스트하면 성공한느지 확인해 봅시다.--- - hosts: dev-servers  sudo: yes  tasks:   - name: install nginx    yum: name=nginx state=installed  - name: start nginx    service: name=nginx state=running enabled=yes$ ansible-playbook -i hosts nginx-playbook.ymlDockerDocker는 Go 언어로 기술한 가상화를 구현하는 소프트웨어입니다. Docker를 사용하면 Heroku나 CircleCI처럼 배포와 테스트를 할 때마다 다른 환경을 준비할 수 있습니다.Docker 가상화 이미지Vagrant와 Docker는 어떻게 다를까? 둘 다 가상화 기술이지만 가상화의 방법이 다르다.  Vagrant와 Docker의 차이            Vagrant      Docker                  하이퍼바이저형      컨테이너형              호스트 OS와 다른 OS를 다룰 수 있다      호스트 OS와 같은 OS만 처리할 수 있다              애뮬레이트하는 만큼 시작에 시간이 걸린다      바로 시작한다      Docker 도입$ mkdir ~/work/vagrant/docker$ cd !!:$$ vagrant init centos7$ vagrant up이제 가상 머신을 시작했습니다. vagrant ssh 커맨드로 로그인한 후 Docker를 설치합니다.$ sudo yum update$ sudo vi /etc/yum.repos.d/docker.repo# 다음 내용을 입력하고 저장한다[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/7enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpg# Docker를 설치한다$ sudo yum -y install docker-engine다음 커맨드로 Docker를 실행하고 자동 실행 설정도 합니다.$ sudo systemctl start docker $ sudo systemctl enable dockerDocker 테스트docker run 커맨드로 임의의 Docker 이미지에 임의의 처리를 실행할 수 있습니다. 예를 들어, ‘Hello World’를 표시해 보겠습니다.$ docker run centos /bin/echo \"Hello World\"centos라는 Docker 이미지에서 컨테이너를 생성하여 ‘Hello World’를 출력하고, 출력이 끝나면 바로 컨테이너를 종료합니다.  주요옵션            옵션      설명                  -d      백그라운드에서 실행한다.              -i      컨테이너 표준 입력을 연다. /bin/bash 등에서 컨테이너를 조작할 때 지정한다.              -t      tty(단말 디바이스)를 확보한다. /bin/bash 등에서 컨테이너를 조작할 때 지정한다.              -p -p:      포트 매핑을 설정한다.      셸에서의 Nginx 설치 커맨드$ docker run -i -t centos /bin/bashDocker 이미지를 만든다Nginx를 설치한 상태를 Docker이미지로 저장해 보겠습니다.$ docker images컨테이너 목록은 docker ps 커맨드로 표시할 수 있습니다.$ docker ps -a‘docker commit  '으로 지정하면 컨테이너의 Docker 이미지를 원하는 일므으로 저장할 수 있습니다.$ docker commit e07 sasata299/nginxDocker 이미지로 컨테이너를 시작한다$ docker run -d -p 80:80 sasata299/nginx /usr/sbin/nginx -g 'deamon off;'Vagrantfile에 private_network 설정이 되어 있으면, 브라우저로도 Nginx의 실행을 확인할 수 있습니다.컨테이너 관리Docker 컨테이너를 정지하고 삭제해 보겠습니다.$ docker stop b80ea2d658cddocker rm 커맨드를 사용하면 컨테이너를 완전히 삭제합니다.$ docker rm b80ea2d658cdDocker 이미지 관리Docker 이미지의 삭제는 docker rmi 커맨드를 사용합니다.$ docker rmi &lt;이미지명&gt;Dockerfile로 Docker 이미지 만들기간단히 Docker 이미지를 만드는 방법을 실험해 보겠습니다.$ echo test &gt; index.html그리고 Dockerfile은 다음 내용으로 준비합니다. Nginx를 설치하고 작성한 index.html을 /usr/share/nginx/html(DocumentRoot)에 배치하는 처리를 설정합니다.FROM centosMAINTAINER yoon &lt;zizou0812@gmail.com&gt;RUN rpm -Uvh \\\thttp://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmRUN yum install -y nginxADD index.html /usr/share/nginx/html/docker build 커맨들르 사용하면, Dockerfile을 바탕으로 Docker 이미지를 만들 수 있습니다. 여기서는 ‘yoon/nginx’라는 이름의 버전 0.1로 지정했습니다.$ docker build -t yoon/nginx:0.1 .Docker 이미지 공유Docker 이미지 공유는 ‘Docker Hub’에서 할 수 있습니다.사용자 등록이 끝났으면, docker login 커맨드로 로그인합니다.$ docker login 이제 docker push 커맨드로 이미지를 등록해보겠습니다$ docker push yoon/nginxDocker Hub에 등록한 상태에서 docker search 커맨드로 검색해 봅시다. 등록한 Docker 이미지를 찾을 수 있을 것입니다. 이것으로 이미지를 전세계에서 누구나 이용할 수 있게 되었습니다.  docker 커맨드 목록            커맨드      설명                  run      Docker 이미지를 가져와서 컨테이너를 시작하고, 그 안에서 임의의 처리를 실행한다. 종료 후 컨테이너를 종료한다.              images      Docker 이미지 목록을 표시한다.              ps      현재 실행 중인 컨테이너 목록을 표시한다. -a 옵션을 사용하면 정지된 컨테이너도 표시한다.              stop      지정한 컨테이너를 정지한다.              rm      지정한 컨테이너를 삭제한다.              rmi      지정한 Docker 이미지를 삭제한다.              build      Dockerfile을 사용하여 Docker 이미지를 만든다.              commit      컨테이너를 Docker 이미지로 저장한다.              pull      Docker 이미지를 리포지터리에서 가져온다.              push      Docker 이미지를 리포지터리에 등록한다.              search      Docker 이미지를 리포지터리에서 검색한다.      Docker로 CI 테스트Docker의 예로 Jenkins에서 CI 테스트 환경을 Docker로 만든 후 매번 클린 환경으로 테스트하는 방법을 자주 사용합니다.Java 설치Jenkins는 Java에서 동작하므로, yum 커맨드를 사용하여 Java를 설치합니다.$ sudo yum -y install java-1.7.0-openjdk$ sudo yum -y install wgetJenkins 설치$ sudo wget -0 /etc/yum.repos.d/jenkins.repo http://pkh.jenkins-ci.org/redhat/jenkins.repo$ sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key$ sudo yum -y install jenkins자동 실행 설정$ sudo service Jenkins start$ sudo chkconfig Jenkins onJenkins 사용자를 docker 그룹에 추가$ sudo gpasswd -a Jenkins docker Jenkins 설정FROM yoon/nginx:0.1RUN git clone &lt;임으의 리포지터리&gt;",
        "url": "/blackruby-code//web/2017/12/25/Web7.html"
      }
      ,
    
      "web-2017-12-25-web6-html": {
        "title": "웹 엔지니어 - 데이터 시각화",
        "tags": "Web, JSON",
        "date": "December 25, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "데이터 시각화왜 구글 차트인가구글 차트는 구글에서 제공하는 HTML5, SVG 기능을 이용한 그래프 라이브러리입니다. 구글 차트를 JavaScript에 삽입하면 쉽게 그래프를 그릴 수 있습니다.막대 그래프유스케이스막대 그래프를 사용하는 유스케이스 예는 다음과 같습니다.  작년 같은 달의 액세스 총수를 비교하고 싶다.  이번 달 시간별 상품 매출 비교를 지난달과 비교하고 싶다.예제 표시&lt;html&gt;  &lt;head&gt;    &lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\"&gt;      google.charts.load('current', {'packages':['bar']});      google.charts.setOnLoadCallback(drawChart);      function drawChart() {        var data = google.visualization.arrayToDataTable([          ['Year', 'Sales', 'Expenses', 'Profit'],          ['2014', 1000, 400, 200],          ['2015', 1170, 460, 250],          ['2016', 660, 1120, 300],          ['2017', 1030, 540, 350]        ]);        var options = {          chart: {            title: 'Company Performance',            subtitle: 'Sales, Expenses, and Profit: 2014-2017',          },          bars: 'horizontal' // Required for Material Bar Charts.        };        var chart = new google.charts.Bar(document.getElementById('barchart_material'));        chart.draw(data, google.charts.Bar.convertOptions(options));      }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"barchart_material\" style=\"width: 900px; height: 500px;\"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;jsapi를 읽어 온다&lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;사용하고 싶은 API를 호출한다google.charts.load('current', {'packages':['bar']});페이지 그릴 때 값을 설정한다google.charts.setOnLoadCallback(drawChart);      function drawChart() {        var data = google.visualization.arrayToDataTable([          ['Year', 'Sales', 'Expenses', 'Profit'],          ['2014', 1000, 400, 200],          ['2015', 1170, 460, 250],          ['2016', 660, 1120, 300],          ['2017', 1030, 540, 350]        ]임의의 ID 요소에 그린다var chart = new google.charts.Bar(document.getElementById('barchart_material'));chart.draw(data, google.charts.Bar.convertOptions(options));누적 막대 그래프유스케이스누적 막대 그래프를 사용하는 유스케이스 예는 다음과 같습니다.  월별 액세스 총수 중 PC, iPhone, Android 비교  월별 사용자의 남녀 비교누적 막대 그래프는 시계열로 비교하고 싶을 때 주로 사용합니다.예제 표시&lt;html&gt;  &lt;head&gt;    &lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\"&gt;      google.charts.load('current', {'packages':['bar']});      google.charts.setOnLoadCallback(drawChart);      function drawChart() {        var data = google.visualization.arrayToDataTable([\t        ['Genre', 'Fantasy &amp; Sci Fi', 'Romance', 'Mystery/Crime', 'General',\t         'Western', 'Literature', { role: 'annotation' } ],\t        ['2010', 10, 24, 20, 32, 18, 5, ''],\t        ['2020', 16, 22, 23, 30, 16, 9, ''],\t        ['2030', 28, 19, 29, 30, 12, 13, '']      ]);     \t var options = {\t        width: 600,\t        height: 400,\t        legend: { position: 'top', maxLines: 3 },\t        bar: { groupWidth: '75%' },\t        isStacked: true,      };        var chart = new google.charts.Bar(document.getElementById('columnchart_material'));        chart.draw(data, google.charts.Bar.convertOptions(options));      }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"columnchart_material\" style=\"width: 800px; height: 500px;\"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;꺾은선 그래프유스케이스꺾은선 그래프를 사용하는 유스케이스 예는 다음과 같습니다.  전월과 비교했을 때 당월 계정 증가율  전월과 비교했을 때 당월 매출 증가율예제 표시&lt;html&gt;  &lt;head&gt;    &lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\"&gt;      google.charts.load('current', {'packages':['corechart']});      google.charts.setOnLoadCallback(drawChart);      function drawChart() {        var data = google.visualization.arrayToDataTable([          ['Year', 'Sales', 'Expenses'],          ['2004',  1000,      400],          ['2005',  1170,      460],          ['2006',  660,       1120],          ['2007',  1030,      540]        ]);        var options = {          title: 'Company Performance',          curveType: 'function',          legend: { position: 'bottom' }        };        var chart = new google.visualization.LineChart(document.getElementById('curve_chart'));        chart.draw(data, options);      }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"curve_chart\" style=\"width: 900px; height: 500px\"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;산포도유스케이스산포도를 사용하는 유스케이스 예는 다음과 같습니다.  계정별 매출과 매매 횟수의 상관  계정별 로그인 횟수와 매출 금액의 상관예제 표시&lt;html&gt;  &lt;head&gt;    &lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\"&gt;      google.charts.load('current', {'packages':['corechart']});      google.charts.setOnLoadCallback(drawChart);      function drawChart() {        var data = google.visualization.arrayToDataTable([          ['Age', 'Weight'],          [ 8,      12],          [ 4,      5.5],          [ 11,     14],          [ 4,      5],          [ 3,      3.5],          [ 6.5,    7]        ]);        var options = {          title: 'Age vs. Weight comparison',          hAxis: {title: 'Age', minValue: 0, maxValue: 15},          vAxis: {title: 'Weight', minValue: 0, maxValue: 15},          legend: 'none'        };        var chart = new google.visualization.ScatterChart(document.getElementById('chart_div'));        chart.draw(data, options);      }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"chart_div\" style=\"width: 900px; height: 500px;\"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;외부 JSON 파일과 URL 읽기JSON 데이터 작성{  \"cols\": [        {\"id\":\"\",\"label\":\"Topping\",\"pattern\":\"\",\"type\":\"string\"},        {\"id\":\"\",\"label\":\"Slices\",\"pattern\":\"\",\"type\":\"number\"}      ],  \"rows\": [        {\"c\":[{\"v\":\"Mushrooms\",\"f\":null},{\"v\":3,\"f\":null}]},        {\"c\":[{\"v\":\"Onions\",\"f\":null},{\"v\":1,\"f\":null}]},        {\"c\":[{\"v\":\"Olives\",\"f\":null},{\"v\":1,\"f\":null}]},        {\"c\":[{\"v\":\"Zucchini\",\"f\":null},{\"v\":1,\"f\":null}]},        {\"c\":[{\"v\":\"Pepperoni\",\"f\":null},{\"v\":2,\"f\":null}]}      ]}JSON 데이터 구조 확인JSON 데이터의 구조는 다음과 같습니다.            배열 이름      설명                  cols      열(데이터 이름 등을 지정)              rows      행(이름과 관련된 값을 저장)              c      셀      JSON 파일로 HTML 파일 만들기&lt;html&gt;  &lt;head&gt;    &lt;!--Load the AJAX API--&gt;    &lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\" src=\"//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\"&gt;        // Load the Visualization API and the piechart package.    google.charts.load('current', {'packages':['corechart']});          // Set a callback to run when the Google Visualization API is loaded.    google.charts.setOnLoadCallback(drawChart);          function drawChart() {      var jsonData = $.ajax({          url: \"./colmn-example.json\", # &lt;!-- 여기서 앞에서 만든 JSON 파일을 저장 --&gt;          dataType: \"json\",          async: false          }).responseText;                // Create our data table out of JSON data loaded from server.      var data = new google.visualization.DataTable(jsonData);      // Instantiate and draw our chart, passing in some options.      var chart = new google.visualization.PieChart(document.getElementById('chart_div'));      chart.draw(data, {width: 400, height: 240});    }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!--Div that will hold the pie chart--&gt;    &lt;div id=\"chart_div\"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;jQuery라는 JavaScript 라이브러리를 사용합니다.&lt;script type=\"text/javascript\"\tsrc=\"http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;",
        "url": "/blackruby-code//web/2017/12/25/Web6.html"
      }
      ,
    
      "web-2017-12-24-web5-html": {
        "title": "웹 엔지니어 - 로그",
        "tags": "Web",
        "date": "December 24, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "로그로그는 왜 중요한가로그가 필요한 네가지 경우      버그 조사        이상 징후 감지        가설 검증        감사 로그  버그 조사원인을 조사하는 정보로 가장 효과적인 것이 시스템 로그와 액세스 로그 같은 이른바 각종 ‘로그’입니다. ‘어느 URL에 보내는 요청에서 오류가 발생했는지’, ‘파라미터는 적절하게 전달되었는지’ 알 수 있으면, 문제 해결이 쉬워 집니다.이상 징후 감지예를 들어, 매일 CPU와 메모리, 디스크 사용량 등 데이터를 기록해서 그래프로 시각화한다면, 그래프가 갑자기 변동하거나 한계치에 가깝더라도 문제가 되기 전에 파악할 수 있습니다. 이처럼 문제를 감지하는 것이 중요합니다.가설 검증무엇보다도 로그를 제대로 가져와야 가설을 검증할 수 있습니다. 예를 들어, 어떤 페이지에 버튼이 있는데 그 버튼을 얼마나 눌렀는지, 로그(정보)가 없다면 그곳에 버튼을 설치한 것이 좋았는지 정량적인 판단을 할 수가 없습니다.감사 로그보안이라는 관점에서 로그를 생각해 보겠습니다. ‘언제, 누가, 무엇을 했는지’ 정확히 로그로 남겨 두는 것이 중요합니다. 관계형 데이터베이스에서 조작 로그 등이 이에 해당합니다. 이런 로그가 남아 있지 않다면, 문제가 일어났을 때 단서가 없어 곤란합니다.Fluentd 등장 배경여러 대에 걸친 로그를 로그 서버와 같은 어딘가 전용 서버에 실시간으로 모을 수 있다면 편리할 것입니다. 이 장에서 소개할 Fluentd 로그 수집 소프트웨어가 이런 용도에 적합합니다.Fluentd와 syslogd의 차이Fluentd와 syslogd의 다른점  로그 수집 방법과 저장소 등 유연한 사용자화  로그에 태그를 붙여 쉽게 관리  다양한 언어를 지원하는 모듈 제공Fluentd 사용Fluentd 도입Fluentd는 다음과 같은 방법으로 설치할 수 있습니다.  소스코드로 Fluentd를 설치한다.  Rubygems로 Fluentd를 설치한다.  RPM이나 Dev 패키지로 td-agent를 설치한다.Fluentd의 구조디렉티브와  디렉티브가 있습니다.  실제로 몇가지 디렉티브를 이용해서 테스트를 해보겠습니다.$ sudo / etc/init.d/td-agent startStarting td-agent (via systemctl):\t             [ OK ]# 또는 $ sudo systemctl start td-agent.serviceFluentd에 메세지 전송Fluentd 설정 파일은 /etc/td-agent/td-agent.conf이므로 이 파일을 다음처럼 수정합니다.&lt;source&gt;\ttype forward&lt;/source&gt;&lt;match debug.test&gt;\ttype stdout&lt;/match&gt;수정을 마쳤으면 반드시 설정 파일을 다시 로드 합니다.$ sudo systemctl reload td-agent로그 감시Nginx 설치# Nginx 저장소를 설치합니다$ sudo rpm -Uvh \\http://nginx.org/packages/centos/7/noarch/RPMS/nginx-releasecentos-7-0.el7.ngx.noarch.rpm# Nginx를 설치한다 $ sudo yum -y install nginxNginx를 시작합니다. 자동 시작 설정도 하겠습니다.# httpd 데몬이 실행 중일 수도 있으니 일단 중지한다$systemctl stop httpd.service# Nginx 시작 및 자동 시작 설정을 한다 $ systemctl start nginx.service$ systemctl enable nginx.service로그를 다른 Fluentd 서버로 전송여러 대의 서버에서 동작하는 좀 더 복잡한 처리를 예로 들어 생각해 봅시다. 어떤 서버에서 Nginx의 액세스 로그를 감시하고 기록된 로그를 Fluentd로 보냅니다. 그리고 out_forward 플러그인을 사용해서 그 로그를 다른 Fluentd에 전송합니다.호스트 이름 부여호스트에 이름을 붙이려면 fluent-plugin-record-reformer 플러그인을 사용합니다. 이 플러그인은 외부 플러그인이므로 td-agent-gem install 커맨드로 먼저 설치해야 합니다.$ /usr/sbin/td-agent-gem install fluent-plugin-record-reformerMongoDB에 저장여기서는 스키마가 없는 도큐먼트 지향 데이터베이스인 MongoDB로 출력해봅니다.etc/yum.repos.d/mongodb-org-3.0.repo 파일을 다음처럼 작성하여 yum 저장소를 추가합니다.$ sudo yum -y install mongodb-org설치를 마쳤으면 자동으로 시작되도록 합니다.$ sudo service mongod start$ sudo chkconfig mongod on   액세스 로그를 MongoDB에 저장했는지 알아보는 커맨드 셸 명령어$ mongo fluentd&gt; db.nginx_access.find()Fluentd의 권장 구성실제로 Fluentd의 서버 쪽은 active-standby 구성을 권장합니다.네트워크에 연결하지 않아도 로그 수집을 멈추지 않게 하려는 것입니다. 이때는 다음 처럼 active와 standby를 따로 지정하고 standby 쪽은  블록 안에서 standby로 설정해야 합니다.로그 시각화로그의 문제점을 쉽게 파악할 수 있다면 로그를 시각화하는 것도 하나의 방법입니다.예를 들어, 다음 정보를 시각화할 수 있다면 편리하지 않을까요?  오류 로그(404, 500)추이  페이지 응답 속도 추이  응답에 일정 시간 이상 걸린 액세스 수의 추이  로그인에 실패한 수의 추이엘라스틱 서치엘라스틱 서치(Elasticsearch)는 엘라스틱이 개발한 오픈 소스 검색엔진으로, 아파치 루씬(Apache Lucene)이라는 전문(Full text) 검색 라이브러리를 기반으로 사용합니다. 스키마를 지정하지 않고 데이터를 등록할 수 있으며, 대량으로 등록된 데이터를 거의 실시간으로 검색할 수 있습니다.엘라스틱서치 도입Java 설치엘라스틱 서치는 Java로 구현하므로, 우선 Java를 설치합니다.$ sudo yum -y install java-1.7.0-openjdk엘라스틱서치 설치엘라스틱 서치는 yum 커맨드로 간단하게 설치할 수 있습니다./etc/yum.repos.d/elasticsearch.repo 파일을 다음 내용으로 새로 만들고, yum 리포지터리를 추가합니다.$ sudo yum -y install elasticsearch$ sudo systemctl start elaticsearch.service$ sudo systemctl enable elasticsearch.service엘라스틱서치 사용엘라스틱서치는 ‘인덱스’단위로 데이터를 관리합니다. 인덱스는 다음처럼 HTTP 요청으로 쉽게 생성할 수 있습니다.$ curl -X POST http://localhost:9200/test_index{\"acknowledged\":true}Fluentd에서 엘라스틱서치로 데이터 전송엘라스틱서치로 데이터를 보낼 때는 Fluent-plugin-elasticsearch 플러그인을 사용하면 간단합니다. 이 플러그인을 사용하려면 libcurl-devel도 필요하므로 함께 설치합니다.$ sudo yum -y install libcurl-devel$ sudo /usr/sbin/td-agent-gem install fluent-plugin-elasticsearch서버쪽 Fluentd 설정을 다음처럼 변경합니다. 여기서는 out_copy 플러그인을 사용하여 앞에서처럼 MongoDB에 로그를 출력하면서 동시에 엘라스틱서치에도 로그를 보냅니다. out_copy는 출력을 복수의 스토리지에 복사해서 전달할 수 있는 편리한 플러그인입니다.&lt;source&gt;\ttype forward&lt;/source&gt;&lt;match hostname.nginx.access_log&gt;\ttype copy\t\t&lt;store&gt;\t\ttype mongo\t\thost localhost\t\tport 27017\t\tdatabase fluentd\t\tcollection nginx_access\t\tflush_interval 10s\t&lt;/store&gt;\t\t&lt;store&gt;\t\ttype elasticsearch\t\thost localhost\t\tport 9200\t\tlogtash_format true\t\tlogstash_prefix test_index\t\tlogstash_dataformat %Y%m\t\ttype_name nginx_access\t\tbuffer_type memory\t\tbuffer_chunk_limit 10m\t\tbuffer_queue_limit 10\t\tflush_interval 1s\t\tretry_limit 16\t\tretry_wait 1s\t&lt;/store&gt;&lt;/match&gt;인덱스 삭제오래된 인덱스를 삭제할 때는 엘라스틱서치에서 제공하는 Curator 도구를 사용하면 편리합니다. ‘pip’라는 Python의 패키지 관리 도구를 사용해서 설치하겠습니다.$ sudo pip install elasticsearch-curator$ sudo pip install argparseCurator에는 여러 옵션이 있지만, 최근 며칠분의 인덱스만 남기고 오래된 인덱스를 삭제하는 사용법으로도 충분합니다.$ curator --host localhost delete --older-than 30 키바나카바나는 엘라스틱서치 안의 데이터를 시각화하고자 엘라스틱서치사에서 제공하는 공식 데이터 시각화 도구입니다. HTML, CSS, JS로만 구성하기 때문에 웹 서버만 준비하면 사용할 수 있습니다.카바나 도입적당한 디렉터리에 키바나를 설치하고 Nginx의 도큐먼트 루트에 설정합니다.$ curl -O https://download.elastic.co/kibana/kibana/kibana-3.1.0.tar.gz$ tar zxvf kibana-3.1.0.tar.gz$ mv kibana-3.1.0 /usr/local/$ vi /etc/nginx/conf.d/default.conf더미 액세스 로그 생성우선 apache-loggen을 설치합니다. Ruby 라이브러리 관리; 도구인 Rubygems를 사용할 것이므로 환경을 설정합니다. 이미 앞에서 환경을 설정했다면 건너뜁니다.$ git clone https://github.com/sstephenson/rbenv.git ~/.rbenv$ echo 'export PATH=\"$HOME/.rbenv/bin:$PATH\"' &gt;&gt; ~/.bash_profile$ echo 'eval \"$(rbenv init -)\"' &gt;&gt; ~/.bash_profile$ source ~/.bash_profile$ git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build$ sudo yum -y install gcc make openssl-devel $ rbenv install 2.2.3$ rbenv global 2.2.3이제 Rubygems를 사용할 수 있으니 apache-loggen을 설치합니다.$ gem install apache-loggen키바나 사용로그를 여러 가지 관점에서 분석하고 싶을 때 간편하게 시각화할 수 있는 것이 키바나의 장점입니다.키바나에서는 다양한 그래프를 자유롭게 생성하고 배치할 수 있지만, 주로 다음 네 가지를 사용합니다.  히스토그램  테이블  텀  트렌드히스토그램히스토그램에서는 시계열로 데이터를 표시하거나 특정 쿼리로 필터링할 수 있습니다.테이블테이블에서는 액세스 로그를 테이블 형식으로 표시합니다. 표시할 요소를 필터링 할 수도 있어 적절히 필터링 하면 보기가 편해집니다.텀텀은 이른바 패싯 검색 결과를 표시하는 것입니다. 예를 들어, 아파치의 액세스 로그에서 Field로 Code(스테이터스 코드)를 지정하면, 각 스테이터스 코드가 몇 번씩 발생했는지 표시합니다.트렌드트렌드는 10분 전이나 1시간 전과 비교해서 값이 어느 정도 변했는지 알려줍니다.",
        "url": "/blackruby-code//web/2017/12/24/Web5.html"
      }
      ,
    
      "front-2017-12-24-web4-html": {
        "title": "웹 엔지니어 - 프론트엔드의 구현",
        "tags": "AngularJS, jQuery, Web, JavaScript",
        "date": "December 24, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "프런트 엔드 구현프런트 엔드 개발프런트 엔드는 jQuery를 사용하여 구현하는 사례가 많습니다. 그도 그럴 것이 순수하게 JavaScript만으로 처리를 구현하려면 각 브라우저의 고유 사양에 대응해야 하므로, 개발자는 브라우저별로 처리를 구현해야 합니다. 반면에 jQuery를 사용하면 jQuery가 브라우저 간의 동작 차이를 흡수하므로, 개발자의 부담이 줄어듭니다.jQuery의 특징  브라우저에 의존하지 않는 DOM 조작  이벤트와 CSS 조작 등 취급이 간단  이팩트와 애니메이션  Ajax와 쉽게 통신  확장성(jQuery 플러그인)jQuery 간단 사용법다음과 같은 페이지가 있고 선택된 요소를 JavaScript로 가져온다고 가정해봅시다.&lt;html&gt;&lt;head&gt;\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t&lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;\t&lt;form&gt;\t\t&lt;label&gt;&lt;input type=\"radio\" name\"fruit\" value=\"사과\" checked&gt;사과&lt;/label&gt;\t\t&lt;label&gt;&lt;input type=\"radio\" name\"fruit\" value=\"딸기\"&gt;딸기&lt;/label&gt;\t\t&lt;label&gt;&lt;input type=\"radio\" name\"fruit\" value=\"귤\"&gt;귤&lt;/label&gt;\t&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;jQuery를 사용하지 않고 순수 JavaScript로만 구현하는 이런 느낌일 것입니다. 먼저 document.getElementsByName으로 라디오 버튼 요소를 모두 가져와서 for 루프로 요소를 하나씩 checked인지 확인합니다. checked인 요소를 발견할 때까지 반복합니다.var checkedVal;var radio buttons = document.getElementsByName('fruit');for (var i = 0; i &lt; radioButtons.length; i++) {\tif (radioButtons[i].checked) {\tcheckedVal = radioButtons[i].value;\tbreak;\t}}alert(checkedVal);반면에 jQuery를 사용하면 다음처럼 단 두 줄만으로도 동일하게 처리할 수 있습니다.var checkedVal = jQuery('[name=\"fruit\"]:checked').val();alert(checked);DOM 요소 가져오기부모 요소 가져오기부모 요소를 가져오는 방법 하나를 봐도 parent, parents, closest라는 API를 제공합니다. 각 API의 차이는 다음 표와 같습니다.  부모 요소를 가져오는 API의 차이            API      설명                  parent      바로 위 부모 요소만 가져온다(조상 요소까지 거슬러 올라가지 않는다.)              parents      조상 요소까지 거슬러 올라가서 가져온다.              closest      지정한 인수와 일치하는 가장 가까운 조상 요소를 가져온다.      자식 요소 가져오기자식 요소를 가져오는 방법으로 children, find와 같은 API가 준비되어 있습니다. 각 차이는 다음의 표와 같습니다.  자식 요소를 가져오는 API의 차이            API      설명                  children      자식 요소만 가져온다(손자 요소는 가져오지 않는다)              find      자손 요소까지 모두 대상으로 해서 가져온다      형제 요소 가져오기next나 prev 등 API가 준비되어 있습니다.  형제 요소를 가져오는 API의 차이            API      설명                  next      바로 다음에 있는 형제 요소만 가져온다.              nextAll      바로 이후에 있는 모든 형제 요소를 가져온다.              prev      바로 앞에 있는 형제 요소만 가져온다.              prevAll      이전에 나온 모든 형제 요소를 가져온다.      jQuery 오브젝트jQuery는 실제로 jQuery 오브젝트라고 하는 데이터로 되어 있습니다.&gt; $(\"#target\") instanceof jQuerytrueDOM 요소를 가져올 때 복수의 요소가 반환되는 경우, 요소 중에서 맨 앞쪽 데이터를 추출하면 그 데이터는 jQuery 오브젝트가 아니므로 주의해야합니다.&gt; $(\"li\"){\t&lt;li&gt;Foo&lt;/li&gt;,\t&lt;li id=\"target\"&gt;Target&lt;/li&gt;,\t&lt;li&gt;Bar&lt;/li&gt;,\t&lt;li&gt;Baz&lt;/li&gt;,]&gt; $(\"li\") instanceof jQuerytrue&gt; $(\"li\")[0] instanceof jQueryfalse특정 인덱스의 요소를 가져올 때는 first 나 last, 인덱스 번호를 지정할 수 있습니다.&gt; $(\"li:first\") instanceof jQuerytrue&gt; $(\"li\").eq(0) instanceof jQuerytrueCoffeeScriptCoffeeScript는 Ruby나 Python에서 영향을 받아 탄생한 JavaScript로 변환 가능한 프로그래밍 언어입니다. 간단히 말해, JavaScript의 신택스 슈가입니다. 컴파일하여 JavaScript로 변환할 수 있고, JavaScript보다 간결하고 코드양도 적습니다.CoffeeScript의 특징  변수를 선언하는 var가 필요 없다(자동으로 부여)  문장 끝에 ;(세미콜론)이 필요 없다  {}는 들여쓰기(인덴트)로 표현한다  ()는 모호하지 않을 경우 생략할 수 있다CoffeeScript 사용CoffeeScript에서는 다음처럼 배열을 for 루프로 돌리거나 함수 정의(fuction)을 ‘-&gt;’로 대신 쓸 수 있습니다.names = [\"kyeonghan\", \"yoon\", \"han\"]hello = (name) -&gt;\talert \"Hi, #{name}\"\tfor name in names\thello(name if name.length &gt; 5위의 내용을 JavaScript로 변환하기$ coffee -c test.coffee//Generated by CoffeeScript 1.10.0(function() {\tvar hello, i, len, name, names;\t\tname = [\"kyeonghan\", \"yoon\", \"han\"];\t\thello = function(name) {\t\treturn alert(\"Hi, \" + name);\t};\t\tfor (i = 0, len = names.length; i &lt; len; i++) {\t\tname = names[i];\t\tif (name.length &gt; 5) {\t\t\thello(name);\t\t}\t}\t}).call(this);  JavaScript와 CoffeeScript 연산자 비교            JavaScript      CoffeeScript                  ===      is              !==      isnt              !      not              &amp;&amp;      and              ||      or      존재 검사 연산자다음과 같은 CoffeeScript가 있다고 하자.alert \"ok\" if nameJavaScript로 변환하면 다음과 같지만, 문제가 있습니다. 예를 들어, name이 ‘undefined’일 때도 alert가 실행되어 버립니다.if (name) {\talert(\"ok\");}그렇다면 존재를 검사하는 연산자를 사용하면??alert \"ok\" if name?JavaScript는 다음처럼 변환됩니다.if (typeof name !== \"undefined\" &amp;&amp; name !== null) {\talert(\"ok\");}이렇게 하면 name이 ‘undefined’일 때는 alert를 실행하지 않습니다.TypeSciptTypeScipt는 마이크로소프트가 개발한 프로그래밍 언어입니다. CoffeeScript와 마찬가지로 JavaScript의 신택스 슈가이지만, 변수를 선언할 때 데이터형을 지정할 수 있다는 특징이 있습니다.TypeScipt 도입$ sudo npm install -g typescriptTypeScipt 사용test.ts에 다음 코드를 입력합니다.var name:string = \"yoon\";컴파일해봅시다.$ tsc test.tstsc 커맨드를 실행하면, 컴파일되어 test.js가 생성됩니다.  JavaScript, CoffeeScript, TypeScipt의 차이            종류      특징      확장자                  JavaScript      -      .js              CoffeeScript      짧고 간결하게 기술할 수 있다.      .coffee              TypeScript      데이터형을 지정할 수 있다      .ts      GruntGrunt는 JavaScript로 기술된 테스크를 실행하는 자동화 도구 입니다. 최근 프런트 엔드 성능을 향상하려고 JavaScript와 CSS 파일을 최소화하고 이미지 파일을 최적화하는 일이 늘었습니다. 파일을 수정할 때마다 이런 작업을 일일이 수작업으로 하는 것은 매우 힘이 듭니다. Grunt를 사용하면 이런 작업을 자동화할 수 있습니다.Grunt 도입$ sudo npm install -g grunt-cliGrunt를 사용할 때는 다음 두가지 파일이 필요합니다.  package.json  Gruntfile.js(또는 Gruntfile.coffee)package.json의 내용은 다음과 같습니다.{ \t\"name\": \"grunt-test\",\t\"version\": \"0.0.0\",}Coffee.Script를 컴파일할 때 몇 가지 필요한 모듈이 있으므로 함께 설치합니다.$ npm install grunt --save-dev$ npm install grunt-contrib-watch --save-dev$ npm install grunt-contrib-coffee --save-devGrunt로 처리 자동화module.exports = (grunt)-&gt;\t# 테스크 설정 \tgrunt.initConfig\t\tpkg: grunt.file.readJSON 'package.json'\t\twatch:\t\t\tfiles: ['src/**/*.coffee']\t\t\ttasks: 'coffee'\t\tcoffee:\t\t\tcompile: files: [\t\t\t\texpand: true\t\t\t\tcwd: 'src/'\t\t\t\tsrc: ['**/*.coffee']\t\t\t\tdest: 'dest/'\t\t\t\text: '.js'\t\t\t]\t\t\t\t\t# 모듈 로드 \t\tgrunt.loadNpmTasks 'grunt-contrib-coffee'\t\tgrunt.loadNpmTasks 'grunt-contrib-watch'\t\t\t\t# 테스크 등록 \t\tgrunt.registerTask 'default', ['watch']\t\treturn이제 이 Gruntfile.coffee가 있는 디렉터리에서 grunt 커맨드를 실행합니다.$ gruntRunning \"watch\" taskWaiting...JavaScript 프레임워크 등장jQeury로 프런트 엔드 개발이 매우 편해졌다는 사실을 알았습니다. 그런데 왜 Backbone.js, AngularJS, Ember.js, Vue.js와 같은 JavaScript 프레임워크가 등장한 걸까? jQuery만으로는 부족했을까? 그 이유는 크게 두가지 입니다.  DOM 변경에 약한 jQuery  대규모화된 프런트 엔드 개발DOM 변경에 약한 jQueryjQeury는 아주 편리하지만, DOM을 탐색하기에는 아무래도 DOM 구조 변경에 취약합니다.$(\"#target\").parent().next().find(\".defualt\").hide();특정 ID요소에서 부모 요소의 형제 요소를 찾아 그중 class 이름이 default인 자손 요소를 비표시로 하는 처리입니다. jQuery에서는 이처럼 DOM을 탐색하는 처리를 간단히 기술할 수 있어 편리하지만, 그 편리함 때문에 약간만 DOM 구조를 변경해도 바르게 동작하지 않아 버그의 원인이 됩니다.대규모화된 프런트 엔드 개발서버사이드 개발에서는 이전부터 MVC(Model-View-Controller)라는 디자인 패턴을 이용하여 비즈니스 로직은 모델에, 디자인은 뷰에 책임을 분산했습니다. 최근 프런트 엔드 개발 규모가 커지자 서버사이드 개발과 마찬가지로 프런트 엔드 개발에서도 MVC 디자인 패턴으로 비즈니스 로직과 디자인을 따로 분리하려는 경향을 보입니다.AngularJS 특징AngularJS는 구글에서 만든 풀 스택 JavaScript 프레임워크 입니다. Backbone.js 등은 최소한의 기능만 있기 때문에 부족한 기능은 서드파티 플러그인이나 라이브러리를 조합해서 개발해야 합니다. 하지만 AngularJS에서는 필요한 기능을 기본으로 지원합니다.AngularJS의 특징  HTML을 그대로 템플릿으로 사용  양방향 데이터 바인딩  DI 컨테이너HTML을 그대로 템플릿으로 사용AngularJS에서는 HTML을 그대로 템플릿으로 사용할 수 있습니다. HTML을 기반으로 커스텀 태그와 커스텀 속성을 지정하여 조건 분기나 반복 등을 제어할 수 있습니다. 겉보기에는 거의 일반 HTML과 다르지 않으므로 도입하기도 쉽습니다.AngularJS에서는 커스텀 태그와 커스텀 속성을 ‘Directive’라고 합니다. ng-if나 ng-repeat등 굉장히 많은 Directive가 준비되어 있습니다.양방향 데이터 바인딩AngularJS의 가장 큰 특징은 양방향 데이터 바인딩입니다. 양방향 바인딩이란 ‘화면에 뭔가 입력했을 때 JavaScript 변수에 값이 반영되는 처리’와 ‘JavaScript’에서 변수 값이 변했을 때 화면에 다시 그리는 처리’를 양방향으로 하는 것 입니다. 이렇게 아주 매끄럽게 연계하는 것이 AngularJS의 강점입니다.DI 컨테이너AngularJS의 큰 특징은 ‘DI(Dependency Injection)’이라는 DI패턴을 이용해서 의존관계를 관리하는 매커니즘입니다. AngularJS를 능숙하게 사용하려면, DI 컨테이너를 반드시 이해해야 합니다. 예를 들어, 다음처럼 ‘myApp’이라는 모듈을 정의하고, 그 안에 ‘message’ 속성이 있는 ‘greetService’라는 Service를 정의하겠습니다.var myApp = angular.module(\"myApp\", []);myApp.service(\"greetService\", fuction() {\tthis.message = \"Hello World!\"});이 Service를 다른 곳에서 호출해서 사용해 봅시다.var myApp = angular.module(\"myApp\"); // sample_service.js에서 정의한 module을 가져온다myApp.controller(\"MyCtrl\", [\"$scope\", \"greetService\", function($scope, greetService) {\t$scope.greet = greetService.message;}]);이 매커니즘 덕분에 기능을 역할별로 모듈화하여 관리할 수 있습니다.AngularJS 사용AngularJS는 공식 사이트에서 다운로드 한뒤, script 태그로 불러오면 됩니다.&lt;script src=\"libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;또 다음처럼 구글에 호스팅되는 CDN(Contents Delivery Network)을 사용할 수도 있습니다.&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;DOM 조작AngularJS에서는 DOM을 조작하려고 jqlite라는 jQuery 호환 API를 준비하여 두었습니다.jqliteAngular.element를 사용하면 jqlite 오브젝트를 가져올 수 있습니다. HTML 안에 있는 임의의 요소를 인수로 전달하면 됩니다.&gt; angular.element(document.getElementById('wrap'))$scope.$applyAngularJS에서는 $scope 속성이 변하면 화면도 자동으로 다시 그립니다. 하지만 AngularJS의 관리 밖에서 이벤트가 발생하면 자동으로 처리하지 않으므로, $scope 오브젝트 내용을 수정해도 화면에 그린 내용은 예전과 같을 때가 있습니다.다음의 내용은 focus 이벤트가 발생하지만 이 이벤트는 AngularJS의 관리 밖에 있습니다. 이때는 $scope.$apply를 사용해서 명시적으로 화면을 다시 그립니다$(\"#target\").on(\"focus\", function() {\t$scope.$apply(function() {\t\t$scope.isFocus = true;\t});});컨트롤러 사용다음 HTML을 템플릿으로 합니다. ng-controller=”MainCtrl”로 지정하여 div 요소 안에서 MainCtrl의 변수와 메소드를 사용할 수 있는 상태로 합니다. ng-repeat는 루프 처릴를 하는Directive입니다.&lt;!doctype html&gt;&lt;html ng-app&gt;\t&lt;head&gt;\t\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"controller.js\"&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div ng-controller=\"MainCtrl\"&gt;\t\t\t users.\t\t\t&lt;ul ng-repeat=\"user in users\"&gt;\t\t\t\t&lt;li&gt;()&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;  MainCtrl은 다음처럼 구현합니다. $scope라는 특수한 오브젝트에 임의의 속성을 지정하고, 그 속성을 HTML 쪽에서 불러낼 수 있습니다.var MainCtrl = function($scope) {\t$scope.users = [\t\t{name: \"dooli\", age: \"21\"},\t\t{name: \"ttochi\", age: \"31\"},\t\t{name: \"gildong\", age: \"38\"},\t];}TODO 리스트 구현컨트롤러 쪽에서 초기 태스크를 준비하고, 초기 태스크를 ng-repeat로 표시합니다. 체크박스는 ng-model=”task.done”으로 하여 task.done값에 따라 표시를 바꿉니다. 또 ng-class를 사용하여 task.done이 true면 done이라는 이름을 붙이고, CSS에서 표시를 바꿉니다.&lt;!doctype html&gt;&lt;html ng-app&gt;\t&lt;head&gt;\t\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"todo.js\"&gt;&lt;/script&gt;\t\t&lt;style&gt;\t\t\t.done {\t\t\t\tcolor: gray;\t\t\t\ttext-decoration: line-through;\t\t\t}\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div ng-controller=\"todoCtrl\"&gt;\t\t\t&lt;ul ng-repeat=\"task in tasks\"&gt;\t\t\t\t&lt;li&gt;\t\t\t\t\t&lt;input type=\"checkbox\" ng-model=\"task.done\"&gt;\t\t\t\t\t&lt;span ng-class=\"{done: task.done}\"&gt;&lt;/span&gt;\t\t\t\t&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;  JavaScript쪽은 다음처럼 name과 done 속성이 있는 태스크의 배열로 되어 있습니다.var todoCtrl = function($scope) {\t$scope.tasks = [\t\t{name: \"task1\", done: true},\t\t{name: \"task2\", done: false},\t\t{name: \"task3\", done: false},\t\t{name: \"task4\", done: false},\t];}ng-submit으로 폼을 전송하는 동작을 지정합시다.&lt;!doctype html&gt;&lt;html ng-app&gt;\t&lt;head&gt;\t\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"todo.js\"&gt;&lt;/script&gt;\t\t&lt;style&gt;\t\t\t.done {\t\t\t\tcolor: gray;\t\t\t\ttext-decoration: line-through;\t\t\t}\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div ng-controller=\"todoCtrl\"&gt;\t\t\t&lt;ul ng-repeat=\"task in tasks\"&gt;\t\t\t\t&lt;li&gt;\t\t\t\t\t&lt;input type=\"checkbox\" ng-model=\"task.done\"&gt;\t\t\t\t\t&lt;span ng-class=\"{done: task.done}\"&gt;&lt;/span&gt;\t\t\t\t&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t\t\t\t\t# &lt;!-- 추가 --&gt;\t\t\t&lt;form ng-submit=\"addNewTask()\"&gt;\t\t\t\t&lt;input type=\"text\" ng-model=\"newTaskName\"&gt;\t\t\t\t&lt;input type=\"submit\" value=\"Add\"&gt;\t\t\t&lt;/form&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;이제 $scope.tasks 배열에 새로운 요소만 추가하면 화면 표시는 AngularJS가 자동으로 실행하니 아주 간단합니다. 또 마지막에 $scope.newTaskName을 비워서 다음 태스크를 매끄럽게 입력할 수 있게 해야 합니다.var todoCtrl = function($scope) {\t$scope.tasks = [\t\t{name: \"task1\", done: true},\t\t{name: \"task2\", done: false},\t\t{name: \"task3\", done: false},\t\t{name: \"task4\", done: false},\t];\t// 추가\t$scope.addNewTask = function() {\t\t$scope.tasks.push({name: $scope.newTaskName, done: false});\t\t#scope.newTaskName=\"\";\t}}전체 태스트가 몇 개이고, 그중에서 몇 개를 완료했는지 표시해봅시다.&lt;!doctype html&gt;&lt;html ng-app&gt;\t&lt;head&gt;\t...\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div ng-controller=\"todoCtrl\"&gt;\t\t\t&lt;!-- 추가 --&gt;\t\t\t&lt;p&gt;\t\t\t\tDone:  / \t\t\t&lt;/p&gt;\t\t\t\t\t\t\t\t\t&lt;ul ng-repeat=\"task in tasks\"&gt;\t\t\t\t&lt;li&gt;\t\t\t\t\t&lt;input type=\"checkbox\" ng-model=\"task.done\"&gt;\t\t\t\t\t&lt;span ng-class=\"{done: task.done}\"&gt;&lt;/span&gt;\t\t\t\t&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t\t\t\t\t\t\t\t&lt;form ng-submit=\"addNewTask()\"&gt;\t\t\t\t&lt;input type=\"text\" ng-model=\"newTaskName\"&gt;\t\t\t\t&lt;input type=\"submit\" value=\"Add\"&gt;\t\t\t&lt;/form&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;  JavaScript에서는 angular.forEach 구문으로 $scope.tasks를 계속 돌면서 각각의 task.done 값을 보고 완료된 태스크 수를 카운트 합니다.var todoCtrl = function($scope) {\t$scope.tasks = [\t\t{name: \"task1\", done: true},\t\t{name: \"task2\", done: false},\t\t{name: \"task3\", done: false},\t\t{name: \"task4\", done: false},\t];\t// 추가\t$scope.addNewTask = function() {\t\t$scope.tasks.push({name: $scope.newTaskName, done: false});\t\t#scope.newTaskName=\"\";\t}\t\t// 추가\t$scope.doneTaskCount = function() {\t\tvar doneTaskCount = 0;\t\tangular.forEach($scope.tasks, function(task) { \t\t\tdoneTaskCount += task.done ? 1 : 0;\t\t});\t\treturn doneTaskCount;\t}}디버깅한 가지 더 기억해야 할 것이 바로 디버깅 방법입니다. AngularJS는 편리한 디버깅 방법을 제공합니다.&lt;!doctype html&gt;&lt;html ng-app&gt;\t&lt;head&gt;\t...\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div ng-controller=\"todoCtrl\"&gt;\t\t\t&lt;!-- 추가 --&gt;\t\t\t&lt;p&gt;\t\t\t\tDone:  / \t\t\t&lt;/p&gt;\t\t\t\t\t\t\t\t\t&lt;ul ng-repeat=\"task in tasks\"&gt;\t\t\t\t&lt;li&gt;\t\t\t\t\t&lt;input type=\"checkbox\" ng-model=\"task.done\"&gt;\t\t\t\t\t&lt;span ng-class=\"{done: task.done}\"&gt;&lt;/span&gt;\t\t\t\t&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t\t\t\t\t\t\t\t&lt;form ng-submit=\"addNewTask()\"&gt;\t\t\t\t&lt;input type=\"text\" ng-model=\"newTaskName\"&gt;\t\t\t\t&lt;input type=\"submit\" value=\"Add\"&gt;\t\t\t&lt;/form&gt;\t\t\t\t\t\t&lt;!-- 추가 --&gt;\t\t\t&lt;pre&gt;&lt;/pre&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;서버 통신여기서는 Rails를 사용해서 서버 쪽에 간단한 API를 준비합니다. 먼저 새로 Rails 프로젝트를 준비합니다. 여기서는 ‘angular-sample’이름으로 프로젝트를 만들겠습니다.$ rails new angular-sample --skip-bundle다음으로 bundle install 커맨드로 필요한 gem을 설치합니다$ cd angular-sample$ bundle install --path=vendor/bundle이번에는 User 정보를 다루는 API를 준비합니다. Users 컨트롤러와 User 모델이 필요합니다.$ rails g controller users$ rails g model user name$ rake db:migrate$ rails generate controller top indexTOP 페이지는 Top 컨트롤러의 index 액션을 담당하게 합시다. config/routes.rb를 다음처럼 작성합니다.root 'top#index'resource :users  뷰는 다음처럼 AngularJS를 사용하도록 설정합니다. 또, ngResource 모듈을 사용하므로 이 모듈을 뷰에서 로드합니다.&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;\t&lt;head&gt;\t\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular-resource.min.js&gt;&lt;/script&gt;\t\t&lt;script src=\"angular.js\"&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;body ng-controller=\"MainCtrl\"&gt;\t\t&lt;input type=\"text\" ng-model=\"userName\" /&gt;\t\t&lt;button ng-click=\"addUser()\"&gt;Add&lt;/button&gt;\t\t&lt;ul&gt;\t\t\t&lt;li ng-repeat=\"user in users\"&gt;&lt;/li&gt;\t\t&lt;/ul&gt;\t\t&lt;pre&gt;&lt;/pre&gt;\t&lt;/body&gt;&lt;/html&gt;API 쪽 컨트롤러는 다음처럼 작성합니다. RESTful API로 되어 있습니다. index 액션으로 모든 사용자의 정보를 반환하고 show 액션으로 특정 사용자의 정보를 반환합니다. 또, create 액션에서는 주어진 파라미터를 이용하여 사용자를 새로 생성합니다.class UserController &lt; ApplicationController\tdef index\t\trender json: User.all\tend\t\tdef show\t\trender json: User.find(params[:id])\tend \t\tdef create\t\trender json: User.create(user_name)\tend\tprivate \t\tdef user_params\t\tparams.require(:user).permit(:name)\tendend\t      이제 index.html.erb에서 로드한 angular.js에 구체적인 처리를 구현합니다.      var app = angular.module(\"myApp\", [\"ngResource\"]);  # Rails의 CSRF Token 대책  app.config([\"$httpProvider\", function($httpProvider) {      csrfToken = angular.element('meta[name=csrf-token]').attr('content')      $httpProvidr.defaults.headers.post['X-CSRF-Token'] = csrfToken      $httpProvidr.defaults.headers.put['X-CSRF-Token'] = csrfToken      $httpProvidr.defaults.headers.patch['X-CSRF-Token'] = csrfToken   }]);  var MainCtrl = function($scope, $resource) {      var User = $resource(\"/users\");      $scope.users = User.query();      $scope.addUser = function() {          User.save({name: $scope.userName}, function(user) {              $scope.users.push(user);          });          $scope.userName = \"\";      };  }      ngResource에서 사용할 수 있는 액션            액션      HTTP 메소드                  get      GET              save      POST              query      GET              delete      DELETE              remove      DELETE      \u0010서비스AngularJS에는 서비스라는 편리한 매커니즘이 있습니다. 서비스는 함수와 오브젝트 등을 AngularJS 애플리케이션 안에서 공유하는 매커니즘 입니다. 싱글톤으로 다루므로 컨틀로러 간 공유에도 이용할 수 있습니다. 다음은 대표적인 서비스 입니다.  $location  $timeout  $cookieStore(ngCookies)$location$location은 window.location을 AngularJS로 랩핑한 서비스입니다.&lt;!doctype html&gt;&lt;html ng-app=\"app&gt;\t&lt;head&gt;\t\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"location.js\"&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;/body&gt;\t\t&lt;div ng-controller=\"LocationCtrl\"&gt;\t\t\t\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;컨트롤러 쪽에서 $location을 넘겨주고 그 값을 $scope가 갖게 하여 뷰쪽에서도 $location을 사용할 수 있습니다.var app = anular.module('app', []);app.controller('LocationCtrl', ['$scope', '$location', function($scope, $location) {\t$scope.$location = $location;}]);$timeout$timeout은 window.setTimeout을 AngularJS로 랩핑한 서비스입니다.AngularJS가 관리하지 않는 setTimeout 등 함수를 사용해서 $scope 값을 변경해도 화면을 다시 그리지 않습니다. 화면을 갱신하려면 $timeout을 사용해야 합니다. 사용법은 setTimeout과 완전히 똑같습니다.&lt;!doctype html&gt;&lt;html ng-app=\"app&gt;\t&lt;head&gt;\t\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"timeout.js\"&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;/body&gt;\t\t&lt;div ng-controller=\"TimeoutCtrl\"&gt;\t\t\t\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;var app = anular.module('app', []);app.controller('TimeoutCtrl', ['$scope', '$timeout', function($scope, $timeout) {\t$timeout(function() {\t\t$scope.message = '3초가 지났어요!'\t}, 3000);}]);$cookieStore(ngCookie)ngCookie 모듈을 사용하면, 쿠키를 간단하게 조작할 수 있습니다.&lt;!doctype html&gt;&lt;html ng-app=\"app&gt;\t&lt;head&gt;\t\t&lt;meta content=\"text/html\" charset=\"UTF-8\"&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.29/angular-cookies.min.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"cookies.js\"&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;/body&gt;\t\t&lt;div ng-controller=\"CookieCtrl\"&gt;\t\t\t\t\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;var app = angular.module('app', ['ngCookies']);app.controller('CookieCtrl', ['$scope', '$cookieStroe', function($scope, $cookieStore) {\t$cookieStore.put(\"name\", \"dooli\");\t$scope.name = $cookieStore.get(\"name\");}]);초기화 처리$rootScope에 API의 URL을 지정하면 다음처럼 처리한다.var app = angular.module(\"app\", []);app.run(function() {\t$rootScope.apiUrl = \"http://exmaple.com/users\";});",
        "url": "/blackruby-code//front/2017/12/24/Web4.html"
      }
      ,
    
      "web-2017-12-24-web3-html": {
        "title": "웹 엔지니어 - 데이터베이스",
        "tags": "Web, NoSQL, Redis, MongoDB, Ruby",
        "date": "December 24, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "NoSQL 데이터베이스와 관계형 데이터베이스의 차이관계형 데이터베이스의 특징SQL을 사용하면 누구나 똑같이 데이터를 조작할 수 있으므로, 현재는 사실상 데이터 저장소 표준이 되었습니다.관계형 데이터베이스의 강점  데이터의 일관성을 보증할 수 있다(트랜잭션)  정규화를 전제로 하므로 갱신 비용이 적다  JOIN이나 복잡한 검색 조건으로 검색할 수 있다  오래된 기술이라 실적과 노하우가 축적되어 있다.관계형 데이터베이스의 약점  단순하고 빠르게 결과를 반환한다  대량의 데이터를 저장하여 처리한다  갱신이 발생하는 테이블에서 인덱스를 작성하고 스키마를 변경한다  칼럼을 결정하기 어렵다RedisRedis는 이탈리아의 살바토레 산필리포가 개발한 오픈 소스 소프트웨어입니다. Key-Value 저장소라는 의미에서 맴캐시드와 비슷하지만, 메모리 기반으로 휘발성이면서 영속성을 지원하는 특징이 있습니다.Redis를 사용하는 이유      영속화 기능이 있다          메모리에서 데이터의 스냅샷을 임의의 조건에서 파일로 저장합니다. 기본으로 15분에 1개 이상, 5분에 10개 이상, 1분에 1만개 이상 Key를 변경할 때는 파일로 저장하는데, 저장 조건은 자유롭게 변경할 수 있습니다.            다양한 형식의 데이터를 다룰 수 있다          Redis에서는 문자열형, 리스트형, 세트형, 정렬된 세트형, 해시형 같은 다양한 데이터형이 준비되어 있어 용도에 맞게 이용할 수 있습니다.            아토믹하게 처리할 수 있다          이것은 간단하게 말해 ‘일련의 처리를 한 번의 명령으로 처리’하는 것입니다.      Redis 설치$ sudo su - $ yum -y install redisRedis-cli 사용Redis에는 redis-cli 커맨드라인 클라이언트가 있습니다. redis-cli를 사용해서 데이터를 저장하거나 읽을 수 있습니다.$ redis-cliRuby에서 Redis 사용redis gem의 사용$ gem install redis  통째로 저장하기require 'rubygems'require 'redis'redis = Redis.newredis.set 'bar',[1,2,3]p redis.get 'bar'# =&gt; \"[1,2,3]\"  json 저장하기require 'rubygems'require 'redis'require 'json'redis = Redis.newredis.set 'foo',[1,2,3].to_jsonp JSON.parse(redis.get('foo'))# =&gt; [1,2,3]순위 정보 다루기특정 사용자나 특정 상품이 지금 몇 번째 순위인지 나타내고 싶을 때는 번거롭습니다. 순위 목록을 가져온 후 특정 사용자나 상품이 어디에 있는지 몇 번이고 루프를 돌려서 찾아내는 끈기가 필요합니다.반면에 Redis의 정렬된 세트형을 사용하면 간단하고 빠르게 순위 정보를 알 수 있으므로 편리합니다.require 'rubygems'require 'redis'redis = Redis.new(1..10).each do |user_id|\t\tredis.zadd('ranking', rand(100), user_id)endredis-commanderRedis안에 실제로는 어떻게 데이터가 존재하는지 확인해보고 싶을때 사용합니다.npm 커맨드를 사용할 수 있는 상태라면 다음과 같이 설치가 가능합니다.$ sudo yum -y install npm $ npm install -g redis-commander각 요소의 순위 반환다음의 코드는 임의의 키 중에서 각 요소의 내림차순 순위를 반환합니다. 순위는 0부터 시작합니다. 가장 스코어가 높은 요소가 0이 되므로 1을 더하고 있습니다.require 'rubygems'require 'redis'redis = Redis.newp redis.zerevrank('ranking', 4) + 1# =&gt; 3각 요소의 스코어 반환require 'rubygems'require 'redis'redis = Redis.newp redis.zscore('ranking', 4)# =&gt; 67.0순위 반환require 'rubygems'require 'redis'redis = Redis.newp redis.zrevrange('ranking', 0, 9)# =&gt; [\"1\", \"2\", \"4\", \"5\", \"7\", \"10\", \"9\", \"3\", \"8\", \"6\"]순위 갱신activities.each do |activity|\tredis.zadd('ranking_tmp', activity.score, activity.user_id)endredis.rename('ranking_tmp', 'ranking')  정렬된 세트형 조작 커맨드            커맨드      설명                  zadd      각 요소를 등록한다.              zrevrank      각 요소의 순위를 반환한다.              zscore      각 요소의 스코어를 반환한다.              zrevrange      지정한 범위의 요소를 반환한다.      MongoDBMongoDB는 10gen에서 개발한 고성능과 확장성이 특징인 오픈 소스 소프트웨어입니다. 도큐먼트 지향 데이터베이스라고도 합니다.MongoDB를 사용하는 이유      MongoDB의 장점          스키마를 고정하지 않아도 된다      검색을 유연하게 할 수 있다      스키마를 고정하지 않아도 된다MongoDB는 데이터를 저장할 때 데이터 구조를 포함하여 통째로 BSON(JSON을 바이너리화 한 것)형식으로 저장하고, 그 데이터를 특정 키와 연결합니다. 이런 설계 덕분에 스키마를 정의할 필요가 없습니다. 다만, 데이터 처리 방법이 다르므로 표현하는 용어도 다릅니다. 관계형 데이터베이스의 테이블을 MongoDB에서는 컬렉션, 관계형 데이터베이스의 레코드를 MongoDB에서는 도큐먼트라고 합니다.검색을 유연하게 할 수 있다스키마는 정의하지 않지만, 임의의 키에서 관계형 데이터베이스처럼 검색도 유연하게 할 수 있습니다. 정규식 표현 검색과 배열 중 특정 값이 포함되어 있는지 다양한 조건으로 검색할 수 있습니다. 이런 검색의 유연성을 MongoDB의 매우 편리한 점입니다.MongoDB의 설치$ vi /etc/yum.repos.d/mongodb-org-3.0.repo# 다음 내용으로 저장소를 추가한다[mongodb-org-3.0]name=MongoDB Repositorybaseurl=http://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.0/x86_64/gpgcheck=0enabled=1# 다음 커맨드로 mongoDB를 설치한다$ yum -y install mongodb-orgmongo 셸 사용MongoDB를 작동한 상태에서 mongo 커맨드를 실행하면 mongo 셸이 시작합니다. mongo 셸을 사용해서 기본적인 처리를 테스트해봅니다.$ mongoMongoDB shell version: 3.0.6connecting to: test # 인수를 지정하지 않으면 test 데이터베이스에 접속한다Welcome to the MongoDB shell&gt; show dbs&gt; local 0.078GB&gt; show collections데이터를 저장하기&gt; db.users.save({name: \"yoon\"})WriteResult({ \"nInserted\" : 1 })&gt; show dbslocal 0.078GBtest  0.078GB&gt; show collectionssystem.indexesusersRuby로 MongoDB 사용mongo-ruby-driver gem을 사용해보기$ gem install mongo이 gem을 사용해서 간단하지만 컬렉션 목록을 표시하고 데이터베이스에 쓰기, 읽기 등 처리를 테스트해보기require 'rubygems'require 'mongo'# mydb 데이터베이스에 접속한다connection = Mongo::Client.new([ '123.0.0.1:222' ], :database =&gt; 'mydb')db = connection.database# 아직 이 시점에서는 컬렉션이 없다p db.collection_names# =&gt; []users = db.collection('users')(201..300).each do |i|\tusers.insert_one(name:\"yoon\"#{i}\")endp db.collection_names# =&gt; [\"users\", \"system.indexes\"]p users.count# =&gt; 100# name이 yoon299인 데이터를 추출한다users.find(name: 'yoon299').each { |row| p row }# =&gt; {\"_id\"=&gt;BSON::ObjectId('2345234534346344'), \"name\"=&gt;\"yoon299\"}# name의 맨 끝이 0인 데이터를 5개 추출한다 users.find(name: /0$/).limit(5).each { |row| p row }로그 기록사용자 ID와 액세스한 경로, 등록 일시, 액세스 IP를 기록한다고 가정하면, 코드는 다음과 같습니다.require 'rubygems'require 'mongo'connection = Mongo::Client.new([ '127.0.0.1:1111' ], :database =&gt; 'mydb')db = connection.databaselogs = db.collection('logs')logs.insert_many([{user_id: user.id},{path: '/users/12/books?type=comic'},{registered_at: user.registered_at}, {ip_address: '192.168.33.1'}])",
        "url": "/blackruby-code//web/2017/12/24/Web3.html"
      }
      ,
    
      "web-2017-12-24-web2-html": {
        "title": "웹 엔지니어 - PHP",
        "tags": "Web, PHP",
        "date": "December 24, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "PHP최근 PHP5.0의 객체 지향 기능 강화, 5.3의 네임 스페이스와 익명 함수, 5.4의 트레이트, 5.5의 제너레이터 지원 등 PHP는 버전이 올라가면서 다양한 기능을 추가하고 있습니다.또, 예전부터 보안 문제로 추천하지 않았던 기능, 함수 등은 하위 호환성을 버리면서 개량을 거듭하는 중으로, 예전 스타일의 작성법이나 현재는 권장하지 않는 오래된 정보가 많이 발견됩니다.PHP 프레임워크풀 스택 프레임워크풀스택 프레임워크에서는 ORM이나 인증, 템플릿 등 웹 애플리케이션에 필요한 기능을 제공합니다. 주요 풀 스택 프레임워크는 다음과 같습니다.  Aura  CakePHP  FuelPHP  Laravel  Lithium  Phalcon  Symfony  Yii  Zend framework  CodeIgniter위의 항목중에서 Symfonu, laravel, phalcon 세 가지 프레임워크가 강력했습니다.SymfonySymfony는 2005년부터 개발하여 현재 최신 버전은 2.6입니다. 원래 Ruby on Rails에 영향을 받아 만든 프레임워크였지만, 버전 2에서 설계부터 코드까지 완전히 다른 프레임워크로 다시 태어났습니다. 각 기능을 느슨하게 결합하도록 철저하게 설계되어 있고, 개발자는 프레임워크로 규칙, 제약을 그다지 받지 않은 채 아주 유연하게 개발할 수 있습니다.LaravelLaravel(라라벨)은 2012년부터 개발한 비교적 새로운 프레임워크입니다. 해외에서는 2014년 가장 유망한 PHP 프레임워크로 뽑히는 등 상당히 인기가 있습니다.Laravel은 앞선 기능을 많이 갖추고 있으며, 프레임워크 방식을 따르기에 Rails처럼 궤도에 오르는 느낌으로 개발할 수 있는 PHP 프레임워크입니다.PhalconPhalcon(팔콘) 공식 도큐먼트에 나온 것처럼 ‘중요한 것은 성능’이라는 견해를 바탕으로, 다른 프레임워크와는 달리 PHP 확장 모듈을 C언어로 구현했습니다. Phalcon은 PHP를 실행할 때 일어나는 구문 해석, Opcode 변환 단계를 날려 버려 뛰어난 성능과 압도적인 속도를 자랑합니다.마이크로 프레임워크  Silex  Slim풀스택 프레임워크와 달리 기본 기능은 한정되어 있지만 학습 비용이 낮아서 간단한 기능이나 소규모 개발에서는 마이크로 프레임워크를 선택하는 것도 좋은 방법입니다.PHP 실행 환경 구축PHP 설치rbenv처럼 PHP에도 버전을 관리하는 phpenv, 빌드와 인스톨을 담당하는 php-build 도구가 있으니 이를 사용해서 환경을 구축합니다.우선은 가상 머신에 SSH로 로그인합니다.$ vagrant sshPHP 빌드에 필요한 라이브러리를 미리 yum 커맨드로 설치$ sudo yum install -y epel-release$ sudo yum install -y --enablerepo=epel libxml2-devel readline-devel libcurl-debel libjpeg-turbo-devel libpng-devel libmcrypt-devel libtidy-devel libxslt-devel re2c bisonphpenv 설치$ curl https://raw.githubusercontent.com/CHH/phpenv/master/bin/phpenv-install.sh | shphpenv 사용에 필요한 설정을 .bash_profile에 추가하고 설정을 반영합니다$ echo 'export PATH=\"/home/vargrant/.phpenv/bin:$PATH\"' &gt;&gt; ~/.bash_profile$ echo 'eval \"$(phpenv init -)\"' &gt;&gt; ~/.bash_profile$ source ~/.bash_profilephpenv 버전의 확인phpenv -v configure 옵션을 변경하지 않고, php-build의 기본 configure로 설치를 진행합니다.PHP 5.6.13의 설치$ phpenv install 5.6.13설치된 PHP버전 목록 확인phpenv versions기본 버전의 지정phpenv install 5.6.13php 커맨드의 사용$ php -vphp.ini 설정$ cd ~/.phpenv/versions/5.6.13/etc$ cp php.ini php.ini.old # 원본 파일 백업$ vi php.ini # php.ini 수정# 다음 변경된 부분을 참고하여 수정한다$ git diff --no-index php.ini.old php.iniComposer 사용Composer는 PHP 프로젝트의 의존관계를 관리하는 도구입니다. 프로젝트에 필요한 라이브러리의 이름과 버전을 정의하면, 다운로드부터 설치, 버전 관리, 클래스 자동 로딩 문제를 해결합니다.Composer 설치Composer를 사용함녀 프로젝트에 필요한 라이브러리를 관리할 수 있고, PHP 개발 전반에 사용하는 커맨드라인 도구 등 라이브러리도 설치할 수 있습니다.PSR 알아보기PHP로 개발할 때 지켜야 할 규약으로 PSR(PHP Standard Recommendations)이 있습니다. PSR은 PHP의 다양한 프레임워크와 라이브러리 개발 커뮤니티인 PHP-FIG(PHP Framework interop Group)가 참여하여 제창한 표준 가이드라인입니다. 현재 PSR-0~PSR-4까지 공개되어 있습니다.PSR은 이름 규칙과 디렉터리 구조, 코딩 스타일 같은 작성법을 비롯하여 로거처럼 필수적이고. 중요한 기능의 인터페이스 정의도 포함하여 표준화를 진행합니다.PHP 애플리케이션 개발 환경 구축프로젝트 만들기Composer를 사용하여 Silex를 설치할 수 있습니다. ‘/vagrant’ 디렉터리를 프로젝트 루트로 합니다.  Composer.json에 라이브러리 정보를 기술합니다. require 부분에는 패키지 이름과 버전을 지정합니다.{ \t\"require\" : {\t\t\"silex/silex\": \"~1.2\"\t}}composer install을 실행하면 composer.json의 내용을 바탕으로 Silex가 의존하는 모듈을 다운로드하기 시작합니다.$ composer install설치가 끝나면 composer.lock 파일을 만들고, vendor 디렉터리 아래에는 설치한 라이브러리를 저장합니다.Git 등으로 애플리케이션 버전을 관리할 때는 composer.json, composer.lock 파일 모두 커밋하도록 합니다. composer.lock 파일이 없으면 자신의 로컬 환경과 다른 팀 멤버의 환경, 실제 서비스 환경에서 설치하는 라이브러리 버전이 다를 수 있으므로 반드시 커밋.Silex 매뉴얼에 있는 ‘Hello World’ 애플리케이션을 만들어 보자. 시작할 때 Composer가 생성한 ‘vendor/autoload.php’를 제일 먼저 읽어 들여 라이브러리를 자동으로 로딩 할 수 있다.&lt;?phprequire_once __DIR__.'/vendor/autoload.php';$app = new Silex/Application();$app-&gt;get('/hello/{name]', function ($name) user ($app) {\treturn 'Hello' . $app-&gt;escape($name) . PHP_EOL;});$app-&gt;run();API 만들기# 요청한 IP 주소를 반환한다$ curl -s http://httpbin.org/ip# 요청한 사용자 에이전트를 반환한다$ curl -s http://httpbin.org/user-agent# GET 요청에 HTTP 헤더, 요청 파라미터를 반환한다$ curl -s 'http://httpbin.org/get?foo=bar&amp;baz=qux'&lt;?phpuse Symfony\\Componet\\HttpFoundation\\Request;require_once __DIR__.'/vendor/autoload.php';$app = new Silex/Application();$app-&gt;get('/ip', function (Request $request) use ($app) {\treturn $app-&gt;json([\t\t'origin' =&gt; $request-&gt;getClientIp(),\t]);});$app-&gt;get('/user-agent', fuction (Request $request) use ($app) {\treturn $app-&gt;json([\t\t'user-agent' =&gt; $request-&gt;headers-&gt;get('User-Agent'),\t]);});$app-&gt;get('/get', function (Request $request) use ($app) {\t//헤더의 키를 '-'로 구분해 대문자로, user-agent -&gt; User-Agent\t$headers = [];\tforeach ($request-&gt;headers-&gt;all() as $key =&gt; $value) {\t\t$key = preg_replace_callback('/\\w+/', function($matches) {\t\t\treturn ucfirst($matches[0]);\t\t}, $key);\t\t$headers[$key] = $value[0];\t}\t\treturn $app-&gt;json([\t\t'args' =&gt; $request-&gt;query-&gt;all(),\t\t'headers' =&gt; $headers,\t\t'origin' =&gt; $request-&gt;getClientIp(),\t\t'user-agent' =&gt; $request-&gt;headers-&gt;get('User-Agent'),\t\t]);});$app-&gt;run();개발에 편리한 도구REPLRuby의 Pry와 같은 REPL은 PHP에서는 그다지 활발하게 사용하지 않는 것 같습니다. php -a 옵션으로도 대화식 모드를 이용하여 PHP를 실행할 수 있지만, 아주 간단한 기능만 제공하므로 기능이 풍부한 PsySH를 도입해서 사용해보자.PsySH는 composer를 사용해서 환경 전체에 설치할 수 있다.$ composer global require psy/psysh:@stable설치를 완료하면 psysh 커맨드로 Psy 셸을 사용할 수 있습니다.$ psysh’~/.psysh’ 아레에 사전 파일을 저장하면, PsySH 안에서 PHP 메뉴얼을 참조할 수 있습니다. 사전 파일은 다음과 같이 설치한다.$ curl -O http://psysh.org/manual/en/php_manual.sqlite$ mkdir ~/.psysh$ mv php_manual.sqlite ~/.psysh이제 ‘doc 함수 이름’으로 PHP 메뉴얼의 함수 정의를 참조할 수 있습니다. 다시 한 번 doc 커맨드를 테스트하는 명령어.$ psysh&gt;&gt;&gt; $d = new Datetime...&gt;&gt;&gt; doc $d-&gt;getOffserPsySH를 시작할 때 autoload 파일을 지정하면, PsySH 안에서 프로젝트에서 이용하는 라이브러리에도 액세스할 수 있다.$ cd /vendor$ psysh vendor/autoload.phpindex.php 소스 코드에서 /get 시작 부분에 다음처럼 브레이크 포인트를 삽입한다.&lt;?phpuser Symfony\\Component\\HttpFoundation\\Request;... 중략 ...$app-&gt;get('/get', function (Request $request) user ($app) {\t// 브레이크 포인트 \t\\Psy\\Shell::debug(get_defined_vars());\t\t// 헤더의 키를 '-'로 구분하여 대문자로, user-agent -&gt; User-Agent\t$headers = [];\t\t... 중략 ...\t});$app-&gt;run();호스트 운영체제에서 HTTP 요청을 보내면, PHP 빌트인 웹 서버를 실행한 콘솔에서 PsySH를 시작한다.코딩 규칙 점검, 분석PHP Coding Standards Fixer는 PSR-0~2와 Symfony 코딩 규칙 등을 따르는지 분석하고, 규칙을 따르지 않는 코드를 수정합니다.Composer로 설치할 수 있습니다.$ composer global require fabpot/php-cs-fixer앞서 소개한 API를 PSR 규칙에 반하도록 수정해본다.  PHP의 예약어를 대문자로 지정한다.  함수 정의 사이의 공백을 없앤다.  함수 이름과 () 사이에 공백을 넣는다.&lt;?phpuser Symfony\\Component\\HttpFoundation\\Request;require_once __DIR__.'/vendor/autoload.php';$app = NEW Silex/Application();\t$app-&gt;get('/ip', function(Request $request)use($app){\treturn $app-&gt;json([\t\t'origin' =&gt; $request-&gt;getClientIp(),\t]);});$app-&gt;run();?&gt;php-cs-fixer는 기본적으로 Symfony의 코딩 규약으로 검사한다. 변경사항을 표시하려고 diff 옵션을 지정하고, 검사할 수준은 PSR-2로 지정하여 실행한다.$ php-cs-fixer fix index.php --diff --level=psr2나머지 도구이외에도 PHP 개발에는 Git의 커밋 전에 훅을 호출하거나 CI와 연계하면 편리한 정적 분석 도구가 있습니다.PHPMDPHPMD는 정적으로 코드를 분석하여 거대한 클래스와 함수 등 복잡하고 버그가 생기기 쉬운 곳이나 개선하는 편이 나은 곳을 탐지하여 보고합니다.$ composer global require phpmd/phpmdPHPLOCPHPLOC는 코드의 행 개수나 클래스, 함수의 개수 등 프로젝트의 구성을 분석합니다.$ composer global require 'phploc/phploc=*'PHPCPDPHPCPD는 복사하여 붙여 넣은 코드를 찾아서 보고합니다.$ composer global require 'sebastian/phpcpd=*'정리Facebook이 HHVM이라는 PHP 실행 환경과 HHVM에서 동작하는 PHP 확장 언어인 Hack을 개발 중이다.HHVM에서 동작하는 Hack은 PHP에 없는 다음과 같은 강력한 기능을 추가하면서 기존 PHP 코드와 공존하여 동작시킬 수 있다.  정적 타입  제네릭스  비동기 처리",
        "url": "/blackruby-code//web/2017/12/24/Web2.html"
      }
      ,
    
      "web-2017-12-23-web1-html": {
        "title": "웹 엔지니어 - Ruby on Rails",
        "tags": "Web, Ruby, OAuth",
        "date": "December 23, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "Ruby on Rails로 개발Ruby의 개요Ruby는 마츠모토 유키히로(통칭 Matz)가 개발한 일본산 객체 지향 프로그래밍 언어입니다. Smalltalk, Lisp, Perl, Python 등 다양한 언어에서 영향을 받아 1993년에 태어났습니다.루비의 배열list = [1, 'hi', 3.14, 1, 2]puts list[2] # 3.14puts list.reverse # [2, 1, 3.14, 'hi', 1]puts list.class # Array루비의 해시hash = { foo: 1, bar: 2 }puts hash[:foo] # 1hash.each do |key, value|\tputs \"#{key} : #{value}\"end# foo : 1# bar : 2puts hash.class # HashRuby on Rails의 등장Rails는 애플리케이션 개발을 위한 라이브러리는 물론, 코드를 생성하는 도구의 동작을 확인하는 서버 등을 하나로 모은 풀 스택 프레임워크라는 특징이 있습니다.Rails의 기본 이념Rails의 기본 이념은 다음 두가지 입니다.  같은 일을 반복하지 않는다.  설정보다 규약이다.각각을 좀 더 자세하게 알아보겠습니다.같은 일을 반복하지 않는다.같은 코드나 설정을 여기저에 쓰지 않게 해서 전체 가독성을 높이고 유지 보수도 쉽게 하자는 발상입니다.  예를 들어, Rails에서는 DB의 스키마 정의를 설정 파일 등에 기술할 필요가 없습니다. DB에 테이블을 작성하기만 하면, 나머지는 Rails가 스키마 정의를 인식하여 임의의 칼럼에 액세스하는 메소드를 준비합니다.설정보다 규약이다.신중히 설계된 규약을 따라서 설정을 불필요하게 하거나 가볍게 한다는 발상입니다.  예를 들어, users 테이블이 있다면 모델은 User 모델에 자동으로 대응하는 등 Rails 스타일의 규약이 있습니다. 어떤 의미에서는 개발자에게 규약을 따를 것을 강제하는 것이지만, 그 결과로 테이블과 모델의 맵핑을 직접 명시할 필요가 없고 생산성이 높아집니다.RESTful API의 설계REST는 애플리케이션을 설계하는 방법 중 하나입니다. 조작 대상 리소스를 URL로 나타내고, HTTP 메소드인 GET, POST, DELETE, PUT을 사용하여 URL을 조작하는 방법입니다. 어떤 URL에 GET으로 액세스하면 결과를 목록으로 가져올 수 있고, 같은 URL에 POST로 액세스하면 새로 만들 수 있습니다.MVC(Model - View - Controller)Rails를 비롯한 요즘 웹 애플리케이션 프레임워크는 대부분 MVC 아키텍쳐를 사용합니다.모델먼저 모델입니다. 모델에서는 애플리케이션의 비즈니스 로직을 다룹니다. 데이터 입수와 저장 등을 담당하지만, 어떻게 표시할지는 뷰가 담당하므로 모델의 책임은 아닙니다. 어디까지나 데이터 처리만 담당합니다.뷰다음은 뷰 입니다. 뷰는 모델에서 받은 데이터를 적절히 가공해서 표시합니다. 보통은 데이터를 HTML 형식으로 반환하지만, API 서버에서는 데이터를 JSON 형식으로 출력하기도 합니다. 이것이 뷰의 역할입니다.컨트롤러마지막으로 컨트롤러 입니다. 컨트롤러는 브라우저나 커맨드라인의 요청을 받아 모델에 처리를 할당하고, 결과를 뷰에 전달합니다. 축구에서 말하는 사령탑과 역할이 같습니다. 컨트롤러는 편리한 존재로 임의의 처리를 기술할 수 있습니다. 하지만 뭐든지 다 컨트롤러에 적어 넣으면 이른바 Fat Controller 상태가 되므로 좋지 않습니다.Concerns 디렉터리컨트롤러에 처리를 기술하지 않고 모델에 모아 두면(Skinny Controller, Fat Model) 이번에는 모델 쪽 코드양이 늘어나서 보기에 좋지 않습니다. 이런 문제를 해결하고자 Rails4.0 부터는 Mixin용 모듈을 설치하는 디렉터리를 제공합니다.  app/models/concerns  app/controllers/concerns다수의 모델과 컨트롤러에서 공통된 처리는 모듈로 나눠 Concerns 디렉터리에 저장하세요. 이곳에 처리를 나누고 Mixin으로 모델이나 컨트롤러에서 사용하는 형태로 정리하면 보기 좋습니다.Rails로 애플리케이션 개발Rails 개발 환경 준비직접 Ruby나 Rails를 설치해도 되지만, 여기서는 rbenv Ruby 버전을 관리할 수 있는 도구를 사용하여 개발 환경을 준비합니다.rbenvrbenv는 다양한 버전의 Ruby를 관리하는 도구입니다. 예를 들어, 다음처럼 요구한다고 합시다.  새로운 버전의 Ruby를 사용하고 싶다.  오래된 버전의 Ruby에서 동작을 확인하고 싶다.  애플리케이션별로 Ruby 버전을 변경하고 싶다.요구마다 다른 버전의 Ruby를 설치하고 경로를 설정해야 한다면 아주 번거롭고 시간도 많이 걸립니다. 이때 rbenv를 사용해서 Ruby를 설치하면 쉽게 버전을 전환할 수 있습니다.다음처럼 rbenv를 사용하면 Ruby 버전을 전환할 수 있습니다.$ rbenv global 2.1.5 # 항상 2.1.5를 사용한다$ rbenv local 1.9.3 # 이 디렉터리 아래에서는 1.9.3을 사용한다$ rbenv shell 1.8.7 # 현재 셸에서는 1.8.7을 사용한다Ruby 설치하기먼저 필요한 라이브러리를 설치해야 합니다.$ sudo yum -y update &amp;&amp; sudo yum -y install git gcc openssl-devel libyaml-devel readline-devel zlib-devel splite-devel glibc-devel libffi-devel libxml2 libxslt libxml2-devel lixslt-devel다음으로 git clone 하여 rbenv를 설치 합니다.마지막으로 rbenv 설정을 ‘.bash_profile’에 추가하고 설정을 반영합니다.$ echo 'export PATH=\"$HOME/.rbenv/bin:$PATH\"' &gt;&gt; ~/.bash_profile$ echo 'eval \"$(rbenv init -)\"' &gt;&gt; ~/.bash_profile$ source ~/.bash_profileRails 다루기먼저 Rails를 설치합니다. Ruby 라이브러리는 RubyGems 사이트에 gem으로 저장되어 있습니다. 이 gem들을 설치하는 커맨드가 바로 gem install입니다. Rails에서는 의존 라이브러리가 많으므로 설치에 조금 시간이 걸립니다.$ gem install rails --no-ri --no-rdoc이번에는 만들 애플리케이션의 원형을 생성합니다. 이름은 아무것이나 상관없습니다.$ rails 아무이름 -B -Trails new 커맨드의 주요 옵션            옵션      단축 옵션      설명                  --skip-bundle      -B      bundle install 커맨드를 실행하지 않는다.              --skip-test-unit      -T      Test::Unit 파일을 만들지 않는다.              --database=DATABASE      -d      이용할 데이터베이스를 지정한다.(mysql, oracle, postgresql, sqlite3 등, 기본은 sqlite3)      Gemfile 파일에는 이 애플리케이션에서 사용할 gem 라이브러리가 기술되어 있습니다. Gemfile에는 therubyracer행이 주석으로 처리되어 있으므로 주석을 풀어주세요. therubyracer는 JavaScript 엔진인 v8을 Ruby에서 사용할 수 있게 하는 gem 입니다.bundle install 커맨드를 실행하면 Gemfile에 기술된 gem 라이브러리를 실행합니다.$ vi Gemfile-- Gemfile 내용 중 --# gem 'therubyracer', platforms: :ruby# 다음처럼 수정하고 [:wq]로 저장한다gem 'therubyracer', platforms: :ruby$ bundle install --path vendor/bundlervendor/bundler 아래에 각 gem 라이브러리가 설치되었습니다. 이 상태에서 rails server 커맨드로 테스트 서버를 시작하면, 3000번 포트로 애플리케이션에 액세스할 수 있습니다.$ rails server ......# 다음처럼 IP와 Port를 지정하여 시작할 수도 있다$ rails s -p 3000 -b 192.0.0.1지금은 Rails의 기본 톱페이지를 표시했습니다. 우선은 이 페이지를 독자적인 톱페이지로 변경해야 합니다.처음에는 rails generate controller 커맨드로 톱페이지용 컨트롤러를 작성합니다. 다음처럼 실행하면 ‘top’ 컨트롤러를 만들어 그 안에 index 액션을 정의 합니다.$ rails generate controller top index계속해서 config/routes.rb를 편집하여 톱페이지에 액세스할 때 이 ‘top’ 컨트롤러의 index 액션을 호출하도록 설정합니다.Rails.application.routes.draw do\troot 'top#index'end이제 http://localhost:3000에 접속하면 조금 전에 만든 ‘top’ 컨트롤러의 index 액션을 호출합니다.‘rails generate xxx’ 커맨드로 만든 일련의 파일은 ‘rails destroy xxx’커맨드로 삭제할 수 있으니 기억해두자.$ rails destroy controller top indexOAuth 인증 사용Facebook 피드나 GitHub 액티비티 목록을 작성 중인 애플리케이션에 표시하거나 Facebook이나 GitHub 계정을 사용하여 작성 중인 애플리케이션에 로그인하는 처리를 생각해보겠습니다. 이때는 OAuth 인증을 사용하면 좋습니다.OAuth 인증을 사용하지 않고 이런 처리를 구현하려면, Facebook이나 GitHub ID와 패스워드를 애플리케이션에서 입력 받아야만 합니다. 물론, 그렇게 해도 구현할 수는 있습니다. 하지만 애플리케이션 운영자가 사용자의 ID와 패스워드를 알 수 있으므로 나쁜 의도로 도용하는 등 위험이 있습니다.이 문제를 해결하려고 제안한 것이 OAuth 인증입니다. 이것은 대상 사이트에서 토큰을 받아서 일정한 조작을 사용자 대신 할 수 있게 하는 구조 입니다. 어떤 조작을 허가할지 제한할 수 있고, 최소한의 조작만 애플리케이션에 허락하므로 안전합니다.OAuth 인증 구현OAuth 인증은 devise와 omniauth라는 gem을 사용하여 구현합니다. Gemfile에 필요한 gem을 추가하고  bundle install 커맨드를 실행합니다.Gemfile에 추가할 내용  gem ‘devise’  gem ‘omniauth-facebook’  gem ‘omniauth-github’필요한 파일을 추가로 설치$ bundle install --path vendor/bundlerdevise의 초기 설정rails generate devise:install 다음은 User 모델을 만들고, 그곳에서 사용자를 관리합니다. provider, uid, name, token은 OAuth 인증에서 사용할 컬럼이 됩니다.$ rails generate devise user provider:string uid:string name:string token:stringrake db:migrate 커맨드로 migration 파일을 실행하고 users 테이블을 작성합니다.$ bundle exec rake db:migrate또, User 모델에서 ‘omniauthable’ 모듈을 추가합니다. devise에서는 기능이 모듈 단위로 나눠 있어 사용하고 싶은 모듈만 사용할 수 있습니다.class User &lt; ActiveRecord::Base\tdevise :database_authenticatable, :registerable,\t\t:recoverable, :rememberable, :trackable, :omniauthableend라우팅을 확인하면 다양한 라우팅이 자동으로 설정되어 있습니다. rake를 bundler로 설치했기 때문에 커맨드 앞에 ‘bundle exec’를 붙여야 하므로 주의해야 합니다.$ bundle exec rake routes라우팅이 많아 복잡하게 보이지만, OAuth 인증에 주로 관계된 것은 /users/auth/:provider와 /users/auth/:action/callback 2개 뿐입니다.OAuth 인증은 먼저 /user/auth/:provider에 액세스하면, ‘OAuth Server’로 리디렉션하는 과정으로 진행합니다. 예를 들어, Facebook은 URL로 리디렉션 됩니다.app/views/top/index.html.erb를 변경하고 OAuth 인증용 링크를 준비합니다.나머지는 사전에 작성 중인 애플리케이션을 OAuth Client로서 등록해야 합니다. 이것은 OAuth 인증을 할 수 있는 OAuth Client를 제한하기 위함입니다.Facebook과 GitHub는 앱을 등록하기 위해서 ID와 Secret라는 값이 필요합니다.취득한 해당값을 config/initializers/devise.rb에 설정합니다. \t로그인 인증용 gem인 devise의 secret key를 설정하지 않았다는 오류를 표시하면, 오류 메세지에 포함된 키를 복사해서 secret_key를 지정하거나 rake secret 커맨드를 생성하여 지정할 수 있습니다.$ vi config/initializers/devise.rbrequire 'devise'# User this hook to configure devise mailer, warden hooks and so forth.#Many of these configuration options can be set straight in your model.Devise.setup do |config|# 추가config.secret_key = '생성된 키'파라미터로 client_id를 전달하면, 이 값으로 등록된 OAuth Client인지 확인하여 어느 OAuth Client의 요청인지 판별합니다.한 번 인증하면 다음부터는 인증 페이지를 표시하지 않습니다. OAuth Server 쪽에서 인증된 애플리케이션으로 등록되어 있기 때문입니다. 인증된 애플리케이션 페이지에서 해당 애플리케이션을 삭제하면, 다시 인증 페이지를 표시합니다.인증을 마치면 다시 애플리케이션으로 돌아옵니다. 이때 URL의 라우팅이 ‘/users/auth/:action/callback’이 됩니다.콜백 URL로 돌아왔을 때 처리가 아직 없으므로 구현해 보면, 우선 ‘config/routes.rb’에서 콜백 처리를 ‘app/controllers/users/omniauth_callbacks_controller.rb’에서 받도록 합니다.‘app/controllers/users/omniauth_callbacks_controller.rb’에서는 콜백 URL을 받아들여 Facebook으로 인증할 때는 Facebook 메소드가, GitHub 계정으로 인증 할 때는 github 메소드가 처리를 담당합니다.데이터는 request.env[‘omniauth.auth’]로 받을 수 있으므로 값을 단순히 저장합니다.그런 다음, 다음의 커맨드를 실행하면 데이터가 등록된 것을 확인 할 수 있습니다.$ rails dbGists 목록 가져오기우선 octokit와 httparty gem을 Gemfile에 추가하고, bundle install 커맨드로 설치합니다. 이 gem을 사용해서 GitHub의 API를 호출합니다.gem 'octokit', '~&gt; 3.0'gem 'httparty'인증에 성공하면 Gists 목록을 그대로 가져옵니다.class Users::OmniauthCallbacksController &lt; Devise::OmniauthCallbacksController\tdef facebook\t\t# facebook으로 인증할 때 callback 처리는 이곳에 기술한다\tend\t\tdef github\t\tauth = request.env['omniauth.auth']\t\t@user User.find_by_provider_and_uid(auth['provider'], auth['uid']) ||\t\t\t   User.create_with_omniauth(auth)\t\t\t   \t   octokit = Octokit::Client.new(access_token: @user.token)\t   octokit.gitst.each do |gist|\t   \tunless Snippet.find_by(gist_id: gist[:id])\t   \t\tgist[:files].to_hash.each do |filename, gist_info|\t   \t\t\tlanguage = gist[:files][filename][:language]\t   \t\t\tresponse = HTTParty.get(gist[:files][filename][:raw_url])\t   \t\t\t\t   \t\t\tsnippet = Snippet.create(\t   \t\t\t\tgist_id: gist[:id],\t   \t\t\t\tgist_url: gist[:html_url],\t   \t\t\t\tlanguage: language.try(:downcase),\t   \t\t\t\tplain_code: response.force_encoding('utf-8'),\t   \t\t\t\tuser: @user   \t\t\t\t)\t\t\tend\t\tend\tend\t\tsign_in_and_redirect @user, event: :authenticationendendsnippets 컨트롤러를 만들어 Gists 목록을 표시해 보겠습니다.$ rails generate controller snippets index이어서 Snippet 모델을 준비하고 오리지널 코드를 보존하는 plain_code 칼럼과 신택스 하이라이트된 코드를 저장하는 highlighted_code 칼럼을 준비합니다. Gitsts의 ID와 URL을 저장하는 칼럼도 만들어 두면 편리합니다.비동기 처리이대로면 코드의 신택스 하이라이트가 없어서 보기에 불편합니다. 다음으로 코드의 신택스 하이라이트를 생각합니다. 코드의 신책스 하이라이트는 Pygments라는 외부 서비스를 이용하기로 합니다. Pygments API에 코드와 언어 종류를 POST 방식으로 전송합니다.하지만 실제로 Pygments API를 사용할 때는 스니펫마다 5~6초 정도 기다려야 합니다. 또, Pygments API가 다운되면 응답이 돌아오지 않으므로 아무리 기다려도 화면이 나타나지 않을 수 있습니다.이 문제를 피하려고 이번에는 Pygments API 호출을 비동기 처리로 하겠습니다. 비동기 처리를 하는 라이브러리로 sidekiq이라는 gem을 사용합니다.Gemfile에 sidekiq을 추가하고 bundle install 커맨드를 실행gem 'sidekiq'비동기 처리는 app/workers 디렉터리 아래에 저장합니다. app/workers 디렉터리를 새로 만들고, 그 안에 pygments_worker.rb를 작성합니다. app/workers 디렉터리 아래에 저장하면 애플리케이션에 자동으로 로드 됩니다.class PygmentsWorker\tinclude Sidekiq::Worker\t\tdef perform(snippet_id)\t\tsnippet = Snippet.find(snippet_id)\t\turi = URI.parse('http://pygments.slmplabs.com/')\t\trequest = Net::HTTP.post_form(uri, {lang: snippet.language, code: snippet.plain_code})\t\tsnippet.update(highlighted_code: request.body}\tendend이제 비동기 처리를 실현했습니다. highlighted_code가 nil일 때만 PygmentsWorker를 호출하고, 비동기 처리로 큐에 등록합니다. 그 결과, 순식간에 페이지 응답이 돌아오도록 개선했습니다.테스트하기동작을 보증하는 테스트도 중요한데, 이번에는 RSpec gem을 사용하여 테스트를 실행합니다. 우선 Gemfile에 rspec_rails와 함께 factory_girl_rails라는 gem을 추가합니다. FactoryGirl이란 테스트용 데이터를 간편하게 준비해주는 gem입니다.group :devlopment, :test do\tgem 'rspec-rails', '~&gt;3.1'\tgem 'factory_girl_rails'endbundle install 커맨드로 설치하고, 초기화 처리도 합니다.이번에는 Devise를 사용하므로, rails_helper.rb 파일에 내용을 추가합니다.테스트 데이터의 통합 관리테스트하기 전에 먼저 테스트 데이터를 준비하고 싶을 수도 있습니다. 물론, 테스트 중에도 ActiveRecord를 사용해서 테스트 데이터를 등록할 수 있습니다. 하지만 여러 테스트 케이스에서 같은 데이터를 사용할 때가 자주 있으므로, 테스트 데이터의 정의를 어딘가에서 통합해서 관리하고 싶을 것 입니다. 이때 FactoryGirl을 사용하면 테스트 데이터를 통합해서 관리할 수 있습니다.시간관련 테스트다음처럼 Helper를 작성합니다.module DateHelper\tdef date_format(date)\t\tdate.strtime(\"%Y년%m월%d일입니다\")\t\tendend이 테스트는 9월 15일에 실행하면 성공하지만, 9월 16일에 실행하면 실패합니다.이때는 다음처럼 오늘이 아니라 특정 일자를 넘겨주는 방법이 좋지만, 여기서는 timecop이라는 gem을 사용해서 대처해 보겠습니다.우선 Gemfile에 gem ‘timecop’를 추가하고 bundle install 커맨드로 설치합니다. timecop은 테스트에서 시간을 다룰 때 사용할 수 있는 편리한 gem으로, Timecop, freeze나 Timecop.travel등 커맨드로 테스트 중 시간을 임의로 설정할 수 있습니다.목과 스텁 활용테스트를 작성할 때 빠뜨릴 수 없는 것이 목과 스텁의 존재입니다. 예를 들어, 모델과 API 등을 아직 구현하지 않아 테스트를 작성하려 해도 할 수 없을 때가 있습니다. 이때 테스트를 작성할 수 있게 하는 편리한 장치가 목과 스텁입니다. 용도에 따라 종류는 다음과 같습니다.doubledouble을 사용하면 ‘더미 오브젝트’를 작성할 수 있습니다.# 더미 오브젝틀르 만든다. # 제1인수는 생략할 수 있지만, 오류가 발생하면 표시되므로 입력하면 좋다 book = double('book')# book.title을 호출하면 'karaage Book?'이 돌아오는 더미 오브젝트book = double('book', title: 'karaage Book?')stubstub를 사용하면 ‘더미 메소드’를 작성할 수 있습니다.# 모두 book.title을 호출하면 'karaage Book?'을 반환하는 더미 메소드book.stub(:title) {'karaage Book?'}book.stub(\"title =&gt; 'karaage Book?')book.stub(:title).and_return('karaage Book?')#double로 만든 더미 오브젝트가 아니더라도 더미 메소드는 정의할 수 있다. String.stub(:test).and_return('test')mockmock을 사용하면 메소드의 행동을 평가하는 ‘더미 오브젝트’를 작성할 수 있습니다.Book.should_receive(:find).with(:all).and_return([book])편리한 gem 소개Rails로 개발할 때 알아 두면 편리한 gem이 여럿 있습니다. 여기서는 이 편리한 gem의 일부를 소개합니다.  Pry  Better Errors  MailCatherPryRuby에서 메소드의 움직임을 조사하거나 간단한 예제 코드를 실행할 때 편리한 것이 irb입니다. irb는 interactive ruby의 준말로, Ruby를 설치한 환경에서 사용할 수 있는 REPL(대화형 실행 환경)입니다.Better ErrorsBetter Errors를 사용하면 오류가 발생했을 때 화면에 손쉽게 보여 줍니다. 게다가 binding_of_caller라는 gem을 함께 사용하면 브라우저상에서 디버그할 수도 있습니다.MailCatcher애플리케이션을 개발하다 보면 메일을 전송해야 할 때가 많습니다. 개발 중에 메일이 제대로 전송하는지 확인하고 싶지만, 일부러 개발용 메일 전송 환경을 만들기가 번거롭습니다. 또 잘못해서 테스트 메일을 실제 사용자에게 전송한다면 큰일이겠지요. 이 때 안전하게 메일전송을 확인할 수 있는 gem으로 MailCatcher가 있습니다.정리Ruby의 개요 및 Ruby on Rails의 기본 이념부터 Rails를 사용하여 기능을 구현하거나 테스트를 작성하는 일련의 개발 프로세스를 소개했습니다. Rails는 규칙에 따라 처리를 구현하기에 매우 빠르고 안전하게 개발을 진행할 수 있는 프레임워크입니다.",
        "url": "/blackruby-code//web/2017/12/23/Web1.html"
      }
      ,
    
      "web-2017-12-20-web-html": {
        "title": "웹 엔지니어 - 웹 엔지니어",
        "tags": "Web, Python, Flask",
        "date": "December 20, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "웹 엔지니어의 교과서웹 엔지니어웹 엔지니어는 어떤 일을 할까?웹 엔지니어여기에서는 Ruby나 PHP로 웹 애플리케이션을 개발하는(프런트 엔드도 하지만 주로 서버사이드를 담당하는) 엔지니어를 가리켜 웹 엔지니어로 정의합니다.웹 엔지니어가 하는 일웹 애플리케이션의 요구 사항 정의와 설계, 개발, 테스트 등 서비스의 공개나 개선과 관련된 일을 주로 합니다.  트위터  요구 사항 정의  설계  개발  테스트  오류의 원인 조사  버그 수정  로그 분석  기술 조사  코드 리뷰풀스택 엔지니어최근 '풀 스택 엔지니어'라는 말이 화젯거리입니다. 풀스택 엔지니어는 프런트 엔드, 서버사이드, 인프라 등 여러 분야에서 폭넓게 잘할 수 있는 엔지니어를 의미합니다.필요한 기술 영역웹 엔지니어는 보통 다음의 기술 영역을 다룹니다.  HTML  CSS  프런트 엔드  서버사이드  데이터베이스  웹 서버  AWS  GithubHTMLHTML은 웹에서 문서를 표시하는 마크업 언어입니다.HTML은 첫 버전인 HTML 1.0이 탄생한 이후 여러 번 사양이 변경되어 HTML5 버전까지 등장했습니다.HTML5에는 다음과 같은 특징이 있습니다.  동영상과 음성, 그래프를 표현할 수 있다.  API를 새롭게 추가할 수 있다.  폼 관련 기능을 강화했다.  긴 선언을 생략할 수 있다.  더 명확하게 문서 구조를 나타낼 수 있다.CSSCSS는 Cascading Style Sheets의 약어로, 웹 애플리케이션의 스타일을 지정하는 언어입니다. 보통 HTML로는 문서 구조를 정의하고, CSS로는 스타일을 제어하는 방식으로 구분해서 사용합니다.최근에는 SCSS라고 하는 메타 언어도 등장했습니다. SCSS를 사용하면 중첩하여 똑같은 태그를 여러 번 지정하지 않아도 되고, 몇 번씩 등장하는 값은 변수로 선언해서 선언한 곳만 값을 수정하면 됩니다.프런트 엔드JavaScript와 jQuery를 사용한 프런트 엔드 개발입니다. 예를 들어, 특정 요소가 처음에는 숨어 있다가 어떤 버튼을 클릭하면 표시한다거나 특정 요소를 동적으로 추가하는 등 처리를 합니다.서버사이드Ruby, PHP, Perl, Python 등을 사용한 서버사이드 개발입니다. 이 분야는 웹 엔지니어로서 갖춰야 할 가장 기본적인 기술 영역입니다. 프런트 엔드 쪽에서 표시를 제어한다고 해도 애초에 서버사이드에서 데이터를 가져와야 합니다.사용 언어별 프레임워크를 정리하면 다음과 같습니다!            언어      프레임워크                  Ruby      Rails, Sinatra, Padrino              PHP      CakePHP, FuelPHP, Symfony, Laravel              Perl      Cataliyst, Mojolicious, Mojolicious::Lite              Python      Django, Tornado, Flask, Bottle      데이터 베이스MySQL이나 PostgreSQL, Oracle 등 관계형 데이터베이스도 웹 애플리케이션을 개발 할 때 피해 갈 수 없습니다. 극단적으로 말하면, 데이터베이스에서 데이터를 꺼내어 표시하는 것이 웹 애플리케이션 입니다. 당연히 데이터베이스를 조작하려면 SQL을 다룰 수 있어야 합니다.또, 웹 애플리케이션은 데이터베이스에서 데이터를 얼마나 빨리 읽을 수 있는지가 중요합니다. Amazon 조사에 따르면, 웹 페이지 표시 속도가 0.1초 느려지면 매출이 1% 감소한다고 합니다. 그리고 구글은 웹 페이지 반응이 0.5초 느려지면 방문자 수가 20% 감소한다고 발표했습니다.이처럼 웹 페이지 표시 속도는 매출과 방문자 수에 큰 영향을 미치게 됩니다.웹 서버웹 애플리케이션을 공개하려면 아파치(Apache)나 엔진엑스(Nginx)등 웹 서버를 다루는 일도 피해갈 수 없습니다. 요즘에는 Nginx를 자주 사용합니다.AWS최근 클라우드 서비스, 그중에서도 특히 AWS(Amazon Web Service)를 사용하여 웹 서버나 데이터베이스를 구축하는 사례가 늘었습니다. AWS에서는 Amazon EC2, Amazon S3 등 아주 많은 서비스를 제공 합니다.Github코드 호스팅 서비스로 GitHub를 이용하는 사례가 늘었습니다. 이미 많이들 GitHub에서 프로젝트를 알리거나 코드 리뷰를 하고 있지요?계속 새롭게 등장하는 기술새로운 기술의 등장을 즐길 수 있으냐는 앞으로 웹 엔지니어로 살아가는 데 중요한 자질이 될 것입니다.  NoSQL 데이터베이스  JavaScript 프레임워크  Fluentd  그래프로 시각화  가상화 기술  프로비저닝 도구NoSQL 데이터베이스NoSQL 데이터베이스에는 맴캐시드와 Redis, MongoDB 등이 있습니다. 관계형 데이터베이스가 취약한 부분에서 강점을 보일 때가 많으므로 적재적소에 활용하면 좋습니다.JavaScript 프레임워크프런트 엔드 구현에서는 jQuery를 사용한 DOM 조작을 생각할 수 있습니다. jQuery가 등장한 덕분에 JavaScript를 사용하는 번거로운 DOM 조작을 아주 간편하게 기술할 수 있습니다. 하지만 최근에는 프런트 엔드를 대규모로 개발하여 jQuery만으로는 대규모 JavaScript 프로그램을 관리하기가 어렵습니다.  MVC는 대표적인 좋은 설계 방식입니다.MVC는 Model(비즈니스 로직을 담당하는 부분), View(표시를 담당하는 부분), Controller(입력을 받아 Model과 View를 연결하는 부분)의 약어로, 크게 세 부분으로 나눠 프로그램을 기술하는 설계 방식입니다.MVC 아키텍쳐Fluentd여러 대의 서버에 로그를 조금씩 저장한 상태에서는 막상 보고 싶을 때 모든 로그를 간단히 확인할 수 없다는 문제가 발생합니다. 이 문제는 로그 수집 도구인 Fluentd로 해결할 수 있습니다. Fluentd를 사용하면 여러 대의 서버에 흩어져 있는 로그를 거의 실시간으로 특정 서버로 모을 수 있습니다.그래프로 시각화로그를 분석해서 KPI 등 다양한 항목을 측정하고, 관리 화면 등에 그 값을 표시할 때가 많습니다. 이때 측정한 데이터를 그래프로 시각화하는 기술이 필요합니다. 데이터를 시각화하면 숫자에 강한 일부 전문가뿐만 아니라 팀 전체에서 쉽게 공유할 수 있습니다.가상화 기술가상화는 Vagrant나 Docker 등이 등장하면서 매우 활성화된 분야입니다. Vagrant나 Docker를 사용하면 환경 구축을 자동화할 수 있습니다.프로비저닝 도구프로비저닝(필요한 라이브러리와 미들웨어를 설치하고 원하는 서버 상태로 만드는 것)에는 Chef와 Ansible과 같은 도구를 사용하면 편리합니다. 여러 대의 서버를 한꺼번에 처리할 수 있으므로 어떤 서버에는 설치하고 어떤 서버에는 설치하지 않거나, 특정 서버와 다른 서버의 버전이 달라지는 등 서버 간 불일치를 막을 수 있습니다.",
        "url": "/blackruby-code//web/2017/12/20/Web.html"
      }
      ,
    
      "code-2017-12-20-code-html": {
        "title": "문제풀이 - 코딩도장",
        "tags": "Algorithm, Code, Python",
        "date": "December 20, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "1차원의 점들이 주어졌을 때, 그 중 가장 거리가 짧은 것의 쌍을 출력하는 함수를 작성하시오. (단 점들의 배열은 모두 정렬되어있다고 가정한다.)예를들어 S={1, 3, 4, 8, 13, 17, 20} 이 주어졌다면, 결과값은 (3, 4)가 될 것이다.s = [1,23,11,24,32]distance = 10000result = [0, 0]for i in range(len(s)):   if i == 0:      continue   else:      tmp_distance = abs(s[i] - s[i - 1])      if tmp_distance &lt; distance:         distance = tmp_distance         result[0] = i - 1         result[1] = iprint(s[result[0]], s[result[1]])",
        "url": "/blackruby-code//code/2017/12/20/Code.html"
      }
      ,
    
      "blockchain-2017-12-19-blockchain-html": {
        "title": "블록체인기술의 개념(O'reilly-blockchain)",
        "tags": "Blockchain",
        "date": "December 19, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "[원문]We may be at the dawn of a new revolution.This revolution started with a new fringe economy on the Internet, an alternative currency called Bitcoin that was issued and backed not by a central authority, but by automated consensus among networked users. Its true uniqueness, however, lay in the fact that it did not require the users to trust each other. Through algorithmic self-policing, any malicious attempt to defraud the system would be rejected. In a precise and technical definition, Bitcoin is digital cash that is transacted via the Internet in a decentralized trustless system using a public ledger called the blockchain. It is a new form of money that combines BitTorrent peer-to-peer file sharing1 with public key cryptography.2 Since its launch in 2009, Bitcoin has spawned a group of imitators—alternative currencies using the same general approach but with different optimizations and tweaks. More important, blockchain technology could become the seamless embedded economic layer the Web has never had, serving as the technological underlay for payments, decentralized exchange, token earning and spending, digital asset invocation and transfer, and smart contract issuance and execution. Bitcoin and blockchain technology, as a mode of decentralization, could be the next major disruptive technology and worldwide computing paradigm (following the mainframe, PC, Internet, and social networking/mobile phones), with the potential for reconfiguring all human activity as pervasively as did the Web.[번역]  우리는 새로운 혁명의 새벽에 있을지도 모릅니다.이 혁명은 중앙 권위가 아니라 네트워크 사용자 간의 자동 합의에 의해 발행되고지지 된 Bitcoin이라는 대체 통화 인 인터넷에서 새로운 프린지 경제로 시작되었습니다. 그러나 진정한 독창성은 사용자가 서로 신뢰하지 않아도된다는 사실에있었습니다. 알고리즘 자체 폴링을 통해 악의적 인 시스템 사기 시도가 거부됩니다. 정확하고 기술적 인 정의에서, Bitcoin은 블록 체인이라는 공공 장부를 사용하여 분산 된 트러스트리스 시스템에서 인터넷을 통해 거래되는 디지털 현금입니다. BitTorrent 피어 투 피어 파일 공유 1과 공개 키 암호화 2를 결합한 새로운 형태의 돈입니다.2 Bitcoin은 2009 년 출시 이후 동일한 일반적인 접근법을 사용하지만 최적화와 조정이 다른 모방 자 그룹을 탄생 시켰습니다. 더 중요한 것은 블록 체인 기술은 지불, 분산 형 교환, 토큰 획득 및 지출, 디지털 자산 호출 및 전송, 스마트 계약 체결 및 실행을위한 기술적 인 기반 역할을하는 웹이 없었던 매끄러운 임베디드 경제 계층이 될 수 있습니다. 분권화 모드 인 Bitcoin 및 블록 체인 기술은 다음과 같은 주요 파괴적인 기술 및 전 세계 컴퓨팅 패러다임 (메인 프레임, PC, 인터넷 및 소셜 네트워킹 / 휴대폰에 이어)으로서 모든 인간 활동을 다음과 같이 광범위하게 재구성 할 수 있습니다.[원문]What Is Bitcoin?Bitcoin is digital cash.It is a digital currency and online payment system in which encryption techniques are used to regulate the generation of units of currency and verify the transfer of funds, operating independently of a central bank. The terminology can be confusing because the words Bitcoin and blockchain may be used to refer to any three parts of the concept: the underlying blockchain technology, the protocol and client through which transactions are effected, and the actual cryptocurrency (money); or also more broadly to refer to the whole concept of cryptocurrencies. It is as if PayPal had called the Internet “PayPal,” upon which the PayPal protocol was run, to transfer the PayPal currency. The blockchain industry is using these terms interchangeably sometimes because it is still in the process of shaping itself into what could likely become established layers in a technology stack.[번역]  Bitcoin은 무엇인가?Bitcoin은 디지털 현금입니다.이것은 디지털 통화 및 온라인 지불 시스템으로 암호화 기술을 사용하여 통화 단위 생성을 규제하고 중앙 은행과 독립적으로 운영되는 자금의 이체를 확인합니다. Bitcoin과 blockchain이라는 단어가 개념의 세 부분, 즉 기본 블록 체인 기술, 트랜잭션이 수행되는 프로토콜과 클라이언트, 실제 암호 화 (돈)를 언급하기 위해 사용되기 때문에 전문 용어가 혼란 스러울 수 있습니다. cryptocurrencies의 전체 개념을 언급하는 데 더 광범위하게 사용됩니다. 마치 PayPal이 PayPal 통화를 전송하기 위해 PayPal 프로토콜이 실행 된 인터넷 “PayPal”을 호출 한 것과 같습니다. 블록 체인 업계는 때때로 기술 스택에서 확립 된 레이어가 될 수 있는 요소를 형성하는 과정에 있기 때문에 이러한 용어를 서로 바꾸어 사용합니다.[원문]Bitcoin was created in 2009 (released on January 9, 20096) by an unknown person or entity using the name Satoshi Nakamoto. The concept and operational details are described in a concise and readable white paper, “Bitcoin: A Peer-to-Peer Electronic Cash System.”7 Payments using the decentralized virtual currency are recorded in a public ledger that is stored on many—potentially all—Bitcoin users’ computers, and continuously viewable on the Internet. Bitcoin is the first and largest decentralized cryptocurrency. There are hundreds of other “altcoin” (alternative coin) cryptocurrencies, like Litecoin and Dogecoin, but Bitcoin comprises 90 percent of the market capitalization of all cryptocurrencies and is the de facto standard. Bitcoin is pseudonymous (not anonymous) in the sense that public key addresses (27–32 alphanumeric character strings; similar in function to an email address) are used to send and receive Bitcoins and record transactions, as opposed to personally identifying information.Bitcoins are created as a reward for computational processing work, known as mining, in which users offer their computing power to verify and record payments into the public ledger. Individuals or companies engage in mining in exchange for transaction fees and newly created Bitcoins. Besides mining, Bitcoins can, like any currency, be obtained in exchange for fiat money, products, and services. Users can send and receive Bitcoins electronically for an optional transaction fee using wallet software on a personal computer, mobile device, or web application.[번역]      Bitcoin은 2009 년 1 월 9 일에 발표 된 나카 모토 사토시 (Satoshi Nakamoto)라는 이름을 사용하여 알려지지 않은 사람이나 단체에 의해 작성되었습니다. 개념 및 운영 세부 사항은 간결하고 읽기 쉬운 백서 “Bitcoin : 피어 - 투 - 피어 전자 현금 시스템”에 설명되어 있습니다. 7 분산 가상 화폐를 사용하는 지급은 잠재적으로 모두에 저장된 공공 장부에 기록됩니다 -Bitcoin 사용자의 컴퓨터 및 인터넷에서 지속적으로 볼 수 있습니다. 비트 코인 (Bitcoin)은 최초이자 가장 큰 분산 형 크립토 커 런시 (cryptocurrency)입니다. Litecoin과 Dogecoin 같은 다른 “altcoin”(대체 동전) cryptocurrencies가 있지만 Bitcoin은 모든 cryptocurrencies의 시가 총액의 90 %를 차지하며 사실상의 표준입니다. Bitcoin은 개인 식별 정보가 아니라 공개 키 주소 (전자 메일 주소와 기능면에서 27-32 자의 영숫자 문자열)가 Bitcoins을 보내고 수신하는 데 사용된다는 의미에서 익명입니다 (익명은 아닙니다).        Bitcoins은 광업으로 알려진 전산 처리 작업에 대한 보상으로 만들어지며, 사용자가 계산을 통해 공공 장부에 지불을 확인하고 기록합니다. 개인이나 회사는 거래 수수료 및 새로 생성 된 Bitcoins과 교환하여 광업에 종사합니다. 광업 외에도 Bitcoins는 통화와 마찬가지로 현금, 제품 및 서비스와 교환 할 수 있습니다. 사용자는 개인용 컴퓨터, 모바일 장치 또는 웹 응용 프로그램에서 Wallet 소프트웨어를 사용하여 선택적 거래 수수료로 Bitcoins을 전자적으로 보내고받을 수 있습니다.  [원문]What Is the Blockchain?The blockchain is the public ledger of all Bitcoin transactions that have ever been executed. It is constantly growing as miners add new blocks to it (every 10 minutes) to record the most recent transactions. The blocks are added to the blockchain in a linear, chronological order. Each full node (i.e., every computer connected to the Bitcoin network using a client that performs the task of validating and relaying transactions) has a copy of the blockchain, which is downloaded automatically when the miner joins the Bitcoin network. The blockchain has complete information about addresses and balances from the genesis block (the very first transactions ever executed) to the most recently completed block. The blockchain as a public ledger means that it is easy to query any block explorer (such as https://blockchain.info/) for transactions associated with a particular Bitcoin address—for example, you can look up your own wallet address to see the transaction in which you received your first Bitcoin.[번역]  블록 체인은 지금까지 실행 된 모든 Bitcoin 트랜잭션의 공용 원장입니다. 광부들이 가장 최근의 거래를 기록하기 위해 매 10 분마다 새로운 블록을 추가함에 따라 지속적으로 증가하고 있습니다. 블록은 선형, 연대순으로 블록 체인에 추가됩니다. 모든 전체 노드 (즉, 거래의 유효성을 확인하고 릴레이하는 작업을 수행하는 클라이언트를 사용하여 Bitcoin 네트워크에 연결된 모든 컴퓨터)에는 광부가 Bitcoin 네트워크에 가입 할 때 자동으로 다운로드되는 블록 체인 복사본이 있습니다. Blockchain은 창세기 블록 (실행 된 첫 번째 트랜잭션)에서 가장 최근에 완료된 블록까지의 주소 및 잔액에 대한 완전한 정보를 가지고 있습니다. 공용 장부로서의 블록 체인은 특정 Bitcoin 주소와 관련된 트랜잭션에 대해 블록 탐색기 (예 : https://blockchain.info/)를 쿼리하는 것이 쉽다는 것을 의미합니다. 예를 들어 자신의 지갑 주소를 조회하여 첫 번째 Bitcoin을받은 거래.[원문]The blockchain is seen as the main technological innovation of Bitcoin because it stands as a “trustless” proof mechanism of all the transactions on the network. Users can trust the system of the public ledger stored worldwide on many different decentralized nodes maintained by “miner-accountants,” as opposed to having to establish and maintain trust with the transaction counterparty (another person) or a third-party intermediary (like a bank). The blockchain as the architecture for a new system of decentralized trustless transactions is the key innovation. The blockchain allows the disintermediation and decentralization of all transactions of any type between all parties on a global basis.[번역]  Blockchain은 Bitcoin의 주요 기술 혁신으로 간주됩니다. BitCin은 네트워크상의 모든 트랜잭션을 “신뢰할 수없는”증명 메커니즘으로 간주하기 때문입니다. 사용자는 거래 상대방 (타인) 또는 제 3 자 중개자 (예 : 거래 상대방)와의 신뢰를 쌓고 유지해야하는 것과 달리 “광부 - 회계사”가 관리하는 여러 분산 된 노드에 전 세계에 저장된 공공 장부 시스템을 신뢰할 수 있습니다. 은행). 분산 된 트러스트없는 트랜잭션의 새로운 시스템을위한 아키텍처 인 블록 체인은 핵심 혁신입니다. 블록 체인은 모든 유형의 모든 거래를 글로벌 차원에서 모든 당사자간에 분산 및 분권화 할 수 있습니다.[원문]The blockchain is like another application layer to run on the existing stack of Internet protocols, adding an entire new tier to the Internet to enable economic transactions, both immediate digital currency payments (in a universally usable cryptocurrency) and longer-term, more complicated financial contracts. Any currency, financial contract, or hard or soft asset may be transacted with a system like a blockchain. Further, the blockchain may be used not just for transactions, but also as a registry and inventory system for the recording, tracking, monitoring, and transacting of all assets. A blockchain is quite literally like a giant spreadsheet for registering all assets, and an accounting system for transacting them on a global scale that can include all forms of assets held by all parties worldwide. Thus, the blockchain can be used for any form of asset registry, inventory, and exchange, including every area of finance, economics, and money; hard assets (physical property); and intangible assets (votes, ideas, reputation, intention, health data, etc.).[번역]  블록 체인은 기존의 인터넷 프로토콜 스택에서 실행되는 또 다른 응용 프로그램 계층과 같으며 인터넷에 전체 계층을 추가하여 경제 거래 (즉각적인 디지털 통화 지불 (보편적으로 사용 가능한 cryptocurrency에서)와 장기적이고 복잡한 재무 관리 계약. 모든 통화, 금융 계약 또는 하드 또는 소프트 자산은 블록 체인과 같은 시스템으로 거래 될 수 있습니다. 또한 블록 체인은 트랜잭션뿐만 아니라 모든 자산의 기록, 추적, 모니터링 및 트랜잭션을위한 레지스트리 및 재고 시스템으로도 사용될 수 있습니다. 블록 체인은 말 그대로 모든 자산을 등록하는 거대한 스프레드 시트와 같으며 전 세계 모든 당사자가 보유한 모든 형태의 자산을 포함 할 수있는 글로벌 규모로 거래하는 회계 시스템입니다. 따라서 블록 체인은 금융, 경제 및 자금의 모든 영역을 포함하여 자산 등록, 재고 및 교환의 형태로 사용될 수 있습니다. 딱딱한 자산 (물적 재산); 무형 자산 (투표, 아이디어, 평판, 의도, 건강 데이터 등).[원문]The Connected World and Blockchain: The Fifth Disruptive Computing ParadigmOne model of understanding the modern world is through computing paradigms, with a new paradigm arising on the order of one per decade (Figure P-1). First, there were the mainframe and PC (personal computer) paradigms, and then the Internet revolutionized everything. Mobile and social networking was the most recent paradigm. The current emerging paradigm for this decade could be the connected world of computing relying on blockchain cryptography. The connected world could usefully include blockchain technology as the economic overlay to what is increasingly becoming a seamlessly connected world of multidevice computing that includes wearable computing, Internet-of-Things (IoT) sensors, smartphones, tablets, laptops, quantified self-tracking devices (i.e., Fitbit), smart home, smart car, and smart city. The economy that the blockchain enables is not merely the movement of money, however; it is the transfer of information and the effective allocation of resources that money has enabled in the human- and corporate-scale economy.[번역]  현대 세계를 이해하는 한 가지 모델은 컴퓨팅 패러다임을 통해 이루어지며 새로운 패러다임은 10 년에 한 번씩 발생합니다 (그림 P-1). 첫째, 메인 프레임과 PC (개인용 컴퓨터) 패러다임이 있었고 인터넷은 모든 것을 혁명적으로 변화 시켰습니다. 모바일 및 소셜 네트워킹이 가장 최근의 패러다임이었습니다. 이 10 년 동안 현재 떠오르는 패러다임은 블록 체인 (blockchain) 암호화에 의존하는 컴퓨팅의 연결 된 세계 일 수 있습니다. 연결된 세계는 웨어러블 컴퓨팅, IoT (Internet-of-Things) 센서, 스마트 폰, 태블릿, 랩톱, 수량화 된 자체 추적 장치를 포함하는 멀티 장치 컴퓨팅의 끊임없이 연결된 세상이되고있는 것에 대한 경제적 인 오버레이로서 블록 체인 기술을 유용하게 포함 할 수 있습니다 (즉, Fitbit), 스마트 홈, 스마트 카, 똑똑한 도시. 블록 체인이 가능하게하는 경제는 단순한 돈의 이동이 아닙니다. 이는 정보의 이전과 인간 및 기업 규모의 경제에서 돈이 가능하게 한 자원의 효과적인 배분입니다.[원문]With revolutionary potential equal to that of the Internet, blockchain technology could be deployed and adopted much more quickly than the Internet was, given the network effects of current widespread global Internet and cellular connectivity.[번역]  인터넷과 동등한 혁명적 인 잠재력을 지닌 블록 체인 기술은 현재 널리 보급 된 전세계 인터넷 및 셀룰러 연결의 네트워크 효과를 고려할 때 인터넷보다 훨씬 빠르게 배치되고 채택 될 수 있습니다.[원문]Just as the social-mobile functionality of Paradigm 4 has become an expected feature of technology properties, with mobile apps for everything and sociality as a website property (liking, commenting, friending, forum participation), so too could the blockchain of Paradigm 5 bring the pervasive expectation of value exchange functionality. Paradigm 5 functionality could be the experience of a continuously connected, seamless, physical-world, multidevice computing layer, with a blockchain technology overlay for payments—not just basic payments, but micropayments, decentralized exchange, token earning and spending, digital asset invocation and transfer, and smart contract issuance and execution—as the economic layer the Web never had. The world is already being prepared for more pervasive Internet-based money: Apple Pay (Apple’s token-based ewallet mobile app) and its competitors could be a critical intermediary step in moving to a full-fledged cryptocurrency world in which the blockchain becomes the seamless economic layer of the Web.[번역]  Paradigm 4의 소셜 - 모바일 기능이 기술 속성의 기대되는 기능이되고, 모든 것을위한 모바일 앱과 웹 사이트 속성 (좋아하는 것, 댓글 달기, friending, 포럼 참여)으로 된 것처럼, Paradigm 5의 블록 체인은 가치 교환 기능에 대한 전반적인 기대. Paradigm 5 기능은 지불에 대한 블록 체인 기술 오버레이 (기본 지불뿐 아니라 소액 결제, 분산 된 교환, 토큰 적립 및 지출, 디지털 자산 호출 및 기타 기능)을 통해 끊임없이 연결되고 끊김없는 물리적 세계 멀티 컴퓨터 컴퓨팅 계층의 경험 일 수 있습니다. 이전, 스마트 계약 체결 및 실행 - 웹에서 결코 볼 수 없었던 경제적 계층. Apple Pay (Apple의 토큰 기반 ewallet 모바일 앱) 및 그 경쟁자는 블록 체인이 완벽 해지는 본격적인 cryptocurrency 세계로 이동하는 중요한 중개 단계가 될 수 있습니다 경제 계층.",
        "url": "/blackruby-code//blockchain/2017/12/19/Blockchain.html"
      }
      ,
    
      "back-2017-12-17-python-travel7-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 데이터 지속성",
        "tags": "Python, Flask",
        "date": "December 17, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "데이터 지속성구조화된 파일데이터베이스 라이브러리파이썬 데이터베이스 API는 파이선에서 데이터베이스에 접근하는 표준 인터페이스를 정의한다. PEP 249에 문서화되어 있으며, 보다 자세한 내용은 파이썬 DB-API에 대한 소개 자료에 나와 있다.sqlite3SQLite는 sqlite3 뒤에서 데이터베이스를 제공하는 C 라이브러리이다. 단일 파일로 데이터베이스를 저장하며 컨벤션에 따라 *.db의 확장자를 가진다.SQLAlchemySQLAlchemy는 매우 인기 있는 데이터베이스 툴킷이다. Django는 자체 ORM에서 SQLAlchemy로 전환하는 옵션을 제공하며, 블로그 제작을 위한 Flask 메가 튜토리얼에서는 SQLAlchemy를 백엔드로 사용한다.Djagno ORMDjango ORM은 데이터베이스 접근을 위해 Django에서 사용하는 인터페이스이다. Django ORM의 액티브 레코드 패턴의 구현이 아마도 여기 소개되는 라이브러리 중 루비 온레일스의 ActiveRecord 라이브러리와 가장 흡사할 것이다.peeweepeewee는 SQL 문법을 알고 있는 상황에서 데이터베이스와 가볍게 상호작용하고 싶을 때 사용하면 좋다. 보는 그대로가 결과 그대로(What you see is what you get)즉 SQLAlchemy와 같이 테이블 구조를 추상화하는 최상위 레이어를 수동으로 작성할 필요가 없으며, Django ORM과 같이 라이브러리가 마법처럼 테이블 아래에 바탕 레이어를 만드는 일도 없다.PonyORMPonyORM은 쿼리 문법에 대해 다른 접근 방식을 취한다. SQL과 매우 유사한 언어나 불린 표현을 작성하는 대신, 파이썬의 제너레이터 구문을 사용한다. 맞춤형 PonyORM 엔티티를 생성할 수 있도록 돕는 그래픽 스키마 편집기도 있다.SQLObject2002년 10월에 공개된 SQLObject는 소개되는 ORM중 가장 오래되었다. 액티브 레코드 패턴을 구현하였으며, 구현했을 뿐아니라, SQLObject에는 SQL 로직을 파이썬에 추상화하는 방법으로 표준 연산자(==, &lt;, &lt;== 등)를 오버로드하는 새로운 아이디어도 적용되었다. 이 아이디어는 거의 모든 ORM 라이브러리에 구현되어 있으며, 매우 인기 있다.RecordsRecords는 다양한 데이터베이스에 원시(raw) SQL 쿼리를 보낼 수 있도록 설계된 최소한의 SQL 라이브러리이다. Tublib과 SQLAlchemy와 함께 설치되며, 근사한 API와 명령줄 도구가 제공되어 SQL 클라이언트와 같이 행동하며, YAML, XLS, 기타 Tablib 형식으로 결과를 출력할 수 있다.NoSQL 데이터베이스 라이브러리전통적인 관계형 데이터베이스가 아닌 데이터베이스, 즉 NoSQL데이터베이스를 사용하는 사람들도 있다. PyPI를 둘러보면, 비슷한 이름을 가진 파이썬 패키지가 수없이 많아 혼란스러울 수 있다. 원하는 데이터베이스 제품과 함께 사용하기 좋은 파이썬 라이브러리가 무엇인지 살펴보자.      MongoDB          몽고DB(MongoDB)는 분산 문서 저장소이다. 고유의 필터와 쿼리 언어가 있는, 클러스터에 서식하는 거대한 파이썬 딕셔너리를 상상하면 된다.            카산드라          카산드라는 분산 테이블 저장소이다. 빠른 검색을 제공하며 열의 개수가 많아져도 무리가 없다. 조인 기능을 제공하지 않는 대신 여러 테이블의 서로 다른 열을 하나의 테이블로 묶는 기능을 제공한다.            HBase          HBase는 분산 열 저장소이다. 이경우 열 저장소는 데이터가 (행 ID, 열 이름, 값)과 같이 저장되므로 웹을 구성하는 웹사이트간 네트워크 데이터와 같은 희소 배열 (sparse array) 형태의 데이터에 적합하다.            드루이드          드루이드는 분산 열저장소로서, 이벤트 데이터를 수집하는 데 사용할 수 있다. 드루이드는 열에 순서를 매기고 정렬할 수 있으며, 빠른 I/O를 가능하게 하고 작은 풋프린트를 가지도록 스토리지(storage)를 압축할 수 있다.            레디스          레디스는 분산 인메모리 키-값 저장소이다. 디스크 I/O가 없어 대기 시간이 줄어드는 게 핵심이다. 예를 들어 더 빠른 웹 조회를 위해 빈번한 쿼리 결과를 저장할 수도 있다.            카우치베이스          Couchbase는 보다 SQL스러운 API를 가지는 또 다른 분산 문서 저장소이다.            Neo4j          Neo4j는 그래프 형태의 관계로 객체를 저장하기 위한 그래프 데이터베이스이다.            LMDB          LMDB는 메모리에 매핑된 파일을 포함하는 키-값 저장소 데이터베이스이다. 즉, 파일이 처음부터 읽혀서 데이터가 있는 부분에 도달할 필요가 없으므로 인메모리 저장소와 거의 같은 성능이 나온다.      ",
        "url": "/blackruby-code//back/2017/12/17/Python_travel7.html"
      }
      ,
    
      "back-2017-12-17-python-travel6-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 데이터 작업",
        "tags": "Python, Flask",
        "date": "December 17, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "데이터 작업과학 애플리케이션파이썬은 주로 고성능 과학 애플리케이션에 사용된다. 작성하기 쉽고 잘 작동하기 때문에 학계와 과학 프로젝트에서 널리 사용된다. 파이썬에서 과학 컴퓨팅을 하기 위해서는 분야 특성상 성능이 중요하기 때문에 대개 연산 속도가 빠른 언어로 작성된 외부 라이브러리를 사용한다.IpythonIPython은 기존 파이썬 인터프리터의 강화판이다. 컬러 인터페이스 보다 상세한 오류 메시지, 인라인 모드를 지원하는데, 인라인 모드에서는 그래픽과 도표를 터미널에서 띄울 수 있다.NumPyNumPy는 Scipy 프로젝트의 일부지만, 별도의 라이브러로도 공개되었다. 따라서 NumPy의 기능만 필요한 경우에는 Scipy는 건너뛰고 NumPy만 설치해도 좋다. NumPy는 파이썬에서 느리게 작동하는 알고리즘 문제를 다차원 배열과 이들에 위한 함수로 말끔히 해결하였다. 따라서, 이런 알고리즘은 배열의 함수로 표현될 수 있고, NumPy는 이 알고리즘이 빠르게 돌아가도록 돕는다.ScipyScipy는 NumPy를 보다 수학적 함수로 사용하는 라이브러리이다. Scipy는 NumPy 배열을 기본 자료구조로 사용하며, 선형대수, 미적분, 특수 함수와 상수, 신호 처리와 같이 과학 프로그래밍에서 널리 이뤄지는 다양한 작업을 모듈로 담았다.MatplotlobMatplotlob은 대화형 2차원 혹은 3차원 플롯을 만들 수 있도록 돕는 융통성 있는 시각화 라이브러리이다. 만들어진 플롯은 고해상도의 그림으로 저장할 수 있다.PandasPandas는 NumPy를 기반으로 하는 데이터 작업 라이브러리이며, 데이터 접근, 인덱싱, 병합, 그룹화 작업이 수월해지도록 돕는 여러 유용한 함수를 제공한다.Scikit-LearnScikit-Learn은 차원 축고, 결측치 대치, 회귀와 분류 모델, 나무모델, 군집화, 모델 파라미터 자동 튜닝, 시각화와 같은 기능을 제공하는 기계학습 라이브러리이다.Rpy2Rpy2는 R 통계 패키지의 파이썬 바인딩 버전이며, R 함수를 파이썬에서 실행할 수 있게 돕는다.decimal, fractions, numbers파이썬은 추상 베이스 클래스의 프레임워크를 정의하여, 모든 수치 자료형의 뿌리인 Number에서 Integral, Rational, Real, Complex 까지 만들었다. numbers 라이브러리 문서의 지침에 따라 다른 수치 자료형을 만들어볼 수도 있다.SymPySymPy는 파이썬에서의 기호 수학을 위한 유일한 라이브러리이다. 전부 파이썬으로 작성되었으며, 속도, 시각화, 대화형 세션을 위한 선택 확장이 포함되어 있다.텍스트 작업과 텍스트 마이닝nltkNational Language ToolKit는 텍스트 분석을 위한 파이썬 도구이다. 스티븐 버드와 에드워드 로페가 2001년에 펜실베니아 대학의 자연어 처리 과정에서 학생들을 돕기 위해 발표한 패키지로, 여러 언어를 다루는 광범위한 라이브러리로 성장하였으며 최근에 연구된 알고리즘도 포함하고 있다.SyntaxNetTensorflow를 기반으로 구축된 구글의 SyntaxNet은 미리 학습된 영어 파서(parser)를 제공한다. 다른 파서를 학습할 수 있는 프레임워크도 제공하는데, 만약 레이블이 달린 데이터가 있다면 영어 이외의 데이터에 대해서도 적용할 수 있다.이미지 작업파이썬에서 가장 유명한 이미지 프로세싱 및 조작 라이브러리 세 가지는 Pillow, cv2 그리고 최신 라이브러리인 Sckit-Image이다. Pillow는 형식변환과 단순 이미지 프로세싱에 좋은 파이썬 이미징 라이브러리이다. cv2는 오픈 소스 컴퓨터 비전의 파이썬 바인딩으로, 실시간 얼굴 탐지와 기타 고급 알고리즘을 제공한다. Sckit-Image는 단순 이미지 프로세싱부터 얼룩(blob), 모양, 엣지 감지와 같은 기초 요소를 제공한다.PillowPIL는 이미지 조작을 위한 파이썬 핵심 라이브러리 중 하나이다. 2009년에 마지막으로 배포되었으며, 파이썬 3로 포팅되지 않았다.cv2오픈소스 컴퓨터 비전은 OpenCV란 이름으로 널리 알려져 있으며, PIL과 비교하여 고급 기법의 이미지 조작/프로세싱 기능이 포함된 소프트웨어다. C와 C++로 작성되었으며, 실시간 컴퓨터 비전에 중점을 두고 있다. 예를 들어, 실시간 얼굴 탐지 모델, 얼굴 인식 모델, 사람 탐지 모델 등이 있다.Scikit-Image위의 두가지 라이브러리보다 최신 라이브러리인 Sckit-Image는 파이썬 기반인 점과 훌륭한 문서 덕분에 꾸준히 인기가 증가하고 있다. cv2처럼 완전한 알고리즘을 가지고 있지는 않으나, 얼룩감지(blob detection), 피처 감지(feature detection)에 더하여 필터링이나 대비 조정(contrast adjustment)과 같은 표준 이미지 프로세싱 도구를 포함하고 있어 과학자에게 충분히 유용하다.",
        "url": "/blackruby-code//back/2017/12/17/Python_travel6.html"
      }
      ,
    
      "back-2017-12-17-python-travel5-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 소프트웨어 인터페이스, 분산 시스템, 암호",
        "tags": "Python, Flask",
        "date": "December 17, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "소프트웨어 인터페이스웹 클라이언트웹 API미국 인구 조사에서 네덜란드 국립 도서관에 이르기까지 거의 모든 웹사이트에서 API를 제공하며, 이를 통해 사용자가 데이터를 받거나 공유할 수 있도록 한다. 트위터나 페이스북과 같은 일부 서비스에서는 여러분(혹은 여러분이 사용하는 앱)이 데이터를 수정할 수 있도록 지원한다. RESTful API라는 용어를 들어본 적이 있을 것이다. RESTful API는 표준도, 프로토콜도, 요구사항도 아닌, HTTP 1.1이 어떻게 설계되었는지를 알려주는 패러다임이다. 그럼에도 불구하고 대부분의 웹 서비스 API 공급자는 RESTful 디자인 원칙을 따른다.JSON 파싱JSON은 말 그대로 자바스크립트에서 객체를 정의하는데 사용하는 표기법이다. Requests 라이브러리의 Response 객체에는 내장 JSON 파서가 있다. json 라이브러리는 JSON 형식의 문자열이나 파일을 파이썬 딕셔너리로 파싱한다. 역으로 파이썬 딕셔너리 혹은 리스트를 JSON 문자열로 바꿀 수도 있다.웹 스크래핑웹사이트의 데이터가 언제나 CSV나 JSON과 같은 편안한 형식으로 제공되지는 않는다. 그러나 HTML 역시 구조화된 데이터이기에 웹 스크래핑이 가능하다. 웹 스크래핑은 컴퓨터 프로그램을 사용해 웹페이지를 탐색하고 필요한 데이터를 가장 유용한 형식에 맞춰 수집하고, 그러한 데이터 구조를 보존하는 작업을 일컫는다.lxmllxml은 XML과 HTML 문서를 매우 빠르게 파싱하기 위해 만들어진 다기능 라이브러리로 올바르지 않은 형식의 마크업까지도 일부 처리할 수 있다.데이터 직렬화데이터 직렬화란 구조화된 데이터를 공유하거나 저장할 수 있는 형식으로 변환하는 개념이며, 데이터 객체를 재구축하는 데 필요한 정보를 전송의 수신단 메모리에 보존한다. 경우에 따라 직렬화된 데이터의 크기를 최소화하여 디스크 필요 공간 혹은 대역폭 요구 정도를 최소화하는 것이 목적이 되기도 한다.피클파이썬 기본 데이터 직렬화 모듈은 피클이라 불린다.언어 간 직렬화만약 여러 언어를 지원하는 직렬화 모듈을 찾고 있따면, 인기 있는 두 가지 선택지로 구글의 프로토버프와 아파치의 에이브로가 있다.버퍼 프로토콜파이썬 핵심 개발자 중 한 명인 엘리 벤데르스키는 ‘메모리 버퍼를 사용해 파이썬이 만드는 동일 데이터에 대한 인메모리 복사본 개수를 줄이는 방법’을 다루는 글을 작성해 블로그에 올렸다. 그의 기법에 따르면, 파일이나 소켓을 기존의 버퍼로 불러올 수 있다.분산 시스템네트워킹파이썬에서는 전역 인터프리터 잠금(Global Interpreter Lock, GIL)의 단일 스레드 한계를 극복하기 위해, 주로 비동기 도구나 스레드를 사용해 연결 네트워크용 통신을 처리한다.파이썬 표준 라이브러리의 성능 네트워킹 도구asyncioasyncio는 파이썬 3.4에서 소개되었으며, Twisted와 gevent를 유지 보수하는 개발자 커뮤니티로부터 배운 아이디어가 녹아 있다. 동시성 도구이며, 주로 네트워크 서버에 사용한다.geventgevent는 코루틴 기반의 파이썬 네트워킹 라이브러리이며, 그린릿을 사용하여 C 라이브러리 이벤트 루프 위에 하이레벨의 동기식 API를 제공한다.TwistedTwisted는 이벤트 기반 네트워킹 엔진이다. HTTP와 서버 및 클라이언트를 포함한 각종 네트워킹 프로토콜, SMTP, POP3, IMAP같은 이메일 프로토콜, SSH, 인스턴스 메시징을 사용한 다양한 애플리케이션을 만들 수 있다.PyZMQPyZMQ는 ZeroMQ를 위한 파이썬 바인딩이다.RabbitMQRabbitMQ는 AMQP(Advanced Message Queing Protocol)을 구현한 오픈 소스 메시지 브로커 소프트웨어다. 메시지 브로커는 중간 프로그램으로, 프로토콜에 따라 발신자로부터 메시지를 전달 받아 수신자에게 전송한다.pikapika는 RabbitMQ가 선호하는, 경량의 순수 파이썬 AMQP 0-9-1 클라이언트이다. RabbitMQ의 파이썬 입문 튜토리얼에서 pika를 사용한다.CeleryCelery는 기능이 한층 더 많은 AMQP 클라이언트이다. RabbitMQ나 레디스(Redis, 분산 인메모리 데이터 저장소)를 메시지 브로커로 사용할 수 있으며, 작업과 결과를 추적할 수 있고, 웹 관리자 도구이자 작업 모니터링 도구인 Flower가 포함되어 있다.암호2013년에 PyCA가 구성되었다. 이들은 파이썬 커뮤니티에 고품질의 암호 라이브러리를 제공하는 데 관심이 있는 개발자 모임이다. 이들은 적절한 키가 주어졌을 때 메시지를 암호화하거나 해독하는 도구를 제공하고, 암호나 기타 비밀 데이터를 비가역 방향으로 난독화하는 암호화 해시 함수를 제공한다.ssl, hashlib, secrets      ssl          파이썬 표준 라이브러리의 ssl 모듈은 표준 소켓처럼 행동하는 소켓 API를 제공한다. 그러나 이 API는 SSL 프로토콜, 그리고 SSL 연결 구성을 포함하는 ssl.SSLContext에 의해 래핑된다.            hashlib          파이썬의 hashlib 모듈은 보안 저장소를 위한 해시 암호를 생성하는 데 사용할 수 있다. 전송 도중 데이터 무결성을 확인하기 위한 체크섬을 생성하는 데 사용할 수도 있다.            secrets          secrets 라이브러리는 PEP 506에서 제안되어 파이썬 3.6에서 도입되었다. 보안 토큰을 생성하기 위한 함수를 제공하며, 암호 초기화와 추측하기 어려운 URL 생성과 같은 분야에 적합하다.      pyOpenSSLCryptography 라이브러리가 공개되었을 때, pyOpenSSL은 OpenSSL 라이브러리를 위한 Cryptography의 CFFI 기반 바인딩을 사용하도록 업데이트되었고, PyCA의 우산 안에 합류하였다. pyOpenSSL은 파이선 표준 라이브러리와는 별도로 존재하므로, 보안 커뮤니티의 속도에 맞춰 업데이트를 배포할 수 있다.PyNaCl과 libnaclPyNaCl과 libnacl의 C 라이브러리 백엔드인 libsodium의 아이디어는 의도적으로 사용자에게 다양한 선택을 제공하지 않고, 상황별 최적 선택만 제공하는 것이다. 모든 TLS 프로토콜을 지원하지는 않으니, TLS 프로토콜이 필요하다면 pyOpenSSL을 사용하자. 직접 관리하는 다른 컴퓨터와의 암호화된 연결이 필요하고, 여기에 원하는 프로토콜을 사용하고 싶다면 libsodium을 사용하자.CryptographyCryptography는 암호화 레시피와 기본 요소를 제공한다. 파이썬 2.6에서 2.7까지, 그리고 파이썬 3.3 이상, PyPy를 지원한다. Cryptography는 레시피와 hazmat의 두 레이어로 나뉜다. 레시피 레이어는 적절한 대칭 암호화를 위한 간단한 API문서를 제공하며, hazmat 레이어는 로우 레벨의 암호화 기본 요소를 제공한다.PyCryptoPyCrypto는 안전한 해시 함수와 다양한 암호화 알고리즘을 제공한다. 파이썬 2.1 이상의 버전과 파이썬 3을 지원한다.bcrypt암호에 bcrypt 알고리즘을 사용하고 싶다면 이 라이브러리를 사용하자. py-bcrypt와 호환되기 때문에 py-bcrypt를 사용하던 사람이 옮겨오기 좋다.",
        "url": "/blackruby-code//back/2017/12/17/Python_travel5.html"
      }
      ,
    
      "back-2017-12-17-python-travel4-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 코드 관리와 개선, 속도, GPU 라이브러리",
        "tags": "Python, Flask",
        "date": "December 17, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "코드 관리와 개선시스템 관리서버 자동화, 시스템 모니터링, 워크플로 관리 등 시스템을 관리하고 모니터링하기 위한 도구를 소개한다.트래비스-CL트래비스-CL은 오픈 소스 프로젝트를 무료로 테스트 할 수 있는 분산 CI 서버이다. 파이썬 테스트를 실행하고 깃허브와 완벽히 통합되는 여러 작업자를 제공한다. 심지어 변경사항 모음이 빌드를 손상시키는지에 대해 풀리퀘스트에 주석을 달 수도 있다.젠킨스젠킨스는 확장 가능한 지속적 통합 엔진이며, 현재 가장 대중적인 CI 엔진이다. 윈도우, 리눅스, 맥에서 동작하며, ‘현존하는 모든 소스 코드 관리 도구’에 연결할 수 있다.빌드봇빌드봇은 코드 변화를 검증하는 컴파일/테스트 반복 작업을 자동화하기 위한 파이썬 시스템이다. 젠킨스와 마찬가지로 소스 코드 관리자를 폴링하여, 지침에 따라 여러 컴퓨터에서 코드를 빌드하고 테스트한 다음 작업 내용을 알려준다.서버 자동화솔트(Salt), 앤시블(Ansible), 퍼핏(Puppet), 셰프(Chef), CF엔진(CFEngine)은 서버 자동화 도구이며, 시스템 관리자가 수많은 실제 혹은 가상 시스템을 관리할 수 있는 우아한 방법을 제공한다.솔트솔트는 마스터 노드를 마스터라고 부르고, 에이전트 노드를 미니언혹은 미니언 호스트라고 부른다. 주 설계 목표는 속도이다. 네트워킹은 ZeroMQ 메시지 라이브러리를 기반으로 마스터와 미니언간 TCP연결을 사용해 수행한다.앤시블다른 자동화 도구에 비해 앤시블이 가지는 가장 큰 장점은 클라이언트 시스템에 파이썬만 설치되어 있어도 충분하다는 사실이다. 다른 옵션은 모두 클라이언트에 데몬이 실행되도록 하여 마스터를 폴링하며, YAML 형식의 구성 파일을 사용한다. 앤시블은 구성, 배포, 오케스트레이션 문서로서 플레이북을 사용한다. 플레이북은 YAML로 작성되며, 템플릿 생성을 위해 Jinja2를 사용한다.퍼핏퍼핏은 루비로 작성되었으며, 구성을 위해 퍼핏 스크립트라는 자체 언어를 제공한다. 에이전트 노드의 오케스트레이션을 담당하는 퍼핏 마스터라는 서버를 가진다. 모듈은 작고 공유할 수 있는 코드 유닛이며, 시스템 상태를 자동화하거나 정의하기 위해 작성된다.셰프인프라구조 코드 작성 언어로 루비를 사용하는 경우 대체로 구성 관리에 셰프를 사용한다. Chef는 Puppet과 비슷하지만, 반대의 철학을 가지고 설계되었다. Puppet은 유연성을 포기하는 대신 모든 것을 단순화하는 프레임워크를 제공하지만, Chef는 프레임워크를 거의 제공하지 않는다. 따라서 Chef는 확장이 수월한 도구이지만 그만큼 사용하기 어렵다.CFEngineCFEngine은 C로 작성되었기에 매우 작은 풋프린트를 가진다. 주요 설계 목표인 오류에 대한 견고함을 달성하기 위해, 분산 네트워크에서 작동하는 자율 에이전트를 사용한다.속도다음은 속도를 위한 옵션들이다!스레딩파이썬의 threading 라이브러리를 사용하면 여러 스레드를 생성할 수 있다. 전역 인터프리터 잠금(GIL) 때문에 하나의 파이썬 인터프리터는 하나의 파이썬 프로세스만 실행한다. 따라서 하나 이상의 스레드가 블로킹되는 경우에만 성능 향상이 가능하다.멀티프로세싱파이썬 표준 라이브러리의 multiprocessing 모듈은 추가 파이썬 인터프리터를 샐행하여 GIL을 우회하는 방법을 제공한다.subprocesssubprocess 라이브러리는 파이썬 2.4부터 표준 라이브러리에 표준으로 포함되었으며, PEP324에 정의되어 있다.파이파이파이파이는 파이썬으로 구현한 파이선 구현체다. 무료인데다 빠르고, 문제가 없다면 기존 코드를 변경해줄 필요가 없다. 가장 먼저 시도해봐야 할 옵션이다.싸이썬불행히도 C 확장을 사용한 모든 라이브러리가 파이파이에서 작동하지 않는다. 이러한 경우를 위해 파이썬을 포함하여 C와 C++ 모듈까지 작성할 수 있도록 돕는 싸이썬이 있다. Cython은 컴파일된 C 라이브러리에서 함수를 호출할 수 있으며, 어떤 방식으로든 파이썬 객체를 조작하지 않는다는 전제하에 특정 코드 부분 근방에서 GIL을 해제할 수 있도록 하는 컨텍스트를 제공한다.NumbaNumba는 특수 데코레이터를 통해 주석이 달린 파이썬 코드를 LLVM으로 컴파일하는 Numpy 중심의 파이썬 컴파일러이다. Numba는 LLVM을 사용해 파이썬 코드를 런타임에 실행할 수 있는 기계코드로 컴파일한다.GPU 라이브러리CFFICFFI는 C파이썬과 파이파이 모두에서 C와 인터페이스하는 간단한 매커니즘을 제공한다. C파이썬과 파이파이 간 호환성이 가장 좋기 때문에 파이파이에서 추천되는 패키지이다.ctypesctypes는 C파이썬에서 C/C++과 인터페이스하는 데 있어 표준이 되는 라이브러리이다. 실제로 표준 라이브러리에 포함되어 있다.F2PYF2PY는 파이썬에서 포트란을 가져다 쓰는 인터페이스를 만들어주는 도구이다. Numpy에 포함되어 있으므로 Numpy를 설치하여 사용할 수 있다.SWIGSWIG는 파이썬을 포함한 매우 다양한 스크립트 언어를 지원한다. 인기 있고 널리  사용된느 명령줄 도구이며, C/C++ 헤더 파일을 원하는 언어에서 사용할 수 있도록 바인딩을 만들어준다.Boost.PythonBoost.Python으로 C++ 객체 기능을 노출시키려면 비교적 많은 수작업이 필요하다. 그러나 Boost.Python은 SWGI가 제공하는 기능을 모두 제공한다. 예를 들어, C++ 객체를 파이썬에 노출하는 도구뿐만 아니라 파이썬 객체에 C++에 PyObject 형태로 노출시키는 래퍼도 있다.",
        "url": "/blackruby-code//back/2017/12/17/Python_travel4.html"
      }
      ,
    
      "back-2017-12-17-python-travel3-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 웹 애플리케이션, 웹 배포, 웹 서버",
        "tags": "Python, Flask",
        "date": "December 17, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "웹 애플리케이션파이썬은 빠른 프로토타이핑과 큰 프로젝트에 모두 적용되는 강력한 스크립팅 언어로써, 웹 애플리케이션 개발에 널리 사용된다.웹 프레임워크/마이크로프레임워크일반적으로 웹 프레임워크는 웹 애플리케이션 구현에 사용되는 라이브러리와 기본 핸들러 모음으로 구성된다. 대부분의 웹 프레임워크는 적어도 아래 나열된 내용을 수행하기 위한 패턴과 유틸리티를 포함한다.      URL 라우팅          들어오는 HTTP 요청과 특정 파이썬 함수를 매칭한다.            요청/응답 객체 처리          사용자의 브라우저에서 수신하거나 송신한 정보를 캡슐화한다.            템플릿          파이썬 변수를 HTML 템플릿이나 기타 풀력에 삽입한다. 따라서 프로그래머가 레이아웃과 애플리케이션 로직을 구분할 수 있도록 돕는다.            디버깅용 웹서비스 개발          작업 중인 머신에 소형 HTTP 서버를 실행해 빠르게 개발할 수 있다. 파일이 업데이트되면 서버 측 코드를 자동으로 재로딩한다.      다음은 웹프레임워크에 대해서 다룬다.장고장고는 건전지가 포함된 웹 애플리케이션 프레임워크이며, 콘텐츠를 담는 웹사이트 제작에 적당한 훌륭한 선택지이다. 수많은 유틸리티와 패턴을 즉시 사용할 수 있어 복잡한 데이터베이스 기반 웹 애플리케이션을 빠르게 구축할 수 있으며 가독성 높은 코드 작성이 가능해진다.플라스크플라스크는 파이썬을 위한 마이크로프레임워크이며, 작은 애플리케이션, API, 웹 서비스를 구축할 때 훌륭한 선택지이다. 사용자가 원하는 대부분의 기능을 모두 제공하는 대신, URL 라우팅, HTTP 요청/응답 객체, 템플릿과 같이 웹 애플리케이션 프레임워크에서 주로 사용되는 핵심 구성 요소만 구현하였다. 플라스크를 사용한 앱 개발은 표준 파이썬 모듈을 작성하는것돠 같다.  플라스크를 사용할 때 애플리케이션의 기타 구성 요소는 사용자가 스스로 선택한다. 예를 들어, 데이터베이스 접근, 양식, 생성/유효성 검증은 플라스크에 내장되어 있지 않다. 많은 웹 애플리케이션이 이러한 기능을 필요로 하지 않으므로 이는 훌륭한 점이다.토네이도토네이도는 파이썬을 위한 비동기 웹프레임워크이며, 자체 이벤트 루프를 가진다. 이를 통해 웹 소켓 통신 프로토콜을 네이티브하게 지원할 수 있다. 토네이도는 다른 프레임워크와 달리 WSGI 애플리케이션이 아니다.피라미드피라미드는 모듈성에 중점을 둔다는 점을 제외하면 장고와 매우 비슷하다. 더 적은 수의 내장 라이브러리가 포함되어 있으며, 스캐폴드라고 불리는 공유 가능한 템플릿을 통해 기본 기능을 확장하길 권장한다.웹 템플릿 엔진대부분의 WSGI 애플리케이션은 HTTP 요청에 응답하고 HTTP이나 마크업 언어로 콘텐츨르 제공한다. 템플릿 엔진은 콘텐츠를 렌더링하는 데 사용된다. 불필요한 반복을 피하기 위해 계층/포함 체계를 사용해 템플릿 파일 모음을 관리하며, 템플릿의 정적 콘텐츠를 애플리케이션이 생성하는 동적 콘텐츠로 채운다.Jinja2새로운 파이썬 웹 애플리케이션에 적용할 템플릿 라이브러리로 Jinja2를 추천한다. Flask의 기본 엔진이며, 파이썬 문서를 만드는 도구인 스핑크스의 기본 엔진이기도 하다. 장고, 피라미드, 토네이도에 사용할 수도 있다. 텍스트 기반 템플릿 언어로 사용 할 수 있으므로 HTML 뿐만 아니라 마크업 언어를 생성하는 데 사용할 수도 있다.ChameleonChameleon은 HTML/XML 템플릿 엔진이며, Template Attribute Language, Expression Syntax, Macro Expansion TAL 구문을 사용해 구현되었다. Chameleon은 페이지 템플릿을 파싱하여 파이썬 바이트코드로 ‘컴파일’하여 로딩 속도를 높인다. 또한 피라미드에 사용된 기본 렌더링 엔진 중 하나다.MakoMako는 성능을 최대화하기 위해 파이썬으로 컴파일하는 템플릿 언어이며, Django와 Jinja2와 같은 다른 템플릿 언어에서 좋은 구문과 API를 가져왔다. 피라미드 웹 프레임워크의 기본 템플릿 언어이다.  다음은 Mako의 템플릿 예이다.&lt;%inherit file=\"base.html\"/&gt;&lt;%    rows = [[v for v in range(0,10)] for row in range(0,10)]%&gt;&lt;table&gt;    % for row in rows:        ${makerow(row)}    % endfor&lt;/table&gt;&lt;%def name=\"makerow(row)\"&gt;    &lt;tr&gt;    % for name in row:        &lt;td&gt;${name}&lt;/td&gt;\\    % endfor    &lt;/tr&gt;&lt;/%def&gt;  Jinja2와 같이 텍스트 마크업 언어이며, XML/HTML 문서 이외에도 사용될 수 있다.웹 배포호스팅PaaS는 인프라 구조, 라우팅, 웹 애플리케이션 규모를 추상화하고 관리하는 클라우드 컴퓨팅 인프라의 일종이다. PaaS를 사용하는 개발자는 배포에 관한 사항이 아닌 애플리케이션 코드 작성에 집중 할 수 있게 된다.헤로쿠헤로쿠는 파이썬 웹 애플리케이션 배포에 추천하는 PaaS이다. 파이썬 2.7에서 3.5까지의 모든 애플리케이션을 지원한다. 헤로쿠 계정과 실제 데이터베이스/웹 서버 사이의 인터페이스를 위한 명령줄 도구 모음이 제공되므로, 웹 인터페이스를 사용하지 않고도 변경이 가능하다. 헤로쿠는 웹 개발자가 처음 애플리케이션을 개발할 때 필요한 단계별 지침뿐만 아니라, 파이썬을 헤로쿠와 함께 사용할 때 필요한 내용을 담은 글을 제공한다.엘더리온엘더리온은 Kubernetes, CoreOS, Docker를 기반으로 하는 PaaS이며, WSGI 애플리케이션을 지원한다.웹 서버Tornado를 제외한 모든 웹 애플리케이션 프레임워크는 WSGI 애플리케이션이다. 즉, HTTP요청을 받고 HTTP 응답을 보내기 위해 PEP 3333에 정의된 WSGI 서버와 상호작용을 해야한다.엔진엑스엔진엑스는 HTTP, SMTP와 같은 프로토콜용 웹 서버이자 역방향 프락시이다. 높은 성능, 상대적인 단순함, 여러 애플리케이션 서버와의 호환성으로 잘 알려져 있으며, 로드 밸런싱, 기본 인증, 스트리밍과 같이 편리한 기능이 포함되어 있다.아파치 HTTP 서버아파치는 세계에서 가장 유명한 HTTP 서버 이지만, 파이썬 커뮤니티는 엔진엑스를 선호한다.WSGI 서버독립형 WSGI 서버는 일반적으로 기존 웹 서버보다 적은 자원을 사용하고, 파이썬 WSGI 서버에 대한 벤치마크 실험에서 최고의 성능을 보여주었다. 이들은 엔진엔스나 아파치와 함께 역방향 프락시로 사용될 수 있다.다음은 가장 많이 사용되는 WSGI 서버이다      G유니콘          G유니콘은 새로운 파이썬 웹 애플리케이션에 권장되는 선택지로, 파이썬 애플리케이션을 제공하는 데 사용되는 순수 파이썬 WSGI 서버이다. 다른 파이썬 웹 서버와 달리, 사려 깊은 사용자 인터페이스가 있어 사용 및 구성이 매우 쉽다.            웨이트리스          웨이트리스는 ‘아주 납득되는 성능’을 주장하는 순수 파이썬 WSGI 서버이다. 문서가 자세하지 않지만, G유니콘에는 없는 몇가지 좋은 기능을 제공한다. 그중 하나는 HTTP 요청 버퍼링인데, “Wait”-ress(기다림 없음)이라는 이름 그대로 느린 클라이언트가 응답하는 데 시간이 소요되더라도 차단하지 않는다.            uWSGI          uWSGI는 호스팅 서비스 구축에 사용되는 풀스택 서버다. 필요한 이유가 없다면 독립형 웹 라우터로 사용하지 않는게 좋다. uWSGI는 완전한 웹 서버 뒤에서 실행할 수 있다. 웹 서버는 uWSGI 프로토콜을 통해 uWSGI와 애플리케이션 작업을 구성할 수 있다.      ",
        "url": "/blackruby-code//back/2017/12/17/Python_travel3.html"
      }
      ,
    
      "back-2017-12-17-python-travel2-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 훌륭한 코드 배포하기, 사용자와 상호작용",
        "tags": "Python, Flask",
        "date": "December 17, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "훌륭한 코드 배포하기유용한 단어와 콘셉트      의존성          일부 프로젝트에서는 파이썬 라이브러리 외의 의존성이 있을 수 있다. Postgres 데이터베이스, C 컴파일러, C 라이브러리 공유 객체 등을 예로 들 수 있다. 이러한 의존성이 별도로 명시되어 있지 않을 수도 있으나, 이들이 없는 경우 빌드가 불가능하다.            내장 배포          내장 배포는 파이썬 패키지의 배포 형식이다(다른 리소스와 메타 데이터를 포함할 수 있다) 별도의 컴파일 없이 설치하고 실행할 수 있다.            에그          에그(egg)는 내장 배포의 한 형식으로, 설치에 사용되는 메타 데이터가 담긴 특수한 구조의 ZIP 파일이다. Setuptools 라이브러리에 의해 소개된 이래로 수년간 사실상 표준이었으나, 공식 파이썬 패키징 형식은 아니었다.            휠          휠(wheel)은 내장 배포의 한 형식으로, 내장 파이썬 라이브러리를 배포하기 위한 표준이다. ZIP 파일 형식으로 패키징되며, pip가 패키지를 설치/제거하는 데 사용할 메타 데이터가 포함되어 있다.      코드 패키징패키징이란 코드를 배포하기 위한 필수 파일 구조를 만들어서 여기에 필요한 파일을 추가하고 적절한 변수를 정의하는 작업이다.Conda아나콘다 파이썬 재배포판을 설치했다면 conda가 기본 패키지 관리자이고, 기본 패키지 저장소가 http://anaconda.org/로 설정되어 있을 것이다.PyPI파이썬의 패키지 생태계는 PyPI, pip와 같은 도구를 통해 잘 정립되어 있다. 따라서 가벼운 실험을 하든 커다란 전문가 시스템을 구성하든 이에 필요한 패키지를 다운 받아 설치하는 작업은 쉽다.오픈소스 파이썬 모듈을 작성하고 있다면, 이를 PyPI에 호스팅 해야 한다. ( PyPi는 치즈샵이라고도 많이 알려져 있다. )샘플 프로젝트PyPA의 샘플프로젝트는 파이썬 프로젝트 패키징에 대한 모범 사례를 보여 준다. setup.py 모듈의 주석에는 옵션에 대한 조언이 담겨 있으며, 관련 PEP 문서가 소개되어 있다.easy_install이 아닌 pip를 사용하자2011년 부터 PyPA는 파이썬 라이브러리의 배포, 패키징, 설치 표준의 부재로 인해 생겨난 무수한 혼란과 논의를 해결하기 위해 노력해왔다. 그 결과 PEP453에서 파이썬의 기본 패키지 인스톨러로 pip가 채택되었으며 파이썬 3.4와 그 이후 배포판에 포함되어 있다.개인용 PyPIPyPI 이외의 소스 로부터 패키지를 설치한다면, 설치할 패키지를 포함하는 디렉터리에서 간단히 HTTP 서버를 호스팅하여 해결할 수 있다.PypiserverPypiserver는 미니멀한 PyPI 호환 서버이며, easy_install 혹은 pip를 위해 일련의 패키지를 제공하는 데 사용할 수 있다.s3-hosted PyPI개인용 PyPI 서버를 위한 또 다른 선택지로는 아마존의 S3에 호스팅하는 방법이 있다. 먼저 S3 버킷과 함께 아마존 웹 서비스 계정이 있어야 한다.pip를 위한 VCS(버전 관리 시스템)지원pip를 사용하여 버전 관리 시스템에서 코드를 직접 가져올 수도 있다.코드 동결하기코드 동결이란 파이썬을 설치하지 않은 최종 사용자도 애플리케이션을 사용할 수 있도록 독립적으로 실행 가능한 번들을 만드는 것을 의미한다.배포 파일이나 번들은 애플리케이션 코드와 파이썬 인터프리터를 모두 담고 있다.PyinstallerPyinstaller는 맥, 윈도우, 리눅슬르 위한 애플리케이션을 만드는 데 사용된다. Pyinstaller의 주목적은 서드파티 패키지와 호환이 되도록 만드는 것이다. 지원하는 그래픽 라이브러리는 Pillow, pygame, PyOpenGL, PyGTK, PyQT4, PyQT5, PySide, wxPython이다.cx_Freezecx_Freeze 또한 Pyinstaller처럼 리눅스, 맥, 윈도우 시스템에서 파이썬 프로젝트를 동결할 수 있다. 그러나 cx_Freeze팀에서는 Wine을 사용하여 윈도우용으로 컴파일하는 것을 권장하지 않는다. 애플리케이션이 작동할 수 있도록 수동으로 복사해야 하는 파일이 있기 때문이다.py2apppy2app은 맥을 위한 실행 파일을 빌드한다. cx_Freeze와 마찬가지로 distutils를 확장하였으며, py2app이라는 새 명령어를 추가하였다.py2exepy2exe는 윈도우를 위한 실행 파일을 빌드한다. 매우 인기 있는 윈도우용 비트토렌트가 py2exe를 사용해 만든 대표적인 애플리케이션이다.bbfreezebbfreeze는 현재 유지 보수가 중단되었고, 파이썬 3로 포딩되지 않았음에도 많이 사용되고 있다. cx_Freeze, py2app, py2exe와 마찬가지로 distutils를 확장하여 bbfreeze 명령어를 추가하였다.리눅스 내장 배포를 위한 패키징리눅스에서 파이썬 코드를 배포하는 ‘올바른 방법’은 리눅스 내장 배포(built distribution)을 만드는 것이다. 내장 배포는 프리징된 패키지와 같으나, 파이썬 인터프리터가 포함되어 있지 않아 코드 동결 대비 2MB 가량 용량이 적다.사용자와 상호작용Jupyter NotebookJupyter는 파이썬 코드를 화면에 대화식으로 띄우고 실행할 수 있도록 돕는 웹 애플리케이션이다. Jupyter는 사용자 간 인터페이스이다!사용자는 웹 브라우저에서 Jupyter의 클라이언트 인터페이스를 보게 된다. 이 인터페이스는 CSS, HTML, 자바스크립트로 작성되었다. 클라이언트 시스템은 파이썬으로 작성된 커널과 통신한다. 이 커널은 코드 블록을 실행하여 그 결과를 클라이언트로 보내는 역할을 한다. 코드와 그 실행 결과는 ‘노트북’형식으로 서버에 저장된다. ‘노트북’ 형식은 여러 개의 ‘셀(cell)’로 구성된 텍스트 JSON 파일로, 각각의 ‘셀’은 HTML, 마크다운, 간단한 텍스트 노트 또는 실행 가능한 코드를 포함한다.  최근 연구에 따르면 교실에서 Jupyter를 사용하면 대화형 인터페이스 덕분에 코딩에 익숙하지 않은 학생들이 코딩을 효과적으로 쉽게 배울 수 있다고 한다.명령줄 애플리케이션명령줄 애플리케이션은 텍스트 인터페이스에서 사용하도록 설계된 컴퓨터 프로그램으로, 셸이 그 예이다. 명령줄 애플리케이션은 pep8이나 virtualenv처럼 간단한 명령어 모음일 수도 있고, python 인터프리터나 ipython과 같은 대화형 프로그램일 수도 있다.argparseargparse는 명령줄 옵션을 파실할 수 있도록 돕는 파이썬 표준 라이브러리이다. HowDoI 프로젝트의 명령줄 인터페이스는 argparse를 사용해 만들어졌으니, 명령줄 인터페이스를 만들 때 HowDoI의 인터페이스를 참고해도 좋다.docoptdocopt의 핵심 철학은 문서는 아름답고 이해하기 쉬워야 한다는 것이다. 이 라이브러리는 하나의 주 명령 docopt.docopt()을 제공한다. 이에 더하여 고급 사용자가 유용하고 편리하게 쓸 몇 가지 함수와 클래스를 제공한다.PlacPlac의 철학은 명령줄을 파싱하는 데 필요한 모든 정보는 대상 함수의 시그니처에 있다는 것이다. Plac은 파이썬 표준 라이브러리의 argparse를 래핑하는 200줄 정도의 가벼운 코드로, 단일함수 plac.plac()을 제공한다.ClickClick의 주된 용도는 개발자가 가능한 한 적은 코드로 구성할 수 있는 명령줄 인터페이스를 만들 수 있도록 돕는 것이다. Click의 기본 설정은 대부분 개발자의 요구를 충족시키지만, 고급 사용자를 위한 설정도 충분히 가능하다. Click은 Plac과 마찬가지로 데코레이터를 통해 파서 정의와 함수를 연결하며, 명령줄 인자 관리를 함수 외부에서 할 수 있도록 한다.ClintClint 라이브러리는 명령줄 인터페이스 도구 모음이다. Clint는 명령줄 인터페이스의 색상과 들여쓰기 설정, 간단하고 강력한 표 형식 출력 도구, 이터레이터 기반의 진행 표시줄, 함축적인 인자 관리 기능을 지원한다.GUI 애플리케이션위젯 라이브러리GUI 개발 관점에서 보았을 때, 버튼, 슬라이더, 스크롤바 같이 자주 사용되는 UI제어 및 디스플레이 요소를 통칭하여 위젯이라 한다. 위젯 라이브러리를 사용한다면 로우레벨 코딩이나 작업에 대한 걱정이 없어진다.TK파이썬 표준 라이브러리의 Tkinter 모듈은 TK에 의존하는 객체지향 레이어다. TK는 Td ㅇ너어로 작성한 위젯 라이브러리이며, 보통 이 둘을 묶어 Tcl/Tk라 부른다. Tkinter는 표준 라이브러리에 포함되어 있으므로 GUI 툴킷 중 가장 간편하고 호환성이 좋다.KivyKivy는 멀티터치를 지원하는 미디어가 풍부한 애플리케이션을 개발하는 데 사용할 수 있는 파이썬 라이브러리이다. Kivy는 커뮤니티에서 활발하게 개발되고 있으며, BSD와 비슷하면서 관대한 라이선스를 가진다. 모든 주요 플랫폼(리눅스, 맥, 윈도우, 안드로이드)에서 작동한다.QtQt(‘큐트’라고 발음)는 GUI를 가지는 소프트웨어를 개발하는 데 널리 사용되는 크로스 플랫폼 애플리케이션 프레임워크이며, GUI가 없는 애플리케이션을 개발할 때 사용할 수도 있다.GTK+GTK+ 툴킷은 GNOME 데스크톱 환경의 백보을 위한 API를 제공한다. C를 선호하며 GTK+의 소스 코드를 보는게 편안한 프로그래머, GNOME 애플리케이션을 작성해 왔거나 해당 API에 친숙한 프로그래머라면 필요에 따라 Qt 대신 GTK+를 선택할 수 있다.wxWidgetswxWidgets의 디자인 철학은, 애플리케이션이 고유의 모양과 느낌을 가지려면, 운영체제별로 고유의 API를 사용하는 게 최선이라는 입장이다. Qt와 GTK+는 x11 대신 다른 창 생성 라이브러리를 사용할 수 있지만, Qt는 라이브러리를 추상화하고 GTK는 사용자가 GNOME을 프로그래밍하는 것 처럼 만든다. wxWidgets는 각 플랫폼과 직접 인터페이스 할 수 있는 게 장점이며, 라이선스가 훨씬 관대하다. 그러나 플랫폼마다 약간씩 다르게 처리해야 한다는게 단점이다.오브젝티브 - C오브젝티브-C는 맥과 IOS 운영체제를 위해 애플이 사용하는 독점 언어이며, 이를 통해 맥에서의 애플리케이션 개발에 사용하는 코코아 프레임워크에 접근 할 수 있다. 다른 도구와 달리, 오브젝티브-C는 크로스 플랫폼이 아니며, 애플 제품만을 위한 도구이다.",
        "url": "/blackruby-code//back/2017/12/17/Python_travel2.html"
      }
      ,
    
      "back-2017-12-16-python-travel1-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 훌륭한 코드 작성하기, 훌륭한 코드 읽어보기",
        "tags": "Python, Flask",
        "date": "December 16, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "실전 돌입하기훌륭한 코드 작성하기코드 스타일      PEP8          PEP8은 파이썬을 위한 코드 스타일 가이드이며 작명 컨벤션, 코드 레이아웃, 공백, 그 외 유사 스타일 주제를 다룬다. 대체로 파이썬 코드를 작성할 때는 PEP8을 준수하는 것이 좋다. 코드 스타일이 통일되면 한 프로젝트 안에서 여러 개발자가 코드의 일관성을 유지하며 개발할 수 있는 밑거름이 된다.            PEP 20(파이썬 계명)          PEP20은 파이썬 코드를 작성할 때 겪는 의사 결정에 도움을 주는 원리 모음이다. 파이썬 셸에서 import this를 입력하면 전문을 볼 수 있다. 이름과는 달리 20개가 아닌 19개의 경구만 포함되어 있다(마지막 경구는 아직 작성되지 않았다)            일반적인 조언                  파이썬 스타일 철학                              “명시가 암시보다 좋다”            다음은 두 개의 값을 입력 받아 이들로 구성된 딕셔너리 형태의 결과를 출력하는 코드의 예다.            나쁜예)              def make_dict(*args):      x, y = args      return dict(**locals())                        좋은예)              def make_dict(x, y):      return {'x': x, 'y':y}                        좋은예의 코드에서는 함수에 x와 y가 명시적으로 입력되어 이들로 구성된 딕셔너리가 명시적으로 출력된다. 다른 개발자들이 함수 코드 첫 줄과 마지막 줄만 읽고도 무슨 함수인지 이해할 수 있도록 코드를 작성해야 한다. 나쁜예의 코드에서는 입력 값과 출력 값, 그리고 함수의 내용을 한눈에 이해하기 어렵다(물론, 함수가 두 줄뿐이라면 쉽긴 하다)                                “여유로운 것이 밀집한 것보다 좋다”            한 줄에 하나의 구문만 작성하자. 간혹 리스트 컴프리헨션(list comprehension)과 같은 일부 복합 구문은 간결성과 표현성이 뛰어나기에 여러 개의 줄이 되어도 괜찮다. 그러나 서로 다른 구문은 여러 개의 줄로 구분하는 게 좋다. 이는 코드의 diff 결과의 가독성을 높이기도 한다.            나쁜예)              print('one'); print('two')\t\t\t  if x == 1: print('one')\t\t\t  if (&lt;복잡한 표현 1&gt; and       &lt;복잡한 표현 &gt;):       # 원하는 작업 수행                         좋은예)             print('one') print('two')\t\t    if x == 1:     print('one')\t\t       cond1 = &lt;복잡한 표현 1&gt;cond2 = &lt;복잡한 표현 2&gt;if cond1 and cond2:\t\t# 원하는 작업 수행                         파이써니스타들은 코드가 길어지더라도 한 줄에 한 구문씩 작성하고, 긴 조건무늘 여러 줄로 나누어 작성한다. 가독성을 위해서라면 파일 크기가 몇 바이트 증가하거나 계산 시간이 수 마이크로초 증가하는 것쯤은 기꺼이 감수한다.                                “오류 앞에서 절대 침묵하지 말지어다”                                          파이썬에서는 try문을 사용하여 오류를 처리한다. 다음의 내용은 벤자민 글라이츠만의 HowDoI 패키기 코드 중 일부이며, 오류 앞에서 침묵해도 되는 상황이 언제인지 알 수 있다.                  def format_output(code, args):          if not args['color']:              return code          lexer = None          # 스택오버플로 태그에서 렉서를 찾거나          # 쿼리 문자열로부터 렉서를 찾으려 시도          for keyword in args['query'].split() + args['tags']:              try:                  lexer = get_lexer_by_name(keyword)                  break              except ClassNotFound:                  pass          # 위에서 렉서를 찾지 못하면 렉서 추정 도구(guess_lexer)를 사용함          if not lexer:              lexer = guess_lexer(code)          return highlight(code, lexer, TerminalFomatter(bg='dark'))                                                                          “함수 인자는 사용하기에 직관적이어야 한다”            API 디자인에 따라 함수를 통해 소통하는 다운스트림 개발자의 경험이 달라진다. 인자는 다음과 같은 네 가지 방법으로 함수에 전달 될 수 있다.              def func(positional, keyword=value, *args, **kwargs):      pass                                      위치 인자(positional)은 필수이며 기본 값을 가지지 않는다.              키워드 인자(keyword=value)는 선택 사항이며 기본 값을 가진다.              가변 인자 리스트(*args)는 선택 사항이며 기본 값을 가진다.              가변 키워드 인자 딕셔너리(**kwargs)는 선택 사항이며 기본 값을 가진다.                                            “구현 결과를 설명하기 어렵다면, 그 아이디어는 나쁘다.”            파이썬은 해커를 위한 강력한 도구이며, 어떠한 종류의 까다로운 작업도 가능하게 하는 후크와 도구를 풍부하게 보유하고 있다. 예를 들어 파이썬에서는 다음 작업이 가능하다.                          객체를 생성하고 인스턴스화하는 방법을 변경              파이썬 인터프리터가 모듈을 불러오는 방법을 변경              C 루틴을 파이썬에 임베딩                                            “우리는 모두 책임 있는 사용자다”            파이썬에는 ‘프라이빗’ 키워드가 없기 때문에 클라이언트 코드가 객체의 속성과 메서드를 덮어쓸 수 있다. 이는 자바와 같은 방어적 성격의 프로그래밍 언어와 매우 다른 철학을 보여준다. 자바에는 사용자가 안전한 방식으로 코드를 작성할 수 있도록 보호하는 장치가 내장되어 있지만, 파이썬은 그렇지 않다. 따라서 파이썬 사용자는 모두 책임감을 가져야 한다.                                “함수의 결과값은 한 곳에서만 반환하자”            함수가 복잡할수록 반환문의 개수가 증가하기 쉽다. 그러나 의도를 명확히 하고 가독성을 유지하려면 의미 있는 결과 값을 최대한 적은 위치에서 반환하는 게 좋다. 함수 실행이 종료되는 경우는 두 가지다. 하나는 오류가 발생하여 종료되는 경우이고, 나머지 하나는 함수가 정상적으로 실행되어 결과 값을 반환한 뒤 종료되는 경우이다. 함수 실행 중 오류가 발생하면 None이나 False를 반환하는 것이 적절하다. 이 때 함수에서 오류와 관련된 문맥이 파악되자마자 결과 값을 반환하도록 하여 함수 구조를 수평적으로 만드는 것이 좋다. 만약 오류가 발생하지 않는다면, 그 다음 코드가 실행되기 위한 조건이 충족된 것이며, 함수 실행이 멈추지 않고 지속된다. 가끔은 여러 개의 반환문을 사용하는 것도 필요하다.                                    컨벤션                  컨벤션은 모두에게 수긍이 가는 방식이지만 유일한 선택지는 아니다. 컨벤션은 일반적으로 널리 사용되며, 코드의 가독성을 높이는 데 도움이 된다.                              같음을 확인하기 위한 대안            나쁜예)              if attr == True:  print 'True!'\t\t\t  if attr == None:  print 'attr is None!'                        좋은예)              # 값이 존재하는지 확인  if attr:      print 'attr is truthy!'\t\t\t\t  # 값이 존재하지 않는지 확인  if not attr:      print 'attr is falsey!'\t\t\t\t  # 값이 'True'인지 확인  if attr is True:      print 'attr is True'\t\t\t\t  # 값이 'None'인지 확인  if attr is None:      print 'attr is None!'                                            딕셔너리 요소에 접근하기            dict.has_key 메서드 대신 x in d 구문을 사용하거나 dict.get()에 기본 인자를 전달하자.            나쁜예)              &gt;&gt;&gt; d = {'hello': 'world'}  &gt;&gt;&gt;  &gt;&gt;&gt; if d.has_key('hello'):  ... \tprint(d['hello']) # 'world' 출력  ... else:  ... \tprint('default_value')  world                        좋은예)              &gt;&gt;&gt; d = {'hello': 'world}  &gt;&gt;&gt;   &gt;&gt;&gt; print (d.get('hello', 'default_value')  world  &gt;&gt;&gt; print (d.get('howdy', 'default_value')  default_value  &gt;&gt;&gt;  &gt;&gt;&gt; # 아니면,  ... if 'hello' in d:  ... \tprint(d['hello'])  ...  world                                            리스트 다루기            리스트 컴프리헨션은 리스트 자료형을 다루는 명확하고 강력한 도구다!            일반 반복문)              # 4보다 큰 성분만 남기기  a = [3, 4, 5]  b = []  for i in a:      if i &gt; 4:          b.append(a)\t\t\t\t\t  # 모든 리스트 성분에 3씩 더하기  a = [3, 4, 5]  for i in range(len(a)):      a[i] += 3                        리스트 컴프리헨션)              # 리스트 컴프리헨션이 좀 더 깔끔하다  a = [3, 4, 5]  b = [i for i in a if i &gt; 4]\t\t\t  # 아니면 다음과 같이 사용해보자  b = filter(lambda x: x &gt; 4, a)\t\t\t  # 여기도 마찬가지로 깔끔하다  a = [3, 4, 5]  a = [i + 3 for i in a]\t\t\t  # 람다 표현식을 사용할 수도 있다  a = map(lambda i: i + 3, a)                                          프로젝트 구조화하기데코레이터데코레이터는 파이썬 2.4에서부터 추가되었다. 데코레이터는 다른 함수나 메서드를 감싸는 (혹은 장식하는) 함수 혹은 클래스 메서드이다. 장식에 사용된 함수나 메서드는 원래의 함수나 메서드를 바꾼다.&gt;&gt;&gt; def foo():... \tprint(\"I am inside foo.\").........&gt;&gt;&gt; import logging&gt;&gt;&gt; logging.basicConfig()&gt;&gt;&gt; &gt;&gt;&gt; def logged(func, *args, **kwargs):... \tlogger = logging.getLogger()... \tdef new_func(*args, **kwargs):... \t\tlogger.debug(\"calling {} with args {} and kwargs {}\".format(... \t\t\t\t\t\tfunc.__name__, args, kwargs))... \t\treturn func9*args, **kwargs)... \treturn new_func...&gt;&gt;&gt;... @logged... def bar():... \tprint(\"I am insdie bar.\")...&gt;&gt;&gt; logging.getLogger().setLevel(logging.DEBUG)&gt;&gt;&gt; bar()DEBUG:root:calling bar with args () and kwargs {}I am inside bar.&gt;&gt;&gt; foo()I am inside foo.  이 메커니즘은 함수나 메서드의 핵심 논리를 유지하는 데 유용하다.동적 타이핑파이썬은 변수의 타입이 고정되지 않은 동적 타입(dynamically typed)언어다. 파이썬에서는 동적 타이핑이 약점으로 여겨지기도 한다. 디버깅하기 어려운 복잡한 코드를 야기하는 경우가 있기 때문이다. 만약 a라는 변수가 다양한 무언가에 할당된다면, 개발자나 관리자는 변수가 가리키는 대상이 서로 완전히 무관한지 확인하기 위해 코드에서 a가 등장하는 모든 부분을 추적해야 한다.변경 가능/불가능한 자료형파이썬의 자료형은 내장 자료형과 사용자 정의 자료형으로 나뉜다.# 리스트는 변경 가능 my_list = [1, 2, 3]my_list[0] = 4print(my_list) # [4, 2, 3] &lt;- 같은 리스트이며, 변경사항이 적용됨# 정수는 변경 불가능x=6x = x + 1 # 메모리의 다른 위치에 새 x가 만들어짐      변경 가능한 자료형          객체 내용에 대한 제자리 연산이 가능핟. 리스트와 딕셔너리가 그 예시이며, list.append()나 dict.pop()과 같은 메서드를 사용하면 제자리에서 값이 변경된다.            변경 불가능한 자료형          객체 내용을 바꾸는 메서드를 제공하지 않는다. 예를 들어, 변수 x에 정수 6이 할당되어 있다면, ‘increment’메서드를 사용할 수 없다. 그래서 x + 1을 계산하려면 새 정수를 만들어 이름을 정해줘야 한다.      변경 가능 여부에 따른 결과 중 하나는 변경 가능한 자료형을 딕셔너리 키로 사용할 수 없다는 것이다. 딕셔너리는 키 저장을 위해서 해싱(hashing)을 사용하는데, 값이 변경된다면 같은 값에 해시될 수 없기 때문에 해싱을 사용할 수 없다. 변경 불가능한 자료형 중 리스트 대신 사용할 수 있는 것은 튜플이다. 튜플은 소괄호로 만들 수 있는데, 제자리에서 값을 변경할 수 없기 때문에 딕셔너리 키로 사용할 수 있다.의존성 벤더화의존성을 벤더화한 패키지는 외부 의존성(서드파티 라이브러리)을 소스 코드에 포함하고 있다. 이 소스 코드는 vendor나 packages라는 폴더 안에 들어있다. 대부분의 경우에는 의존성을 별도로 분리하는 게 좋다는 것이 중론이다. 그렇지 않으면 코드 저장소에 불필요한 내용(종종 메가 바이트의 추가 코드)이 늘어나기 때문이다.  만약 커다란 변경사항에 대한 풀리퀘스트(Pull request)를 제출하면, 다른 사용자의 추가 제안이나 요청을 수렴하여 유지 관리를 해야 할 수도 있다는 것이다. 이러한 이유로 Tablib과 Requests는 일부 의존성을 벤더화하였다.코드 테스트코드 테스트는 매우 중요하다. 프로젝트가 잘 작동하지 않으면 사람들이 사용하지 않을 것이다. 2001년에 발표된 파이썬 2.1부터는 doctest와 unittest를 포함하였고, 테스트 주도 개발(Test-development, TDD)을 채택하였다. TDD란 함수를 구현하기 이전에 함수의 주 연산과 예외 사례를 정의한 테스트 케이스를 작성하고, 이를 통과하도록 함수 코드를 작성하는 방식이다. 이후로 TDD는 비즈니스 및 오픈소스 프로젝트에 널리받아들여지고 채택되었다.테스트를 위한 팁테스트는 히치하이커가 작성할 수 있는 가장 유용한 코드일 것이다.한번에 하나씩 테스트기능은 작은 단위에 초점을 맞춰 테스트해야 해당 기능이 제대로 작동하는지 증멸할 수 있다.독립은 필수각 테스트 유닛은 서로 독립적이어야 한다. 각자 실행 가능해야 하고, 테스트 슈트로도 실행 가능해야 하며, 호출 순서에 관계없이 한꺼번에 실행이 가능해야 한다.함수 이름은 길고 정확하게테스트 함수 이름에 테스트 내용이 포함되도록 긴 이름을 사용하자! 이는 코드 실행에서 짧은 이름이 선호되는 것과는 조금 다른 지침인데, 테스트 함수가 명시적으로 호출되는 일이 없기 때문이다.속도가 중요하다!한 번의 테스트가 실행될 때 수 밀리 초 이상이 소요되면 개발 속도가 느려지거나, 테스트가 원하는 만큼 자주 실행되지 않는다. 경우에 따라 복잡한 데이터 구조 때문에 테스트마다 데이터 구조를 로딩하느라 느려지기도 한다.메뉴얼을 읽자!사용하는 도구가 개별 테스트나 테스트 케이스를 어떻게 수행하는지 익혀야 한다. 모듈 내 함수를 개발할 때는 함수 테스트를 자주 해야 하고, 가능하다면 코드가 저장될 때마다 자동으로 수행해야 한다.코딩 시작 전과 후에 모든 테스트를 수행하자코딩 시작 전에 테스트 슈트 전체를 돌리고, 코딩이 끝나고 다시 한 번 돌려야 한다. 그래야 코드 작성 부분 이외의 나머지 부분이 깨지지 않았다고 확신할 수 있다.버전 관리 자동화 후크는 매혹적이다공유 저장소에 코드를 보내기 전에는 모든 테스트를 수행하는 후크를 구현하는 것이 좋다.쉬고 싶을 때는 고장 난 테스트를 작성하자개발 도중 작업을 멈춰야 할 때, 그다음 개발해야 할 부분에 고장 난 단위 테스트를 작성하는 것이 좋다. 다시 작업하러 돌아왔을 때 해당 지점에서부터 다시 시작할 수 있으며 기존 작업을 빠르게 파악할 수 있다.테스트를 사용하여 디버깅하자디버깅의 시작은 버그를 찾아내는 테스트를 작성하는 것이다. 매번 테스트를 작성하는 게 번거로울 수도 있다. 그러나 버그를 찾아내는 테스트 코드는 여러분의 프로젝트 코드 중 가장 가치 있는 부분 중 하나일 것이다.공동 작업자가 이해하기 쉬운 테스트를 작성하자무언가 잘못됐거나 고쳐야 할 때 코드에 좋은 테스트 모음이 있다면, 여러분이나 다른 유지 관리자가 문제를 수정하거나 특정 동작을 수정하기 위해 테스트 슈트에 전적으로 의지할 것이다. 따라서 테스트 코드를 실행 코드와 비슷한 수준 혹은 그 이상으로 많이 읽게 될 것이다. 이때 의도가 불분명한 단위 테스트는 별 도움이 되지 않는다.설명하기 쉬운 테스트가 좋다테스트 코드는 새로 합류한 개발자들을 위한 안내의 용도로 사용된다. 새로 합류한 개발자가 이미 만들어진 코드에서 작업해야 할 때는 테스트 코드를 돌려보고 읽어보는 게 최선의 방법일 때가 많다. 그렇게 하면, 코드 중 문제가 있는 부분이나 예외가 발생하는 부분이 어디인지 발견할 수 있다.무엇보다, 혼란에 빠지지 말자오픈 소스의 세계에서 여러분은 혼자가 아니다!!테스트를 위한 기본unittestunittest는 건전지(프로그래머가 바로 사용할 수 있는 라이브러리와 통합 환경을 제공한다는 파이썬의 기본 개념)가 포함된 테스트 모듈로, 파이썬 표준 라이브러리에 포함되어 있다.# test_example.pyimport unittestdef fun(x):\treturn x + 1\tclass MyTest(unittest.TestCase):\tdef test_that_fun_adds_one(self):\t\tself.assertEqual(fun(3),4)\t\tclass MySecondTest(unittest.TestCase):\tdef test_that_fun_fails_when_not_adding_number(self):\t\tself.assertRaises(TypeError, fun, \"multiply six by nine\")Mock(unittest.mock)파이썬 3.3부터 unittest.mock이 표준 라이브러리에서 제공된다. mock을 사용하면 테스트중인 시스템의 일부를 mock 객체로 바꿔 어떻게 사용되고 있는지 알 수 있다.from unittest.mock import MegicMockinstance = ProductionClass()instance.method = MagicMock(return_value=3)instance.method(3, 4, 5, key='value')instance.method.assert_called_with(3, 4, 5, key='value')  테스트 중인 모듈에서 mock 클래스나 mock 객체를 만들고 싶다면, patch 데코레이터를 사용하자!doctestdocktest 모듈은 문서화 문자열 안에 대화형 파이썬 세션처럼 보이는 텍스트가 있는지 검사하고, 해당 세션을 실행하여 쓰여진 대로 정확히 동작하는지 확인한다.def square(x):\t\"\"\"x를 제곱함.\t\t&gt;&gt;&gt; square(2)\t4\t&gt;&gt;&gt; square(-2)\t4\t\"\"\"\t\treturn x * x\tif __name__ == '__main__':\timport doctest\tdoctest.testmod()  명령줄에서 해당 모듈을 실행하면(예: python module.py) doctest가 작동하면서, 문서화 문자열에 기술된 대로 동작하지 않으면 경고한다.예시테스트 슈트를 실행하려면 패키지에 포함되지 않은 별도의 라이브러리가 필요하다(예: Requests에서는 모의 HTTP 서버를 구축하기 위해 Flask패키지를 사용함). 해당 라이브러리는 requirements.txt에 명시되어 있다.예시: Tablib에서의 테스트Tablib는 테스트를 위해 파이썬 표준 라이브러리의 unittest 모듈을 사용한다.#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"Tests for Tablib.\"\"\"import jsonimport unittestimport sysimport osimport tablibfrom tablib.compat import markup, unicode, is_py3from tablib.core import Rowclass TablibTestCase(unittest.TestCase): # 1번    \"\"\"Tablib test cases.\"\"\"    def setUp(self): # 2번        \"\"\"Create simple data set with headers.\"\"\"        global data, book        data = tablib.Dataset()        book = tablib.Databook()        #        # ... 여기서 사용하지 않는 구성 생략 ...        #    def tearDown(self): # 3번        \"\"\"Teardown.\"\"\"        pass    def test_empty_append(self): # 4번         \"\"\"Verify append() correctly adds tuple with no headers.\"\"\"        new_row = (1, 2, 3)        data.append(new_row)        # Verify width/data        self.assertTrue(data.width == len(new_row))        self.assertTrue(data[0] == new_row)    def test_empty_append_with_headers(self): # 5번        \"\"\"Verify append() correctly detects mismatch of number of        headers and data.        \"\"\"        data.headers = ['first', 'second']        new_row = (1, 2, 3, 4)        self.assertRaises(tablib.InvalidDimensions, data.append, new_row)      1번: unittest를 사용하기 위해서는 unittest.TestCase를 상속받는 서브 클래스를 만들고, test로 시작하는 이름의 테스트 메서드를 작성한다. TestCase는 단정 메서드를 제공하며, 같음, 참거짓, 데이터 타입, 집합 포함 여부, 예외 발생 여부 등을 확인한다        2번: TestCase.setUp()은 TestCase의 매 테스트 메서드가 실행되기 전에 실행된다.        3번: TestCase.tearDown()은 TestCase의 매 테스트 메서드가 실행되고 난 후에 실행된다.        4번: 모든 테스트 메서드의 이름은 test로 시작해야 하며, 그렇지 않으면 실행되지 않는다.        5번: 하나의 TestCase 안에 여러 개의 테스트가 있을 수 있으나, 각각 하나의 내용만 테스트 해야 한다.  그 외 인기 있는 도구들pytestpytest는 파이썬 표준인 unittest 모듈에 대한 비표준 대안이다. 즉, 테스트 클래스의 스캐폴딩이 필요 없으며, setup이나 teardown 메서드 또한 필요하지 않을 수 있다.NoseNose는 테스트를 보다 쉽게 할 수 있도록 unittest를 확장한 것이다. Nose는 자동으로 테스트를 발견하며, 수작업으로 테스트 슈트를 만드는 수고를 덜어준다.toxtox는 테스트 환경 관리를 자동화하고, 다중 인터프리터 구성에서 테스트하기 위한 도구다.Lettuce 와 BehaveLettuce와 Behave는 파이썬 행동 주도 개발(Behavior-driven development, 이하 BDD)을 위한 패키지이다. BDD는 2000년대 초 테스트 주도 개발(TDD)에서 파생한 개발 프로세스이며, TDD에서 ‘테스트’란 단어를 ‘행동’으로 대체하여 초보자가 TDD를 어려워하는 문제를 극복하고자 하였다.문서파이썬 개발자에게는 프로젝트의 가독성 뿐만 아니라 문서 가독성도 중요하다.프로젝트 문서프로젝트 문서에는 프로젝트 사용자를 위한 API 문서가 있고, 기여자를 위한 별도의 문서가 있다. 여기서는 후자를 다룬다. 최상위 디렉터리의 README 파일은 프로젝트 사용자와 관리자 모두에게 필요한 정보를 제공하며, 텍스트 또는 마크업 언어로 작성해야 한다. 마크업 언어로는 reStructuredText나 마크다운이 있다. 프로젝트나 라이브러리의 목적을 (사용자가 아무것도 모른다고 가정하고) 설명해야 하며, 소프트웨어의 주요 소스 URL과 기본 크레딧 정보가 포함되어야 한다. README 파일은 코드 독자에게 주요 시작점이 된다.프로젝트 공개문서에는 프로젝트에 따라 아래 구성 요소 전부 혹은 일부가 포함될 수 있다.      소개(introduction)에서는 프로젝트 기능을 한두 개 정도의 매우 간단한 용례로 소개해야 한다. 30초 가량의 프로젝트 홍보라고 생각하자!        튜토리얼(tutorial)에서는 주요 용례를 보다 자세히 설명해야 한다. 독자가 프로토타입을 구성할 수 있을 정도로 단계별로 설명하자!        API 레퍼런스(API reference)는 코드로부터 만들어지는 게 전형적이며, 공개적으로 사용 가능한 인터페이스, 파라미터, 반환 값을 나열한다.        개발자 문서(Developer documentation)는 미래의 기여자를 위해 작성되며, 코드 컨벤션이나 프로젝트의 일반 디자인 전략이 포함될 수 있다.  스핑크스Sphinx는 가장 널리 사용되는 파이썬 문서화 도구다. reStructuredText 마크업 언어를 HTML, LaTex(출력 가능한 PDF 버전용), 메뉴얼 페이지 그리고 일반 텍스트와 같은 다양한 형식으로 변환한다.로그대체로 로그를 남기는 데에는 두 가지 목적이 있다.  진단용 로그진단용 로그는 애플리케이션 작동에 관한 이벤트 기록이다. 예를 들어, 사용자가 오류 보고서를 남기면 로그에서 해당 오류의 문맥을 파악할 수 있다.  감시용 로그감시용 로그는 비즈니스 분석에 사용되는 이벤트 기록이다. 사용자의 거래를 추출하여 다른 세부 정보와 결합하여 보고서를 작성하거나 업무를 최적화 할 수 있다.라이브러리에서 로그 남기기“NullHandler 이외의 핸들러는 라이브러리의 로그 기록기에 추가하지 않는 게 좋다!”로그 기록 이벤트가 발생했을 때 무슨 일인지 알아내는 주체는 라이브러리가 아닌 사용자다. 따라서 위의 경고는 아무리 반복해도 지나치지 않는다. Nullhandler는 이름 그대로 아무것도 하지 않으며 사용자가 원하지 않는 경우에 로그 기록을 명시적으로 해제해야 한다.애플리케이션에서 로그 남기기            방법      장점      단점                  INI 형식의 파일 사용      logging.config.listen()함수를 사용하면, 코드 실행 도중에도 구성을 업데이트하고 소켓의 변경사항을 가져올 수 있다.      코드에서 로그를 구성하는 것보다 제어력이 낮다              딕셔너리나 JSON 형식 파일 사용      실행 중 업데이트할 수 있을 뿐만 아니라, json 모듈을 사용해 파일로부터 구성을 불러올 수도 있다.      코드에서 로그를 구성하는 것보다 제어력이 낮다.              코드 사용      모든 구성을 완벽히 제어할 수 있다.      구성을 수정하려면 소스 코드를 변경해야 한다.      라이선스 선택미국에서는 소스 코드를 배포할 때 라이선스를 명시하지 않으면, 법적으로 사용자는 이를 다운로드/수정/배포하지 못한다. 또한 사람들에게 규칙을 알려주지 않으면 아무것도 프로젝트에 기여하지 못한다. 따라서 라이선스가 필요하다.업스트림 라이선스다른 프로젝트에서 파생된 결과물이라면 업스트림(upstream) 라이선스에 따라 라이선스가 정해진다. 예를 들어, 파이썬 소프트웨어 재단에서는 파이썬 소스 코드에 기여한 모든 참여자에게 해당 코드가 파이썬 소프트웨어 재단에 공식적으로 귀속된다는 내용(본인의 저작권은 유지됨)의 동의 서명을 요청한다. 참고로 기여자는 두 가지 라이선스 중 선택할 수 있다.선택사항선택할 수 있는 라이선스는 무수히 많지만, 파이썬 소프트웨어 재단에서는 OSI(Open Source Institute)에서 승인한 라이선스 중에서 고르길 추천한다.오픈 소스 라이선스는 대체로 다음의 두 카테고리 중 하나에 속한다  허용 라이선스허용 라이선스(permissice license)는 종종 BSD(Berkeley Software Distri-bution, 버클리 소프트웨어 배포) 스타일 라이선스로 불리며, 사용자가 자유롭게 원하는 대로 소프트웨어를 사용하는 데에 초점을 둔다.  카피 레프트 라이선스카피레프트(copyleft) 라이선스는 덜 허용적인 라이선스라고도 불리며, 소스 코드가 그 자체로 사용 가능하도록 하는 데 중점을 둔다. GPL 라이선스가 가장 잘 알려져 있다.훌륭한 코드 읽어 보기프로그래머는 수많은 코드를 읽어야 한다. 능수능란한 프로그래머가 되는 비결은 탁월한 코드를 읽고, 이해하고, 따라잡는 데 있다.HowDoi벤자민 글라이츠만의 HowDoI 프로젝트는 코드 전체가 300줄이 채 안되며, 이번 코드 읽기 여정을 시작하기에 제격이다.단일 파일 스크립트 읽기스크립트는 대체로 명료한 시작점, 명료한 옵션, 명료한 종료점이 있으며, API나 프레임워크를 제공하는 라이브러리보다 이해하기 쉽다.HowDoI의 문서 읽기HowDoI는 프로그래밍에 관한 질문의 답을 인터넷에서 찾도록 돕는 조그마한 명령줄 애플리케이션이다!usage: howdoi.py [-h] [-p POS] [-a] [-l] [-c] [-n NUM_ANSWERS] [-C] [-v] QUERY [QUERY ...]instant coding answers via the command linepositional arguments:  QUERY                 the question to answeroptional arguments:  -h, --help            show this help message and exit  -p POS, --pos POS     select answer in specified position (default: 1)  -a, --all             display the full text of the answer  -l, --link            display only the answer link  -c, --color           enable colorized output  -n NUM_ANSWERS, --num-answers NUM_ANSWERS                        number of answers to return  -C, --clear-cache     clear the cache  -v, --version         displays the current version of howdoiHowDoI 사용하기(venv)$ howdoi --num-answers 2 python lambda function list comprehension--- Answer 1 ---[(lambda x: x*x)(x) for x in range(10)]--- Answer 2 ---[x() for x in [lambda m=m: m for m in [1,2,3]]]# [1, 2, 3]HowDoI의 코드 읽기howdoi.py를 훑어보면 각 함수가 그 다음 함수에서 사용되는 것을 알 수 있어 흐름을 이해하기 쉽다. 또한 함수 이름만 봐도 알 수 있듯이, 함수별로 단 하나의 작업이 주어져 있다. 메인 함수인 command_line_runner()는 howdoi.py 파일의 마지막 부분에 있다.HowDoI의 구조 예시HowDoI는 작은 라이브러리이기 때문에 구조에 대해 짚고 넘어갈 점이 별로 없다하나의 함수는 하나의 일만 하도록 하자!HowDoI의 함수는 각자 하나의 일만 처리하도록 분리되어 있다. 이게 얼마나 유익한지는 아무리 강조해도 모자르다. 심지어 다른 함수의 try/except문을 위해서만 존재하는 함수도 있다(_format_output()는 예외인데, try/except를 통해 예외처릴르 하는게 아니라, 구문 강조에 사용할 코딩 언어를 식별한다!)시스템에서 사용할 수 있는 데이터 활용HowDoI는 관련 시스템 값을 확인하고 사용한다. 프락시 서버를 처리하기 위한 urllib.request.getproxies()가 하나의 예다!(학교와 같은 기관에서 중간 서버를 통해 인터넷 연결 중 일부를 제한하는 경우)HowDoI의 스타일 예시HowDoI는 대체로 PEP8을 따르지만, 가독성이 떨어진다면 따르지 않는다. 예를 들어, import문은 파일의 맨 위에 위치하지만 표준 라이브러리와 외부 모듈이 뒤섞여 있다.밑줄이 앞에 붙은 함수 이름(우리는 모두 책임 있는 사용자다)HowDoI의 거의 모든 함수명 앞에 밑줄이 붙어 있다. 이는 패키지의 내부에서만 사용되는 함수임을 의미한다.호환성은 한 곳에서만 처리(가독성은 중요하다)메인 코드가 실행되기 전에 의존성 버전 차이를 처리한다. 이는 코드 독자에게 의존성 문제가 없을 거란 확신을 주고, 버전 확인 코드가 도처에 남용되지 않도록 막는다. 이 점은 HowDoI가 명령줄 도구이므로 장점이다. 명령줄 도구를 사용하려고 파이썬 인터프리터 버전을 바꾸려는 사람은 거의 없을 것이기 때문이다.파이썬스러운 선택(아름다움이 추함보다 좋다)아래 스니펫은 howdoi.py에서 가져왔으며, 파이썬스럽고 사려 깊은 선택이 뭔지 보여 준다. get_link_at_pos() 함수는 결과가 없으면 False를 반환하고, 아니면 결과 링크 중 스택오버플로 링크를 판별하여 적절한 위치의 링크(링크가 충분하지 않으면 마지막 위치의 링크)를 반환한다.def _is_question(link): # 1번\treturn re.search('questions/\\d+/', link)\t# [ ... 기타 함수 생략 ... ]def get_link_at_pos(links, position):    links = [link for link in links if _is_question(link)] # 2번       if not links:        return False # 3번    if len(links) &gt;= position:        link = links[position - 1] # 4번    else:        link = links[-1] # 5번    return link # 6번      1번: _is_question()은 한 줄짜리 함수이며, 불명확한 정규 표현식 검색에 명확한 의미를 부여한다.        2번: 리스트 컴프리헨션이 문장처럼 읽힌다. 이는 _is_question()을 따로 분리해 정의하고, 의미 있는 변수명을 사용한 덕분이다.        3번: 이른 반환문은 보다 수평적인 구조의 코드를 만들어준다.        4번: link 변수에 값을 지정해주는 추가 단계다.        5번: 여기에선 새로운 변수 선언 없이 두 개의 서로 다른 return문을 사용하는 대신, 명확한 변수명의 link를 사용하여 get_link_at_pos()의 목적을 확실하게 드러냈다. 그 결과 코드 자체가 문서처럼 쉽게 읽힌다.        6번: 최상위 들여쓰기 수준에 위치한 하나의 반환문은 각종 코드 경로가 이곳에서 종료됨을 명시적으로 보여준다. 코드의 첫 줄과 마지막 줄만 읽으면 함수가 무슨 일을 하는지 알 수 있다는 단순한 규칙이 여기에도 적용된다.  DiamondDiamond는 시스템 수치를 수집하여 다운스트림 프로그램에 전달하는 데몬(백그라운드 프로세스 상태로 계속 실행되는 애플리케이션)이다. 다운스트림 프로그램으로는 MySQL, Graphite 등이 있다.보다 큰 애플리케이션 코드 읽기Diamond는 HowDoI와 같은 명령줄 애플리케이션이다. 코드 파일이 여러 개임에도 여전히 시작점과 실행 경로가 명료하다.Diamond 사용하기먼저 Diamond/tmp 폴더를 만들어 수정된 구성 파일을 해당 위치로 옮긴다.폴더 생성은 Diamond 폴더에서 다음과 같이 입력하면 된다.(venv)$ mkdir tmp(venv)$ cp conf/diamond.conf.example tmp/diamond.conf그리고 tmp/diamond.conf 파일을 다음과 같이 수정한다.### Options for the server[server]# Handlers for published metrics. # 1번 handlers = diamond.handler.archive.ArchiveHandleruser = # 2번group = # Diarectory to load collector modules from # 3번collectors_path = src/collectors/### Options for handlers # 4번[handlers][[default]][[ArchiveHandler]]log_file = /dev/stdout### Optrions for collectors[collectors][[default]]# Default Poll Interval (seconds)interval = 20 #### Default enabled collectors[[CPUCollector]]enabled = True[[MemoryCollector]]enabled = True      1번: 여러 핸들러가 있고, 클래스 이름을 사용해 선택할 수 있다.        2번: 데몬을 실행할 사용자와 그룹을 제어할 수 있다.        3번: 콜렉터 모듈을 찾을 경로를 지정할 수 있다. 구성 파일에 경로를 명시하지 않으면 Diamond는 사용자가 만든 Collector 서브 클래스를 찾지 못한다.        4번: 구성 핸들러를 개별로 저장할 수 있다.  Diamond 코드 읽기큰 프로젝트의 코드를 읽을 때는 IDE가 유용하다. 소스 코드에서 함수와 클래스가 정의된 위치를 빠르게 찾을 수 있고, 주어진 정의가 사용된 모든 위치를 찾을 수도 있다. 이러한 기능을 사용하기 위해 가상환경의 파이썬 인터프리터를 IDE의 인터프리터로 지정해주자!diamond는 util로부터 버전 정보를 얻고, utils.log를 사용해 로그 기록 설정을 하고, server를 통해 서버를 가동한다. server는 util 패키지의 거의 모든 모듈을 불러온다. utils.classes를 통해 handler.Handler와 collector에 접근하고, utils.config를 통해 구성 파일에서 콜렉터 설정을 불러온다. 그리고 utils.schedular를 통해 콜렉터가 수치를 계산하기 위한 폴링 간격을 설정하고, utils.signals을 통해 핸들러를 구성하고 시작한다!Diamond의 구조 예시Diamond는 실행 가능한 애플리케이션이면서 맞춤형 콜렉터를 만들고 사용할 수 있는 방법을 제공하는 라이브러리이기도 하다.서로 다른 기능을 네임스페이스로 분리하자(네임스페이스는 대박 좋은 아이디어였다!)server 모듈이 diamond.handler, diamond.collector 그리고 diamond.utils라는 세 가지 모듈과 상호작용함을 보았다. 사실 utils하위 패키지에 포함된 모든 클래스와 함수를 모두 util.py 모듈에 모아 하나의 거대한 파일로 만들 수 있지만, Diamond 개발팀은 네임스페이스를 사용하여 기능별로 코드를 분리했다. 대박!사용자가 확장할 수 있는 사용자 정의 클래스(복잡함이 꼬인 것보다 낫다)새 콜렉터를 구현하는 작업은 쉽다. 그저 diamond.collector.Collector 추상 베이스 클래스를 상속하여 Collector.collect() 메서드를 구현한 뒤, 구현 결과를 폴더에 담아 venv/src/collectors/에 넣어주면 된다.Diamond 스타일 예시클로저 사용 예시(갓차가 갓차가 아닌 경우)클로저는 지역 변수를 사용하는 함수이며, 해당 지역 변수가 정의된 함수가 호출되지 않는 한 클로저 함수르 사용할 수 없다. 다른 언어에서는 클로저는 구현하거나 이해학기 어려울 수 있지만, 파이썬에서는 그렇지 않다. 파이썬은 함수를 여타 객체처럼 다루기 때문이다. 예를 들어, 파이썬의 함수는 다른 함수의 인자 혹은 반환 값이 될 수 있다.##~~ ... 임포트 구문 생략 ... # 1번def main():    try:        ##~~ ... 명령줄 파서 구현 생략 ...        # Parse Command Line Args        (options, args) = parser.parse_args()        ##~~ ... 구성 파일을 파싱하는 코드 생략 ...        ##~~ ... 로그를 구성하는 코드 생략 ...    # Pass the exit up stream rather then handle it as an general exception    except SystemExit, e:        raise SystemExit    ##~~ ... 구성에 관한 기타 예외 처리 코드 생략 ...        try:        # PID MANAGEMENT # 2번        if not options.skip_pidfile:            # Initialize Pid file            if not options.pidfile:                options.pidfile = str(config['server']['pid_file'])            ##~~ ... PID 파일이 존재하면 이를 불러온 뒤, ...            ##~~ ... 해당 PID의 프로세스가 없다면 파일을 삭제하고 ...            ##~~ ... 해당 PID의 프로세스가 실행 중이라면 종료하는 코드 생략 ...                        ##~~ ... 그룹과 사용자 ID를 설정하는 코드와 ...            ##~~ ... PID 파일 권한을 변경하는 코드 생략 ...                        ##~~ ... 데몬 여부를 확인한 뒤 ...            ##~~ ... 만약 그렇다면 프로세스를 분리하는 코드 생략 ...        # PID MANAGEMENT # 3번        if not options.skip_pidfile:            # Finish Initialize PID file            if not options.foreground and not options.collector:                # Write pid file                pid = str(os.getpid())                try:                    pf = file(options.pidfile, 'w+')                except IOError, e:                    log.error(\"Failed to write child PID file: %s\" % (e))                    sys.exit(1)                pf.write(\"%s\\n\" % pid)                pf.close()                # Log                log.debug(\"Wrote child PID file: %s\" % (options.pidfile))        # Initialize Server        server = Server(configfile=options.configfile)        def sigint_handler(signum, frame): # 4번            log.info(\"Signal Received: %d\" % (signum))            # Delete Pidfile            if not options.skip_pidfile and os.path.exists(options.pidfile): # 5번                os.remove(options.pidfile)                # Log                log.debug(\"Removed PID file: %s\" % (options.pidfile))                        sys.exit(0)        # Set the signal handlers        signal.signal(signal.SIGINT, shutdown_handler) # 6번        signal.signal(signal.SIGTERM, shutdown_handler)        server.run()    # Pass the exit up stream rather then handle it as an general exception    except SystemExit, e:        raise SystemExit    ##~~ ... 기타 예외 처리 코드 생략 ...    ##~~ ... 나머지 코드 생략      1번: 요약 내용        2번: PID 파일을 통해 데몬이 고유한지 확인하고, 관련 프로세스 ID를 다른 스크립트에 신속히 전달한다.        3번: 이 부분은 클로저까지 이어지는 문맥을 제공하고자 남겼다. 이제 프로세스가 데몬화되어 이전과 다른 PID를 가진다.        4번: sigint_handler() 함수는 클로저다. 최상위 수준이 아닌 main() 함수 안에 정의되어 있다. 이는 sigint_handler()가 PID 파일 탐색 여부와 그 위치를 알아야 하기 때문이다!        5번: 명령줄 옵션으로부터 조건문에 사용되는 정보를 얻는다. 이 정보는 main() 함수가 실행되기 전까지는 얻을 수 없다. 즉, PID 파일에 관한 모든 옵션은 main 네임스페이스의 지역 변수이다.        6번: 클로서(signal_handler() 함수)가 신호 핸들러에 전달되어 SIGINT와 SIGTERM을 처리하는 데 사용한다.  TablibTablib은 데이터 형식을 바꾸거나, Dataset 객체에 데이터를 저장하거나, Datebook에 여러 Dataset을 저장하는 파이썬 라이브러리이다.작은 라이브러리 읽기Tablib은 애플리케이션이 아닌 라이브럴리이다. 따라서 HowDoI나 Diamond와 달리 진입점이 여러 개이다.Tablib 사용하기Tablib은 파이썬 대화형 세션에서 help() 함수를 사용하여 API를 탐색할 수 있다.다음은 tablib.Dataset 클래스를 사용해 여러 형식의 데이터를 불러오거나 저장하는 코드이다.&gt;&gt;&gt; import tablib&gt;&gt;&gt; data = tablib.Dataset()&gt;&gt;&gt; names = ('Black Knight', 'Killer Rabbit')&gt;&gt;&gt; &gt;&gt;&gt; for name in names:... \tfname, lname = name.split()... \tdata.append((fname, lname))...&gt;&gt;&gt; data.dict&gt;&gt;&gt; [['Black', 'Knight'], ['Killer', 'Rabbit']]&gt;&gt;&gt; &gt;&gt;&gt; print(data.csv)Black,KnightKiller,Rabbit&gt;&gt;&gt; data.headers=('First name', 'Last name')&gt;&gt;&gt; print(data.yaml)- {First name: Black, Last name: Knight}- {First name: Killer, Last name: Rabbit}&gt;&gt;&gt; with open('tmp.csv', 'w') as outfile:... \toutfile.write(data.csv)...64&gt;&gt;&gt; newdata = tablib.Dataset()&gt;&gt;&gt; newdata.csv = open('tmp.csv').read()&gt;&gt;&gt; print(newdata.yaml)- {First name: Black, Last name: Knight}- {First name: Killer, Last name: Rabbit}Tablib 코드 읽기모듈의 문서화 문자열을 통해 기존과 다른 방식으로 소스 코드를 둘러보자.다음과 같이 터미널 셸에서 패키지의 최상위 디렉터리로 이동한 뒤 head *.py를 입력하면, 모든 모듈의 문서화 문자열을 한꺼번에 볼 수 있다.(venv)$ cd tablib(venv)$ head *.py==&gt; __init__.py &lt;== # 1번\"\"\" Tablib. \"\"\"from tablib.core import (\tDatabook, Dataset, detect, import_set, import_book,\tInvalidDatasetType, InvalidDimensions, UnsupportedFormat,\t__version__)==&gt; compat.py &lt;== # 2번# -*- coding: utf-8 -*-\"\"\"tablib.compat~~~~~~~~~~~~~Tablib compatiblity module.\"\"\"==&gt; core.py &lt;== # 3번# -*- coding: utf-8 -*-\"\"\"\ttablib.core\t~~~~~~~~~~~\t\tThis module implements the central Tablib objects.\t\t:copyright: (c) 2014 by Kenneth Reitz.\t:license: MIT, see LECENSE for more details.\"\"\"      1번: 최상위 수준 API에는 딱 아홉 개의 진입점이 있다. 먼저 Dataset과 Databook 클래스는 문서에 언급되어 있다. 일단 detect는 형식을 식별하는 것처럼 보이고, import_set과 import_book은 데이터를 불러올 게 분명하다. 그리고 나머지 세 클래스 InvalidDataType, InvalidDataDimensions, UnsupportedFormat는 예외처럼 보인다.        2번: tablib/compat.py는 호환성 모듈이다. 해당 모듈의 코드를 훑어보면, 파이썬 2와 3의 호환 문제를 처리하기 위해 tablib/core.py에서 사용하는 모듈의 위치나 이름 차이를 해결한다는 점을 쉽게 알 수 있다. 이는. HowDoI와 비슷한 해결법이다.        3번: tablib/core.py에는 모듈 이름에서 알 수 있듯 Dataset과 Databook과 같은 핵심 Tablib 객체가 구현되어 있다.  Tablib의 구조 예시Tablib에서 가장 주목할 점은 tablib/formats/ 안의 모듈에 클래스가 없다는 것이다. 이는 클래스를 남용하지 않는 완벽한 예시이다.형식적으로 불필요한 객체지향 코드는 필요 없다(함수 그룹화를 위해 네임스페이스를 사용하자)grep^def formats/*.py를 사용하면 각 모듈이 다음 함수 중 일부 혹은 전부를 담고 있음을 알 수 있다.      detect(stream)은 스트림 내용에 기반하여 파일 형식을 유추한다.        dset_sheet(dataset, ws)는 엑셀 스프레드시트 셀의 서식을 지정한다.        export_set(dataset)은 Dataset을 주어진 형식으로 내보내며, 형식이 갖춰진 문자열을 반환한다.        import_set(dset, in_stream, headers=True)는 Dataset의 내용을 입력 스트림 내용으로 바꾼다.        export_set(dset, in_stream, headers=True)는 Databook 안의 Datasheet를 주어진 형식으로 내보내며, 문자열이나 bytes 객체를 반환한다.        import_book(dbook, in_stream, headers=True) Databook의 내용을 입력 스트림 내용으로 바꾼다.  Tablib의 스타일 예시연산자 오버로딩(아름다움이 추함보다 좋다)Tablib은 파이썬의 연산자 오버로딩을 사용하여 Dataset의 행 단위/열 단위 연산을 가능하게 했다.&gt;&gt;&gt; data[-1] # 1번('1 whole', 'olive')&gt;&gt;&gt;&gt;&gt;&gt; data[-1] = ['2 whole', 'olives'] # 2번&gt;&gt;&gt; &gt;&gt;&gt; data[-1]('2 whole', 'olives') # 3번&gt;&gt;&gt;&gt;&gt;&gt; del data[2:7] # 4번&gt;&gt;&gt; &gt;&gt;&gt; print(data.csv)amount,ingredient # 5번1 bottle,0l' Janx Spirit1 measure,Santraginus V seawater2 whole,olives&gt;&gt;&gt; data['ingredient'] # 6번[\"Ol' Janx Spirit\", 'Santraginus V seawater', 'olives']      1번: 대괄호 연산자([])와 숫자를 함께 사용하면, 특정 위치의 행 데이터에 접근할 수 있다.        2번: 중괄호 연산자를 사용해 값을 할당할 수 있다.        3번: 그리고 원래의 값이 바뀐 것을 확인할 수 있다.        4번: 슬라이스(slice)를 사용해 값을 삭제했다. 2:7은 2,3,4,5,6을 가리키며, 7은 포함되지 않는다.        5번: 데이터가 csv형식으로 바뀌었다.        6번: 열 이름을 통해 열 데이터에 접근할 수도 있다.  Requests2011년 발렌타인데이에 케네스 레이츠는 파이썬 커뮤니티에 대한 애정을 담아 Requests 라이브러리를 공개했다. Requests 라이브러리의 (API 문서를 읽을 필요가 없을 정도로) 직관적인 API 디자인은 파이썬 커뮤니티의 마음을 단숨에 사로잡았다.Requests 문서 읽기Requests는 몇 가지 함수와 특색있는 클래스, 키워드 인자 뭉치만을 사용하여 IETF의 HTTP 기준을 맞추고자 노력하였다.Requests 사용하기Tablib과 마찬가지로 Requests 또한 문서화 문자열이 잘 정리되어 있어 온라인 문서를 굳이 읽지 않아도 무리가 없다.다음은 간략한 상호작용 예시이다.&gt;&gt;&gt; import requests&gt;&gt;&gt; help(requests) # 사용법 설명문을 보면 requests.api를 살펴보라고 설명되어 있다.&gt;&gt;&gt; help(requests.api) # 자세한 API 설명을 보여준다.&gt;&gt;&gt; &gt;&gt;&gt; result = request.get('https://pypi.python.org/pypi/requests/json')&gt;&gt;&gt; result.status_code200&gt;&gt;&gt; result.okTrue&gt;&gt;&gt; result.text[:42]'{\\n \t\"info\": {\\n&gt;&gt;&gt; &gt;&gt;&gt; result.json().keys()dict_keys(['info', 'releases', 'urls'])&gt;&gt;&gt;&gt;&gt;&gt; result.json()['info']['summary']'Python HTTP for Humans.'Requests 스타일 예시Requests의 스타일은 집합을 사용하는 방법에 대한 좋은 예다(대개 집합은 자주 사용되지 않는다) requests.status_code 모듈은 전반적인 코드 스타일을 단순화하기 위해 존재하며, 이 모듈로 인해 HTTP 상태 코드가 필요할 때마다 일일히 코드를 나열하지 않아도 된다.집합과 집합 연산(파이썬스럽고 멋진 관용구)다음은 cookies.py에서 가져온 코드다. 함수 끝부분에서 집합 연산을 확인할 수 있다.# # ... cookies.py에서 가져온 코드 ...# def create_cookie(name, value, **kwargs): # 1번    \"\"\"Make a cookie from underspecified parameters.    By default, the pair of `name` and `value` will be set for the domain ''    and sent on every request (this is sometimes called a \"supercookie\").    \"\"\"    result = dict(        version=0,        name=name,        value=value,        port=None,        domain='',        path='/',        secure=False,        expires=None,        discard=True,        comment=None,        comment_url=None,        rest={'HttpOnly': None},        rfc2109=False,)    badargs = set(kwargs) - set(result) # 2번    if badargs:        err = 'create_cookie() got unexpected keyword arguments: %s'        raise TypeError(err % list(badargs)) # 3번    result.update(kwargs) # 4번    result['port_specified'] = bool(result['port']) # 5번    result['domain_specified'] = bool(result['domain'])    result['domain_initial_dot'] = result['domain'].startswith('.')    result['path_specified'] = bool(result['path'])    return cookielib.Cookie(**result) # 6번      1번: **kwargs를 사용하여 사용자가 쿠키에 대한 키워드 인자를 자유로이 넘기거나 넘기지 않을 수 있게 한다.        2번: 집합 연산이다! 파이썬스럽고 단순하다. 표준 라이브러리에 있다. 딕셔너리에 set()을 적용하면 키로 구성된 집합이 된다.        3번: 긴 줄의 코드를 짧은 두 줄로 쪼갠 훌륭한 예다. err 변수가 추가됐지만 별 영향은 없다.        4번: result.update(kwargs)는 result 딕셔너리를 kwargs 딕셔너리의 키/값 쌍으로 업데이트하며, 기존 쌍이 존재하면 값을 업데이트하고 그렇지 않으면 새로 만든다.        5번: bool()을 호출하여 객체가 의미 있으면 True를 반환한다        6번: cookielib.Cookie를 초기화하려면 시그니처상 18개의 위치 인자와 1개의 키워드 인자가 필요하다. 따라서 Requests는 위치 인자를 키워드 인자처럼 사용할 수 있도록 딕셔너리 형태로 전달한다.  WerkzeugWerkzeug 코드를 읽으려면 웹 서버가 애플리케이션과 통신하는 방법에 대해 조금 알아야 한다. 다음 문단에 최대한 간략하게 요약해보았다.      서버는 HTTP 요청을 받을 때마다 애플리케이션을 한번 호출한다.        애플리케이션은 서버가 HTTP 요청에 대한 응답으로 사용할 순회 가능한 바이트 문자열을 포함한다.        문서에 따르면 애플리케이션은 두 개의 파라미터를 받는다.  2007년에 아르민 로나허는 WSGI라이브러리에 대한 염원과 필요를 충족시켜줄 백자이크(Werkzeug)를 배포했다. 백자이크는 WSGI 애플리케이션과 미들웨어 컴포넌트를 만드는 데 사용할 수 있다.툴킷 코드 읽기소프트웨어 툴킷은 호환 가능한 유틸리티의 모음이다. Werkzeug의 경우, WSGI 애플리케이션과 연관된 모든 게 소프트웨어 툴킷이 된다.Werkzeug 사용하기Werkzeug는 WSGI 애플리케이션을 위한 여러 유틸리티를 제공한다.Werkzeug에는 일회용 테스트를 수행할 때 실제 웹서버를 대신하기 위한 werkqeug.client 클래스가 구현되어 있다. 클라이언트의 응답은 response_wrapper 인자 타입을 가진다.Werkzeug 코드 읽기테스트 커버리지가 좋다면 단위 테스트만 보고도 라이브러리의 역할과 기능을 알 수 있다. 단위 테스트를 볼 때는 의식적으로 ‘숲’이 아닌 ‘나무’를 봐야 한다는 점을 주의하자. werkzeug/test_routing.py를 열어 임포트한 객체를 찾아보자 이를 통해 모듈간 상호 연결을 빠르게 살필 수 있다.import pytest # 1번import uuid # 2번from tests import strict_eq # 3번from werkzeug import routing as r # 4번from werkzeug.wrappers import Response # 5번 from werkzeug.datastructures import ImmutableDict, MultiDict # 6번from werkzeug.test import create_environ # 7번      1번: 여기서는 테스트를 위해 pytest를 사용했다.        2번: uuid 모듈은 test_uuid_converter() 함수에서만 사용된다. 이 함수는 문자열을 uuid.UUID 객체로 변환하는 기능이 잘 작동하는지 테스트한다.        3번: strict_eq() 함수는 werkzeug/tests/init.py에 정의되어 있는 테스트용 함수이며, 자주 사용된다.        4번: werkzeug.routing 모듈이 테스트 대상이다.        5번: Respond 객체는 test_dispatch() 함수에서만 사용된다.        6번: 여기에서 불러온 딕셔너리 객체는 한 번씩만 사용된다. ImmutableDict는 werkzeug.routing.Map의 변경 불가능한 딕셔너리가 정말 변경할 수 없는지 확인하는 데 사용하며, MultiDict는 여러 키 값을 URL 빌드 도구에 제공했을 때 알맞은 URL을 빌드하는지 확인하는 데 사용한다.        7번: create_environ()는 테스트를 위한 함수이며, 실제 HTTP 요청을 사용하지 않고도 WSGI 환경을 만든다.  Werkzeug 스타일 예시자료형을 추측하는 우아한 방법(구현 결과를 설명하기 쉽다면, 그 아이디어는 좋은 아이디어일 수 있다)텍스트 파일을 파싱하여 여러 자료형으로 변환해야 하는 작업은 자주 필요하다. 이에 대한 Werkzeug의 해답은 유독 파이썬스러우며, 스타일 예시로 소개하기 적절하다._PYTHON_CONSTANTS = {\t'None':\tNone,\t'True': \tTrue,\t'False': \tFalse}def _pythonize(value):\tif value in _PYTHON_CONSTANTS: # 1번\t\treturn _PYTHON_CONSTANTS[value]\tfor convert in int, float: # 2번\t\ttry: # 3번\t\t\treturn convert(value)\t\texcept ValueError:\t\t\tpass\tif value[:1] == value[-1:] and value[0] in '\"\\'': # 4번\t\tvalue = value[1:-1]\treturn text_type(value) # 5번      1번: 파이썬 딕셔너리는 키를 검색 할 때 해시 함수를 집합처럼 사용한다. 대신, 파이썬 사용자는 if/elif/else를 사용하거나, 예시 코드처럼 딕셔너리 탐색을 사용한다.        2번: float보다 제한적인 자료형인 int를 먼저 반환하는 점에 주목하자.        3번: 자료형을 추론하기 위해 try/except문을 사용했다. 파이썬 스럽다.        4번: 이 부분은 꼭 필요한 부분이다. 코드는 werkzeug/routing.py에 있고, 파싱되는 문자열은 URL의 일부이기 때문이다.        5번: text_type은 문자열을 유니코드로 변환한다. 이때, 파이썬 2와 3에서 모두 호환되는 방식으로 변환된다.  Werkzeug 구조 예시클래스기반 데코레이터(동적 타이핑의 파이썬스러운 사용)Werkzeug는 덕 타이핑을 사용하여 @cached_property 데코레이터를 만들었다. Tablib 프로젝트에서는 프로피티가 함수처럼 정의되었음을 떠올려보자. 대체로 데코레이터는 함수이다. 그러나 형식에 대한 제한이 없기 때문에, 호출 가능한 객체라면 얼마든지 데코레이터가 될 수 있다.  다음은 사용 예시이다.&gt;&gt;&gt; from werkzeug.utils import cached_property&gt;&gt;&gt; &gt;&gt;&gt; class foo(object):... \t@cached_property... \tdef foo(self):... \t\tprint(\"You have just called Foo.foo()!\")... \t\treturn 42...&gt;&gt;&gt; bar = foo()&gt;&gt;&gt; &gt;&gt;&gt; bar.fooYou have just called Foo.foo():42&gt;&gt;&gt; bar.foo42&gt;&gt;&gt; bar.foo # 더이상 출력문이 작동하지 않음에 주의하자 42Response.callRequests 라이브러리와 마찬가지로, Response 클래스는 BaseResponse에 여러 기능을 더하여 만들어졌다.믹스인(네임스페이스 못지 않게 대박 좋은 아이디어다)파이썬의 믹스인은 클래스에 특정 기능을 추가하기 위해 사용하는 클래스다. 파이썬은 자바와 달리, 다중 상속이 허용된다. 즉, 클래스는 만들 때 여러 개의 서로 다른 상위 클래스로부터 여러 가지 행동이나 특징을 상속받아 만들 수 있고, 여러 기능을 클래스별로 구분하여 모듈화 하는게 가능해진다. 일종의 ‘네임스페이스’라 볼 수 있겠다.때때로 Werkzeug의 믹스인 메서드에 특정 속성이 필요할 수 있다. 이러한 요구사항은 대부분 믹스인 문서화 문자열에 설명되어 있다.# ... in werkzeug/wrappers.pyclass UserAgentMixin(object): # 1번    \"\"\"Adds a `user_agent` attribute to the request object which contains the    parsed user agent of the browser that triggered the request as a    :class:`~werkzeug.useragents.UserAgent` object.    \"\"\"    @cached_property\t def user_agent(self):    \"\"\"The current user agent.\"\"\"    from werkzeug.useragents import UserAgent    return UserAgent(self.environ) # 2번        class Request (BaseRequest, AcceptMixin, ETagRequestMixin,     \t\t\t\t\tUserAgentMixin, AuthorizationMixin, # 3번    \t\t\t\t\tCommonRequestDescriptorsMixin): \t\t\"\"\"Full featured request object implementing the following mixins: \t\t\t\t- :class:`AcceptMixin` for accept header parsing \t\t- :class:`ETagRequestMixin` for etag and cache control handling \t\t- :class:`UserAgentMixin` for user agent introspection \t\t- :class:`AuthorizationMixin` for http auth handling \t\t- :class:`CommonRequestDescriptorsMixin`\t\t\"\"\"\t\t# 4번      1번: UserAgentMixin은 특별할 게 없다. 파이썬 3에서는 object를 상속하는 게 기본값이지만, 파이썬 2와의 호환성을 위해 명시하였다.        2번: UserAgentMixin.user_agent는 self.environ 속성이 있다고 가정한다.        3번: Request를 위한 베이스 클래스 목록에 믹스인이 포함되면, Request(environ).user_agent를 통해 믹스인의 속성에 접근할 수 있다.        4번: 정말 별게 없다. Requests를 정의한 코드는 여기서 끝난다. 모든 기능은 베이스 클래스나 믹스인에서 제공된다.  FlaskFlask는 Werkzeug와 Jinja2를 결합한 웹 마이크로 프레임워크다. 농담처럼 만들어져 2010년 만우절에 배포되었지만, 금새 파이썬에서 가장 인기 있는 웹 프레임워크 중 하나가 되었다.프레임워크 코드 읽기소프트웨어 프레임워크는 물리적인 프레임워크와 같다. Flask는 WSG 애플리케이션을 빌드하는 데 필요한 기반 구조를 제공하며, 라이브러리 사용자는 그 위에 Flask 애플리케이션이 작동하도록 컴포넌트를 쌓아 사용한다.Flask 사용하기Flask 코드 읽기Flask의 궁극적인 목적은 웹 애플리케이션을 만드는 것이다. 따라서 Diamond나 HowDoI와 같은 명령줄 애플리케이션과 그리 다르지 않다.먼저 flaskr.py에 중단점을 추가해보면 코드가 실행되다가 중단점에 도달하면 대화형 세션에서 디버거에 진입한다.@app.route('/') def show_entries():\timport pdb ; pdb.set_trace() ## 중단점이 되는 코드\tdb = get_db() \tcur = db.execute('select title, text from entries order by id desc') \tentries = cur.fetchall()\treturn render_template('show_entries.html', entries = entries)다음으로는 파일을 닫고 명령줄에 python을 입력하여 대화형 세션에 들어가자.서버를 시작하기보다, Flask 내부 테스팅 유틸리티를 사용하여 HTTP GET 요청을 디버거가 위치한 /에 시뮬레이션하자.&gt;&gt;&gt; import flaskr &gt;&gt;&gt; client = flaskr.app.test_client() &gt;&gt;&gt; client.get('/')&gt; /[...truncated path ...]/flask/examples/flaskr/flaskr.py(74)show_entries()-&gt; db = get_db()(Pdb)Flask 스타일 예시Flask의 라우팅 데코레이터(아름다움이 추함보다 좋다)Flask의 라우팅 데코레이터는 아래와 같이 대상 함수에 URL 라우팅을 추가한다.@app.route('/')def index():\tpassFlask 애플리케이션은 요청을 보낼 때 URL 라우팅을 사용하여 응답을 생성하는 함수가 올바른지 분별한다. 데코레이터 구문은 라우팅 코드 로직을 대상 함수에서 제외시킴으로써 함수 구조를 수평적으로 만드는 데 도움이 되며, 사용하기 쉽다.다음은 flask/flask/app.py의 메인 Flask 클래스의 메서드 소스 코드이다!class Flask(_PackageBoundObject): # 1번\t\"\"\"The flask object implements a WSGI application ... \t... 문서화 문자열의 나머지 부분은 생략함 ... \t\"\"\" \t##~~ ... routing() 메서드를 제외한 나머지 생략.\t\tdef route(self, rule, **options):\t\t\"\"\"A decorator that is used to register a view function for a \t\tgiven URL rule. This does the same thing as :meth:`add_url_rule` \t\tbut is intended for decorator usage:: \t\t@app.route('/') \tdef index(): \t\treturn 'Hello World' \t\t... 나머지 문서화 문자열 생략 ... \t\"\"\" \tdef decorator(f): # 2번\t\tendpoint = options.pop('endpoint', None) \t\tself.add_url_rule(rule, endpoint, f, **options) # 3번\t\treturn f return decorator\t      1번: _PackageBoundObject는 HTML 템플릿, 정적 파일 등을임포트하기 위한 파일 구조를 설정하며, 애플리케이션 모듈 위치에 대한 상대 경로를 특정 짓는 구성 값을 사용한다.        2번: 데코레이터니까 데코레이터라고 이름을 붙였다.        3번: 모든 규칙을 담은 매핑에 URL을 추가하는 함수 부분이다. Flask.route의 유일한 목적은 라이브러리 사용자에게 편리한 데코레이터를 제공하는 것이다.  Flask 구조 예시Flask의 구조 예시 주제는 모듈성이다. Flask는 쉽게 확장하고 수정할 수 있게 설계되었다. 거의 모든 것이 쉽게 수정할 수 있으며, 여기서 거의 모든 것이란 JSON 문자열을 인코딩하고 디코딩하는 방법부터 URL을 라우팅하는 데 사용하는 클래스까지 다양하다.애플리케이션 전용 기본 값(단순함이 복잡함보다 좋다)Flask와 Werkzeug 둘 다 wrapper.py 모듈을 가진다. Flask는 웹 애플리케이션 전용 프레임워크이며, Werkzeug는 WSGI 애플리케이션을 위한 보다 범용적인 유틸리티 라이브러리이다. Flask의 wrapper.py는 Werkzeug 위에 Flask 전용 기본 값을 추가하기 위해 존재한다. 이때, 웹 애플리케이션에 관한 특정 기능을 추가하기 위해 Werkzeug의 Request와 Response 객체를 상속한다. 예를 들어, flask/flask/wrappers.py의 Response 객체는 다음과 같이 생겼다.from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase##~~ ... 나머지 코드 생략 ...class Response(ResponseBase):  # 1번    \"\"\"The response object that is used by default in Flask.  Works like the    response object from Werkzeug but is set to have an HTML mimetype by    default.  Quite often you don't have to create this object yourself because    :meth:`~flask.Flask.make_response` will take care of that for you.    If you want to replace the response object used you can subclass this and    set :attr:`~flask.Flask.response_class` to your subclass. # 2번    \"\"\"    default_mimetype = 'text/html' # 3번      1번: Werkzeug의 Response 클래스를 ResponseBase로 임포트하여 그 역할을 분명히 하고, Response라는 이름의 새로운 서브 클래스를 만들 수 있도록 했다. 멋진 스타일이다!        2번: flask.wrappers.Response란 이름의 서브 클래스를 만들고 사용하는 방법이 문서화 문자열에 나와 있다. 이와 같은 기능을 구현할 때, 문서화를 잊지 말자. 문서가 없으면 사용자가 이를 사용할 가능성이 낮아 진다.        3번: Response 클래스에서 이 부분만 바뀌었다. Request 클래스에서는 더 많은 변경사항이 있지만, 설명이 너무 길어지니 생략한다.  모듈성(네임스페이스 못지 않게 대박 좋은 아이디어다)flask.wrappers.Response의 문서화 문자열은 사용자로 하여금 Response 객체를 상속 받아 메인 Flask 객체 내에 사용자가 입맛에 맞는 새클래스를 정의하여 사용할 수 있도록 한다.",
        "url": "/blackruby-code//back/2017/12/16/Python_travel1.html"
      }
      ,
    
      "back-2017-12-15-python-travel-html": {
        "title": "파이썬을 여행하는 히치하이커를 위한 안내서 - 인터프리터 선택하기, 파이썬 설치하기, 개발환경",
        "tags": "Python, Flask",
        "date": "December 15, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "파이썬을 여행하는 히치하이커를 위한 안내서들어가기인터프리터 언어 선택하기파이썬 2와 3 중 어느 버전을 선택할까?파이썬 버전에 관한 몇 가지 사실  오랜 시간 동안 파이썬 2.7이 표준이었다.  파이썬 3에서 많은 변화가 생겼고, 일부 개발자들은 이러한 변화 때문에 불행해졌다.  파이썬 2.7의 필수 보안 업데이트는 2020년까지 지속될 것이다.  파이썬 3는 파이썬 2가 지난 몇 년간 그래왔듯이 끊임없이 진화하고 있다.추천하는 파이썬 버전파이썬 3를 사용할 사람  파이썬 3를 사랑한다.  어떤 버전을 사용할지 모르겠다.  변화를 좋아한다.파이썬 2를 사용할 사람  파이썬 2를 사랑하며, 대다수가 파이썬 3를 사용할 미래를 떠올리면서 슬프다.  파이썬 3를 사용하면, 소프웨어의 안정성 요구사항이 영향을 받는다.  의존한느 소프트웨어가 파이썬 2를 필요로 한다.파이썬 3가 최선일까?구현사람들이 파이썬에 대해 얘기할 때, 파이썬 언어 자체를 언급하는 경우가 대다수지만 가끔 C파이썬 구현체(implementation)를 지칭하기도 한다. 실제로 파이썬은 다양한 방식으로 구현될 수 있다.      C파이썬          C파이썬(CPython)은 파이썬의 표준 구현이며 C언어로 작성되었다. C파이썬은 파이썬 코드를 중간 바이트코드로 컴파일하고, 그 결과를 가상머신이 해석한다. C파이썬은 파이썬 패키지, C 확장 모듈과 호환성이 가장 높다.            스택리스          스택리스 파이썬(Stackless Python)은 보통의 C파이썬이며, C파이썬에서 사용 가능한 모든 라이브러리를 사용 할 수 있다. 그러나 파이썬 인터프리터를 호출 스택과 분리함으로써 코드 실행 순서를 변경할 수 있는 기능이 있다. 스택리스는 태스크릿(tasklet)이라는 콘셉트를 도입하여 함수를 감싸 ‘마이크로스레드(Microthread)로 바꾼다.            파이파이          파이파이(PyPy)는 파이썬 언어의 정적 타입 부분 집합인 RPython을 사용해 구현되었으며, 특정 종류의 최적화가 가능하다.            자이썬          자이썬(Jython)은 파이썬 코드를 자바 바이트코드로 컴파일하는 파이썬 인터프리터 구현이며, 컴파일 결과는 자바 가상머신에서 실행 될 수 있다. 자바 클래스를 파이썬 모듈 불러오듯 가져와 사용할 수도 있다.            아이언파이썬          아이언 파이썬(IronPython)은 닷넷(.NET) 프레임워크를 위한 파이썬 구현이다. 여기서는 파이썬 라이브러리와 닷넷 프레임워크 라이브러리를 모두 사용할 수 있으며, 파이썬 코드를 다른 닷넷 프레임워크 언어에 노출 시킬 수 있다.            파이썬넷          파이썬넷(PythonNet)은 파이썬을 위한 닷넷(Python for .NET)의 줄임말로, 파이썬과 닷넷 CLR(Common Language Runtime, 공용 언어 런타임)을 매끄럽게 통합한 패키지이다.            스컬트          스컬트(Skulpt)는 파이썬을 자바스크립트로 구현한 것이다. C파이썬의 표준 라이브러리가 모두 포팅되지는 않았으며, math, random, turtle, image, unittest time의 일부, urllib, DOM, re가 포함되어 있다.            마이크로파이썬          마이크로파이썬(MicroPython)은 마이크로 컨트롤러에서 실행되도록 최적화된 파이썬 3의 구현이며, Thumb v2명령어를 사용하는 32비트 ARM프로세서를 지원한다.      파이썬 설치하기맥에 파이썬 설치하기맥 운영체제 최신 버전에는 파이썬 2.7이 내장되어 있다. 따라서 맥에서는 파이썬을 별도로 설치하거나 설정할 필요가 없다.Setuptools와 pip홈브류는 파이썬과 함께 Setuptools와 pip도 설치한다. 설치된 pip 실행 파일은 파이썬 3 기준 pip3, 파이썬 2 기준 pip 명령어에 매핑된다.virtualenvvirtualenv는 고립된 파이썬 환경을 생성한다. 환경마다 폴더를 하나씩 만들어, 환경 내에서 패키지를 사용하는데 필요한 모든 실행 파일을 담는다.상용 파이썬 재배포판소속 부서나 수업에서 파이썬 상용 재배포판(commercial redistribution)을 설치하면, 최소한의 작업으로 모두가 일관된 환경을 사용할 수 있다. 이번 절에 나열된 재배포판은 모두 파이썬의 C 구현(C파이썬)이다.      인텔의 파이썬 배보판          인텔의 파이썬 배보판의 지향점은 누구나 무료의 고성능 파이썬을 경험하는 것이다. 인텔 수학 커널 라이브러리와 같은 기본 라이브러리를 파이썬 패키지와 연결하고, 인텔 스레딩 빌딩 블록(Threading Building Block, TBB) 라이브러리를 포함한 향상된 스레딩 기능을 제공하여 성능이 대폭 향상되었다.            컨티넘 애널리틱스의 아나콘다          컨티넘 애널리틱스의 파이썬 배포판은 BSD 라이선스로 배포되고 있으며, 무료패키지 색인에 나열된 수많은 과학/수학 바이너리가 미리 컴파일되어 제공된다. pip와는 다른 콘다(Conda)라는 패키지 관리자가 있다. 이 도구를 사용해 가상 환경도 관리할 수 있지만 가상 환경보다는 Buildout과 같은 역할을 한다. 즉, 사용자를 위해 라이브러리와 외부 의존성을 관리한다. 패키지 형식이 호환되지 않으니, 다른 인스톨러의 패키지 색인에 등록된 패키지는 설치할 수 없다.            액티브스테이트의 액티브파이썬          액티브 스테이트 배포판은 ActiveState Community Licence로 배포되며 무료 평가판이 제공된다. 그 외에는 라이선스를 구매해야 한다. 액티브 스테이트는 펄(Perl)과 Tcl을 위한 해법도 제공한다.            Enthought의 캐노피          Enthought에서 제공하는 배포판은 Canopy Software License로 공개되었다. enpkg라는 패키지 관리자와 함께 제공되는데, 캐노피의 패키지 색인과 연결되어 pip 대신 사용한다.      개발 환경텍스트 편집기      VS 코드          마이크로소프트는 2015년에 VS 코드(VS CODE)를 발표했다. 비주얼 스토디오 계열의 클로즈드 소스 무료 텍스트 편집기다. 깃허브의 일렉트론을 기반으로 작동한다. 텍스트메이트처럼 키 바인딩 기능이 있으며, 크로스 플랫폼 도구이다.      통합 개발 환경많은 개발자가 텍스트 편집기와 통합 개발 환경(integrated development environment, IDE)을 함께 사용한다. IDE는 크고 복잡한 협업 프로젝트에서 주로 사용한다.      파이참/인텔리제이 아이디어          파이참은 가장 사랑 받는 파이썬 IDE이다. 파이참의 코드 완성 도구는 거의 완벽하고, 웹 개발 도구 역시 훌륭하다. 과학 커뮤니티에서는 (웹 개발 도구가 포함되지 않은) 파이참 무료에디션도 충분히 편하다고 권하는 사람들이 있다. 파이참은 Jetbrains가 개발했다. Jetbrains는 이클립스와 경쟁하는 자바 IDE인 인텔리제이 아이디어(IntelliJ IDEA)로도 유명하다. 젯브레인(Jetbrain)에서는 파이썬 IDE로 파이참을 추천하지만, 자바와 결부된 작업, 예를 들어 자바와 파이썬 API를 통틀어 탐색을 수행하거나 자바에서 파이썬으로 포팅하는 용도로는 인텔리제이 아이디어를 추천한다.      기능이 강화된 대화형 도구IDLE은 실제로는 IDE지만, 이전 섹션에 포함되지 않았다. 대부분의 사람들이 대화형 도구가 (기업 프로젝트의 경우) IDE만큼 강력하지 않다고 여기기 때문이다. 대신, 교육용으로는 최적이다. IPython은 스파이더 IED와 통합되어 있으며, 다른 IDE에 통합 될 수도 있다. 대화형 도구는 파이썬 인터프리터를 대체하는 대신, 사용자가 선택한 인터프리터 셀을 추가 도구와 기능으로 보강한다.      IDLE                  IDLE은 통합 개발 학습 환경의 약자다. 파이썬 표준 라이브러리의 일부이며 파이썬과 함께 배포된다.                              IDLE은 다음 기능을 제공한다.                                          파이썬 셀 창(인터프리터)                                            코드에 색을 입힌 여러 창의 텍스트 편집기                                            최소한의 디버깅 능력                                                              IPython                  IPython은 파이썬 상호작용을 돕기 위한 풍부한 툴킷을 제공한다. 주요 구성 요소는 다음과 같다.                  강력한 파이썬 셀(터미널과 Qt 기반)          터미널 셀과 동일한 핵심 기능을 가진 웹 기반 노트북, 그리고 풍부한 미디어, 텍스트, 코드, 수식 표현, 화면 내 데이터 시각화를 표현                    격리도구격리도구는 실행 중인 애플리케이션과 호스트 환경을 원하는 수준으로 격리 할 수 있도록 돕는다. 격리를 통해 다양한 파이썬 버전과 라이브러리 의존성 환경에서 코드를 테스트하고 디버그 할 수 있으며, 일관된 개발 환경을 유지할 수 있다도커도커(Docker)는 virtualenv, conda, Buildhour와 같이 환경 격리를 도와주지만 가상환경을 제공하는 대신 도커 컨테이너를 제공한다. 컨테이너는 가상환경보다 높은 수준의 격리를 제공한다. 예를 들자면, 컨테이너마다 다른 네트워크 인터페이스와 방화벽 규칙, 다른 호스트 이름을 사용할 수 있다. 이렇게 실행되는 컨테이너들은 운영체제로의 액세스를 조정하는 별도의 유틸리티인 도커 엔진을 사용해 관리한다.      맥이나 윈도우, 혹은 원격 호스트에서 도커 컨테이너를 실행한다면, 가상 머신(들)과 인터페이스하는 도커 머신(Docker Machine)이 필요하다.        도커 컨테이너는 셸 명령어와 관련이 있는 리눅스 컨테이너를 기반으로 만들어졌다.        도커는 chroot를 사용하지 않으며, 리눅스 컨테이너도 사용하지 않는다.        도커 이미지를 올바르게 구성하면 Buildout 또는 conda를 사용하여 만든 환경보다 공간을 적게 차지한다. 도커가 이미지 전체를 저장하는 대신 이미지의 ‘diff’만 저장하는 AUFS 결합 파일 시스템을 사용하기 때문이다.  ",
        "url": "/blackruby-code//back/2017/12/15/Python_travel.html"
      }
      ,
    
      "back-2017-12-10-brain7-html": {
        "title": "뇌를 자극하는 파이썬 3 - Pygame으로 게임 만들기",
        "tags": "Python",
        "date": "December 10, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "Pygame으로 게임 만들기!!!pygame 소개pygame은 게임과 같은 멀티미디어 소프트웨어 개발을 위해 만들어진 파이썬 라이브러리이다. SDL(Simple DirectMedia Layer) 라이브러리를 기반으로 만들어진 pygame은 윈도우, 리눅스, 맥 등 다양한 운영체제를 지원하며, 조이스틱 입력, 그래픽 처리, 사운드 재생 등 다양한 기능을 탑재하고 있다.pygame 라이브러리 설치게임 루프게임 루프는 게임과 사용자 간의 지속적인 상호 작용을 하는 무한 루프이다. 게임이 자신의 상태를 화면에 표시하면 사용자는 표시된 상태에 따라 조이스틱이나 키보드 등을 이용해서 명령을 입력한다.게임은 이렇게 입력된 명령을 처리하고 자신의 상태를 변경한 후, 다시 사용자에게 자신의 상태를 화면에 표시한다. 게임 루프는 시작부터 끝까지 이 과정을 지속적으로 반복한다.반복 수행해야 하는 일을 정리하면 다음과 같다.      사용자 입력 처리 : 사용자가 조이스틱, 키보드를 통해 입력한 명령을 처리한다.        게임 상태 업데이트 : 주인공의 에너지, 총알 수, 위치, 적과의 충돌 여부 등을 갱신한다.        게임 상태 그리기 : 2.에서 갱신된 내용을 화면에 그려 넣는다.  pygame을 사용하는 방법pygame을 이용하는 게임 코드는 크게 다섯 부분으로 나뉜다.  pygame 관련 모듈 반입  pygame 초기화  스크린 크기 설정  게임 루프  pygame 관련 모듈 사용 자원 해제  pygame 모듈을 반입하는 것으로 시작import pygame  모듈을 반입한 후에는 pygame에 관련된 다른 기능을 사용하기 전에 pygame.init() 메소드부터 호출해야 한다. 이 메소드가 하는 일은 반입된 모든 pygame 관련 모듈을 초기화 하는 것이다.pygame.init()  그 다음에는 pygame.display.set_mode() 메소드를 호출하여 게임 스크린의 크기를 지정한다.screen = pygame.display.set_mode(400, 300))  게임 루프를 작성하기 전에 게임 루프의 주기를 결정할 pygame.time.Clock 객체를 생성한다.clock = pygame.time.Clock()  게임 루프를 작성while True:\t# 1) 사용자 입력을 처리\t# 2) 게임 상태 업데이트\t# 3) 게임 상태 그리기\tclock.tick(30)  사용자의 명령이나 게임 상태 업데이트에 의해서 게임 루프를 빠져 나오게 되면 어플리케이션이 종료되기 전에 다음과 같이 pygame.quit() 메소드를 호출한다.pygame.quit()처음 만들어보는 pygame 애플리케이션ex) 스크린의 색상이 완전히 빨간색이 되면 다시 하얀색이 되어 빨간색으로 변하기를 반복하는 예import pygamepygame.init() screen = pygame.display.set_mode((400, 300)) pygame.display.set_caption(\"Hello, pygame!\")clock = pygame.time.Clock()run = Truegb = [255, 255]# Game Loopwhile run:    # 1) 사용자 입력 처리    for event in pygame.event.get():        if event.type == pygame.QUIT:            run = False    # 2) 게임 논리 실행    if gb[0] == 0:        gb[0] = 255        gb[1] = 255    else:        gb[0] -= 1        gb[1] -= 1       # 3) 게임 장면 그리기    screen.fill(pygame.color.Color(255, gb[0], gb[1]))    pygame.display.flip()        clock.tick(60)pygame.quit()pygame에서의 사용자 입력 처리pygame에서 사용자 입력 이벤트를 담당하는 모듈은 pygame.event이다. pygame.event.get() 함수는 게임의 이벤트 큐에 있는 모든 이벤트를 순서열로 만들어 반환한다.events = pygame.event.get()ex) KEYDOWN, KEYUP + QUIT 이벤트 테스트의 예import pygamepygame.init() screen = pygame.display.set_mode((300, 100)) pygame.display.set_caption(\"Keyboard Test\")clock = pygame.time.Clock()run = Truekey_status = \"\"key = None# 게임 루프while run:    # 1) 사용자 입력 처리    for event in pygame.event.get():        if event.type == pygame.QUIT:            run = False        elif event.type == pygame.KEYDOWN:            key_status = \"Key Down\"            key = event.key        elif event.type == pygame.KEYUP:            key_status = \"Key Up\"            key = event.key                # 2) 게임 상태 업데이트           # 3) 게임 상태 그리기    screen.fill(pygame.color.Color(255, 255, 255))        if key != None:        pygame.display.set_caption(            pygame.key.name(key) + \" \" + key_status)        pygame.display.flip()        clock.tick(60)pygame.quit()스페이스 키가 눌러져 있는지를 알고 싶을 때는 다음과 같이 pygame.key.get_pressed() 함수가 반환한 튜플에 해당 키를 나타내는 상수(pygame.K_SPACE)을 첨자로 넘기면 된다.keys = pygame.key.get_pressed()if keys[pygame.K_SPACE]:\tprint(\"스페이스 키 눌렀음\")ex) 커서 키가 눌러져 있는지를 감시하고 현재 눌러져 있는 키의 이름을 출력하는 예import pygamepygame.init() screen = pygame.display.set_mode((300, 100)) pygame.display.set_caption(\"Keyboard Test2\")clock = pygame.time.Clock()run = Truekey_status = \"\"key = None# 게임 루프while run:    # 1) 사용자 입력 처리    for event in pygame.event.get():        if event.type == pygame.QUIT:            run = False    # 누르고 있는 키 확인하기.    keys = pygame.key.get_pressed()     if keys[pygame.K_LEFT]:        print(\"LEFT\")    elif keys[pygame.K_RIGHT]:        print(\"RIGHT\")    elif keys[pygame.K_UP]:        print(\"UP\")    elif keys[pygame.K_DOWN]:        print(\"DOWN\")            # 2) 게임 상태 업데이트           # 3) 게임 상태 그리기    screen.fill(pygame.color.Color(255, 255, 255))        if key != None:        pygame.display.set_caption(            pygame.key.name(key) + \" \" + key_status)        pygame.display.flip()        clock.tick(60)pygame.quit()pygame으로 그리기텍스트 그리기pygame으로 텍스트를 그릴 때는 pygame.font.SysFont 클래스를 이용한다.# 1) Sysfont 생성자에 폰트명과 크기를 입력sf = pygame.font.SysFont(\"Monospace\", 20)# 2) SysFont.render 메소드가 하는 일은 텍스트를 그려넣은 Surface 객체를 반환하는 것.#\t이 메소드의 1번째 매개변수는 출력할 텍스트,# \t2번째 매개변수는 안티알리아싱(Anti-aliasing) 여부,# \t3번째 매개변수는 텍스트의 색상text = sf.render(\"Hello, World\", True, (0,0,255))# 3) Surface.blit() 메소드는 다른 Surface 객체를 자신에게 그려넣는 일을 한다. # \t이 메소드의 1번째 매개변수는 그려넣을 Surface 객체, # \t2번째 매개변수에 해당 Surface 객체를 그려넣을 좌표screen.blit(text, (10,10)) 도형 그리기pygame.draw 모듈에는 다양한 도형 그리기 함수가 있다.ex) 도형 그리기의 예import pygamepygame.init() screen = pygame.display.set_mode((300, 100)) pygame.display.set_caption(\"Drawing Shapes\")clock = pygame.time.Clock()run = Truekey = Nonestart_pos = [0, 0]# 게임 루프while run:    # 1) 사용자 입력 처리    for event in pygame.event.get():        if event.type == pygame.QUIT:            run = False        elif event.type == pygame.KEYDOWN:            key = event.key                # 2) 게임 상태 업데이트        if start_pos[0] &gt; screen.get_width():        start_pos[0] = 0    else:        start_pos[0] += 1        # 3) 게임 상태 그리기    screen.fill(pygame.color.Color(255, 255, 255))        if key == pygame.K_1:        pygame.draw.line(screen,             pygame.color.Color(0, 0, 0),             start_pos,             (screen.get_width(), screen.get_height()), 1)    elif key == pygame.K_2:        pygame.draw.ellipse(screen,            pygame.color.Color(255, 0, 0),             pygame.Rect(start_pos, (50, 50)))    elif key == pygame.K_3:        pygame.draw.polygon(screen,            pygame.color.Color(0, 255, 0),             [start_pos,              (0, screen.get_height()),              (screen.get_width(), screen.get_height())])    elif key == pygame.K_4:        pygame.draw.rect(screen,            pygame.color.Color(0, 0, 255),             pygame.Rect(start_pos, (50, 50)))        pygame.display.flip()        clock.tick(60)pygame.quit()이미지 그리기pygame.image.load() 함수는 이미지 파일을 읽어 들여 Surface 객체를 만들어 반환한다.# load() 함수는 이미지 파일로부터 Surface 객체를 반환img = pygame.image.load(\"image.png\")# img 객체가 그려질 위치와 크기를 나타내는 pygame.Rect 객체를 반환.rect = img.get_rect()while True:\tscreen.blit(img, rect) # Surface.blit() 메소드를 이용해 img 객체를 그린다.pygame으로 오디오 재생하기pygame.mixer.Sound 클래스는 오디오를 재생하는 기능을 가지고 있으며, OGG 또는 압축하지 않은 WAV 형식의 오디오 파일을 지원한다.# Sound 생성자에 오디오 파일 경로를 입력fire_sound = pygame.mixer.Sound('fire.ogg')# play() 메소드는 오디오 파일을 재생한다.fire_sound.play()# stop() 메소드는 오디오 파일의 재생을 중지시킨다.fire_sound.stop()스프라이트의 이해스프라이트(Sprite)는 다른 이미지와 합성하기 위해 사용하는 이미지나 애니메이션을 말한다. “게임 화면 내에서 움직이는 물체”라고 생각해도 된다.  스프라이트를 사용하면 더 작은 용량으로 더 작은 메모리로 객체의 상태 변화나 객체들 간의 충동 처리 등이 용이하게 구현 가능하다.pygame.sprite.Sprite와 pygame.sprite.Group다음은 Sprite 클래스가 제공하는 메소드의 목록이다.            메소드      기능                  update()      객체의 상태를 업데이트 한다.              add()      스프라이트를 그룹에 추가한다.              remove()      스프라이트를 그룹에서 제거한다.              kill()      스프라이트가 속해 있는 모든 그룹에서부터 스프라이트를 제거한다.              alive()      스프라이트가 한 그룹에라도 속해있는지의 여부를 반환한다.              groups()      스프라이트가 속해 있는 모든 그룹을 반환한다.        Sprite의 파생 클래스는 다음의 사항을 만족해야 한다.  스프라이트 객체를 그룹에 추가하기 전에 Sprite.init() 메소드를 호출해야 한다.  pygame.Surface 형식의 image 데이터 속성을 할당해둬야 한다.  pygame.Rect 형식의 rect 데이터 속성을 할당해둬야 한다.  update() 메소드를 오버라이드 해야 한다.다음의 예제에서는 Sprite 클래스의 상속 조건 4가지를 만족시키는 Runner 클래스를 정의한다.ex) Sprite_Runner의 예import pygamefrom pygame.color import Colorfrom pygame.sprite import Spritefrom pygame.surface import Surfaceclass Runner(Sprite):    def __init__(self):        Sprite.__init__(self)        self.sprite_image = 'runnersprite.png'        self.sprite_width = 70        self.sprite_height = 100         self.sprite_sheet = pygame.image.load(                                self.sprite_image).convert()        self.sprite_columns = 14        self.current_frame = 0        self.image = Surface((self.sprite_width, self.sprite_height))        rect = (self.sprite_width*self.current_frame, 0,                 self.sprite_width, self.sprite_height)        self.image.blit( self.sprite_sheet, (0, 0), rect)        self.image.set_colorkey(Color(255, 0, 255))        self.rect = self.image.get_rect()           def update(self):        if self.current_frame == self.sprite_columns - 1:            self.current_frame = 0        else:            self.current_frame += 1        rect = (self.sprite_width*self.current_frame, 0,                 self.sprite_width, self.sprite_height)        self.image.blit( self.sprite_sheet, (0, 0), rect)ex) 애니메이션 효과 연출의 예import pygamefrom pygame.color import Colorfrom runner import RunnerFPS = 28if __name__ == \"__main__\":     pygame.init()     size = (400, 300)    screen = pygame.display.set_mode(size)     pygame.display.set_caption(\"Runner Animation\")     run = True    clock = pygame.time.Clock()    background_img = pygame.image.load(\"background.png\")        runner1 = Runner()    runner1.rect.x = 0    runner1.rect.y = 170    # 게임 루프    while run:        # 1) 사용자 입력 처리        for event in pygame.event.get():            if event.type == pygame.QUIT:                run = False        # 2) 게임 상태 업데이트              runner1.update()        # 3) 게임 상태 그리기        screen.blit(background_img, screen.get_rect())        screen.blit(runner1.image, runner1.rect)        pygame.display.flip()         clock.tick(FPS)            pygame.quit()  Sprite 클래스는 pygame.sprite.Group 클래스와 함께 사용하도록 고안되었다. Group은 Sprite 객체의 컨테이너 기능을 하는 클래스이다.다음은 Group 클래스의 메소드 목록이다.            메소드      기능                  sprites()      이 그룹에 소속되어 있는 모든 스프라이트의 목록을 반환한다.              copy()      그룹을 복사한다.              add()      스프라이트를 그룹에 추가한다.              remove()      스프라이트를 그룹에서 제거한다.              has()      그룹이 특정 스프라이트를 갖고 있는지 확인한다.              update()      그룹에 소속되어 있는 모든 스프라이트 객체의 update() 메소드를 호출한다.              draw()      그룹에 소속되어 있는 각 스프라이트 객체의 image 데이터 속성과 rect 데이터 속성을 매개변수로 Surface.blit() 메소드를 호출한다.              clear()      그룹이 갖고 있는 스프라이트 위로 배경을 그린다.              empty()      모든 스프라이트를 그룹에서 제거한다.      스프라이트간의 충돌 처리pygame.sprite.groupcollide() 함수는 스프라이트 그룹간의 충돌 여부를 평가하고, 충돌이 일어난 스프라이트 객체를 자동으로 그룹에서 제거해준다. 게다가 어떤 스프라이트에 충돌이 발생했는지를 dict 객체에 담아 출력해주기까지 한다.while True: # 게임 루프\tcollided = pygame.sprite.groupcollide(group1, group2, False, True)\tfor item collide.items():\t\tprint(item)투석기 게임게임 컨셉 및 구조이 문제는 16세기에 갈릴레오가 해결을 해주었다. 던져진 물체는 포물선 운동을 한다는 사실을 갈릴레오가 밝혀내고 이것을 이론으로 정리해놨기 때문이다.  포물선 운동 공식을 적용해야 한다.게임에 사용할 상수 정의ex) 상수 정의의 예g = 0.7BASE_Y = 250CATAPULT_READY = 0CATAPULT_FIRE = 1STONE_READY = 0STONE_FLY = 1MIN_POWER = 1MAX_POWER = 20MIN_DIRECTION = 20MAX_DIRECTION = 85GAME_INIT = 0GAME_PLAY = 1GAME_CLEAR = 2GAME_OVER = 3스프라이트 클래스 정의: 배경, 투석기, 돌, 외계인, 폭발게임에 사용할 스프라이트의 부모 클래스Animation 클래스는 두 가지 메소드를 구현한다. 하나는 init_animation() 메소드로, 스프라이트 시트 파일을 읽어 들이고 FPS에 따른 프레임 변경 시간 등을 초기화한다.또 다른 하나는 calc_next_frame() 메소드이다. 이 메소드는 시간이 얼마나 지났는지를 보고 애니메이션 프레임을 전환할지를 결정한다.ex) Animation 클래스 구현의 예import pygamefrom pygame import Surfacefrom pygame.color import Colorfrom pygame.sprite import Spriteclass Animation(Sprite):    def init_animation(self):        Sprite.__init__(self)        self.sprite_sheet = pygame.image.load(self.sprite_image).convert()        self.current_frame = 0        self.image = Surface((self.sprite_width, self.sprite_height))        rect = (self.sprite_width*self.current_frame, 0,                 self.sprite_width, self.sprite_height)        self.image.blit( self.sprite_sheet, (0, 0), rect)        self.image.set_colorkey(Color(255, 0, 255))        self.rect = self.image.get_rect()                self.elapsed = pygame.time.get_ticks()        self.threshold =  1000/self.fps     def calc_next_frame(self):       tick = pygame.time.get_ticks()       if tick - self.elapsed &gt; self.threshold:           self.elapsed = tick           if self.current_frame == self.sprite_columns:               self.current_frame = 0           else:               self.current_frame += 1Stone 스프라이트 클래스Stone 스프라이트 클래스는 투석기가 던지는 돌을 표현한다. Stone 스프라이트 애니메이션의 각프레임 크기는 8픽셀이며 총 프레임의 수는 4개이다.Stone 객체는 발사되기 전에는 STONE_READY 상태를 갖고 있다가, 사용자가 투석기에게 발사 명령을 내리면 setup() 메소드를 통해 초기 발사 파워(power), 발사각(direction), 발사 위치(initial_pos)를 객체에 저장한 후 상태를 STONE_FLY로 변경 한다.STONE_FLY 상태가 된 Stone 객체는 게임 루프가 호출하는 move() 메소드를 통해 외계인을 향해 날아간다. 이 때 Stone의 위치가 게임 화면을 벗어나면 상태를 다시 STONE_READY로 돌려 발사 준비 상태로 돌아간다.ex) Stone 클래스의 구현의 예import mathimport pygamefrom pygame.color import Colorfrom animation import Animationfrom const import *class Stone(Animation):    # STATE : STONE_READY -&gt; STONE_FLY    #           ^---------------|    # READY일 때만 이동 가능    # FIRE일 때는 아무것도 못함.    def __init__(self):        self.sprite_image = 'stone.png'        self.sprite_width = 8        self.sprite_height = 8        self.sprite_columns = 4        self.fps = 20        self.state = STONE_READY        self.init_animation()                   def update(self):         # 돌은 투석기가 발사한 이후부터 목표 또는         # 지면에 충돌할 때까지 날기만 하므로        # 상태에 따른 스프라이트 정지 등은 필요 없음.        self.calc_next_frame()                        rect = (self.sprite_width*self.current_frame, 0,                 self.sprite_width, self.sprite_height)        self.image.blit( self.sprite_sheet, (0, 0), rect)        self.image.set_colorkey(Color(255, 0, 255))    def setup(self, initial_pos, power, direction):        self.initial_pos = initial_pos        self.rect.x = initial_pos[0]        self.rect.y = initial_pos[1]        self.power = power        self.direction = direction        self.state = STONE_FLY    def move(self, time, space, decrement_stones):        pos = self.calculate_position(time, g, self.direction)        pos = self.map_position(            self.initial_pos[0], self.initial_pos[1],             pos[0], pos[1])        self.rect.x = pos[0]        self.rect.y = pos[1]        if pos[0] &gt; space[0] or pos[1] &gt; space[1]:            self.state = STONE_READY            decrement_stones()    # 포탄 위치 계산    def calculate_position(self, t, g, direction):        r = math.radians(direction)        x = self.power*math.cos(r)*t        y = self.power*math.sin(r)*t - 0.5*g*math.pow(t, 2)        return (int(x), int(y))    # 포탄의 위치를 화면 좌표에 맞게 변환    def map_position(self, x, y, new_x, new_y):        return (x + new_x, y + (new_y*-1))Catapult 스프라이트 클래스 정의Catapult 클래스는 투석기를 앞/뒤로 이동시키는 forward()/backward() 메소드와 돌을 발사하는 fire() 메소드를 갖고 있다. fire() 메소드는 게임 루프로부터 발사 파워와 발사각을 입력 받아 데이터 속성에 저장하고 Catapult 객체의 상태를 CATAPULT_READY로 변경한다. 그 다음 update() 메소드가 호출될 때 이 상태를 확인하고 발사 애니메이션을 실행한다.발사 애니메이션의 끝에 도달하면 Catapult 객체의 상태는 다시 CATAPULT_READY로 돌아가고, stone 객체의 setup() 메소드를 호출함으로써 돌이 날아가도록 만든다. setup() 메소드를 호출받은 stone 객체의 상태는 STONE_FLY로 바뀌어 외계인을 향해 비행을 시작한다.ex) Catapult 클래스 구현의 예import pygamefrom pygame.color import Colorfrom animation import Animationfrom stone import Stonefrom const import *class Catapult(Animation):    # STATE : CATAPULT_READY -&gt; CATAPULT_FIRE    #           ^------|    # READY일 때만 이동 가능    # FIRE일 때는 아무것도 못함.    def __init__(self, stone):        self.sprite_image = 'catapult.png'        self.sprite_width = 32        self.sprite_height = 32        self.sprite_columns = 5        self.fps = 30        self.stone = stone        self.state = CATAPULT_READY        self.init_animation()    def update(self):         if self.state == CATAPULT_FIRE:            self.calc_next_frame()            if self.current_frame == self.sprite_columns:                self.current_frame = 0                # 돌멩이 날리기 시작                self.state = CATAPULT_READY                self.stone.setup(                    (self.rect.x, self.rect.y),                     self.power, self.direction)        else:            self.current_frame = 0                        rect = (self.sprite_width*self.current_frame, 0,                 self.sprite_width, self.sprite_height)        self.image.blit( self.sprite_sheet, (0, 0), rect)        self.image.set_colorkey(Color(255, 0, 255))    def forward(self):        if self.rect.x &lt; 100:            self.rect.x += 1    def backward(self):        if self.rect.x &gt; 0:            self.rect.x -= 1    def fire(self, power, direction):        self.state = CATAPULT_FIRE        self.power = power        self.direction = directionAlien 스프라이트 클래스 정의Alien 클래스는 우리의 적인 외계인 스프라이트를 표현한다!Alien 클래스는 숨 쉬는 것 말고는 특별한 기능을 갖고 있지 않다.ex) Alien 클래스 구현의 예from pygame.color import Colorfrom animation import Animationclass Alien(Animation):    def __init__(self):        self.sprite_image = 'alien.png'        self.sprite_width = 32        self.sprite_height = 32        self.sprite_columns = 3        self.fps = 10        self.init_animation()                   def update(self):         self.calc_next_frame()        rect = (self.sprite_width*self.current_frame, 0,                 self.sprite_width, self.sprite_height)        self.image.blit( self.sprite_sheet, (0, 0), rect)        self.image.set_colorkey(Color(255, 0, 255))Explosion 스프라이트 클래스 정의Explosion 클래스는 폭발 애니메이션을 구현한다. 돌과 외계인이 충돌 했을 때 사용된다.ex) Explosion 클래스 구현의 예from pygame.color import Colorfrom animation import Animationclass Explosion(Animation):    def __init__(self):        self.sprite_image = 'explosionsprite.png'        self.sprite_width = 100        self.sprite_height = 100         self.sprite_columns = 25        self.fps = 16        self.init_animation()           def update(self):         self.calc_next_frame()        if self.current_frame == self.sprite_columns:            self.current_frame = 0            self.kill()                rect = (self.sprite_width*self.current_frame, 0,                 self.sprite_width, self.sprite_height)        self.image.blit( self.sprite_sheet, (0, 0), rect)        self.image.set_colorkey(Color(255, 0, 255))메인 모듈(게임 루프)ex) 메인 모듈 구현의 예import mathimport pygamefrom pygame import drawfrom pygame.color import Colorfrom pygame.sprite import Spritefrom catapult import Catapultfrom stone import Stonefrom alien import Alienfrom explosion import Explosionfrom const import *FPS = 60stone_count = 3def decrement_stones():    global stone_count    stone_count -= 1class Background(Sprite):    def __init__(self):                self.sprite_image = 'background.png'        self.image = pygame.image.load(                self.sprite_image).convert()        self.rect = self.image.get_rect()        self.rect.x = 0        self.dx = 1        Sprite.__init__(self)            def update(self):        self.rect.x -= self.dx        if self.rect.x == -800:            self.rect.x = 0if __name__ == \"__main__\":     pygame.init()     size = (400, 300)    screen = pygame.display.set_mode(size)     pygame.display.set_caption(\"Catapult VS Alien\")     run = True    clock = pygame.time.Clock()    t = 0    fire_sound = pygame.mixer.Sound('fire.ogg')    crash_sound = pygame.mixer.Sound('crash.ogg')    power = 15    direction = 45        game_state = GAME_INIT    background = Background()    background_group = pygame.sprite.Group()    background_group.add(background)        stone = Stone()     stone.rect.y = -100   # 위치 변경    stone_group = pygame.sprite.Group()    stone_group.add(stone)    catapult = Catapult(stone)        catapult.rect.x = 50 # 위치 변경                           catapult.rect.y = BASE_Y    catapult_group = pygame.sprite.Group()    catapult_group.add(catapult)    alien = Alien()    alien.rect.x = 350    alien.rect.y = BASE_Y    alien_group = pygame.sprite.Group()    alien_group.add(alien)        explosion = Explosion()    explosion_group = pygame.sprite.Group()    explosion_group.add(explosion)    # 게임 루프    while run:        # 1) 사용자 입력 처리        for event in pygame.event.get():            if event.type == pygame.QUIT:                run = False            elif event.type == pygame.KEYUP:                if event.key == pygame.K_SPACE:                    # 초기화면에서 스페이스를 입력하면 시작                    if game_state == GAME_INIT:                         game_state = GAME_PLAY                    elif game_state == GAME_PLAY:                         # GAME_PLAY 상태일 때 스페이스를 입력하면 발사                        if stone.state == STONE_READY:                            t = 0                            catapult.fire(power, direction)                            fire_sound.play()        if game_state == GAME_PLAY:            # 누르고 있는 키 확인하기.            keys = pygame.key.get_pressed()              if keys[pygame.K_LEFT]:                catapult.backward()            elif keys[pygame.K_RIGHT]:                catapult.forward()            elif keys[pygame.K_UP]:                if direction &lt; MAX_DIRECTION:                    direction += 1            elif keys[pygame.K_DOWN]:                if direction &gt; MIN_DIRECTION:                    direction -= 1                elif keys[pygame.K_SPACE]:                if power &gt; MAX_POWER:                    power = MIN_POWER                else:                    power += 0.2        # 2) 게임 상태 업데이트        if stone.state == STONE_FLY:            t += 0.5            stone.move(t,                        (screen.get_width(), screen.get_height()),                        decrement_stones)                if alien.alive():            collided = pygame.sprite.groupcollide(                        stone_group, alien_group, False, True)            if collided:                explosion.rect.x = \\                    (alien.rect.x + alien.rect.width/2) - \\                     explosion.rect.width/2                explosion.rect.y = \\                    (alien.rect.y + alien.rect.height/2) - \\                    explosion.rect.height/2                crash_sound.play()        elif not explosion.alive():             # 외계인도 죽고 폭발 애니메이션도 끝났을 때.            game_state = GAME_CLEAR               # 외계인이 살아 있는데 돌멩이 수가 0이면 게임 오버.        if alien.alive() and stone_count == 0:            game_state = GAME_OVER        if game_state == GAME_PLAY: # 게임 객체 업데이트            catapult_group.update()            stone_group.update()            alien_group.update()                # 3) 게임 상태 그리기        background_group.update()        background_group.draw(screen)                        if game_state == GAME_INIT:             # 초기화면            sf = pygame.font.SysFont(\"Arial\", 20, bold=True)            title_str = \"Catapult VS Alien\"            title = sf.render(title_str, True, (255,0,0))            title_size = sf.size(title_str)            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)                        sub_title_str = \"Press [Space] Key To Start\"            sub_title = sf.render(sub_title_str, True, (255,0,0))            sub_title_size = sf.size(sub_title_str)            sub_title_pos = (screen.get_width()/2 - sub_title_size[0]/2, 200)            screen.blit(title, title_pos)            screen.blit(sub_title, sub_title_pos)        elif game_state == GAME_PLAY:             # 플레이 화면            catapult_group.draw(screen)            stone_group.draw(screen)             alien_group.draw(screen)            # 파워와 각도를 선으로 표현.            line_len = power*5             r = math.radians(direction)                    pos1 = (catapult.rect.x+32, catapult.rect.y)            pos2 = (pos1[0] + math.cos(r)*line_len,                     pos1[1] - math.sin(r)*line_len)            draw.line(screen,Color(255, 0, 0), pos1, pos2)                             # 파워와 각도를 텍스트로 표현.            sf = pygame.font.SysFont(\"Arial\", 15)            text = sf.render(\"{0} °, {1} m/s\".                             format(direction, int(power)), True, (0,0,0))            screen.blit(text, pos2)            # 돌의 개수를 표시            sf = pygame.font.SysFont(\"Monospace\", 20)            text = sf.render(\"Stones : {0}\".                             format(stone_count), True, (0,0,255))            screen.blit(text, (10, 10))            if not alien.alive():                explosion_group.update()                explosion_group.draw(screen)        elif game_state == GAME_CLEAR:             # 게임 클리어            sf = pygame.font.SysFont(\"Arial\", 20, bold=True)            title_str = \"Congratulations! Mission Complete\"            title = sf.render(title_str, True, (0,0,255))            title_size = sf.size(title_str)            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)            screen.blit(title, title_pos)        elif game_state == GAME_OVER:             # 게임 오버            sf = pygame.font.SysFont(\"Arial\", 20, bold=True)            title_str = \"Game Over\"            title = sf.render(title_str, True, (255,0,0))            title_size = sf.size(title_str)            title_pos = (screen.get_width()/2 - title_size[0]/2, 100)            screen.blit(title, title_pos)        pygame.display.flip()         clock.tick(FPS)     pygame.quit()",
        "url": "/blackruby-code//back/2017/12/10/brain7.html"
      }
      ,
    
      "back-2017-12-10-brain6-html": {
        "title": "뇌를 자극하는 파이썬 3 - 파이썬으로 이미지 요리하기",
        "tags": "Python",
        "date": "December 10, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "파이썬으로 이미지 요리하기이미지 매직이미지 매직(Image Magick)은 포토샵 같은 이미지 편집 소프트웨어 이다. GUI를 갖고 있는 포토샵과는 달리 이미지 매직은 명령 프롬프트에서 실행하는 것이 특징이다. 이미지 매직은 형식 변환, 이미지 회전, 도형 그리기, 텍스트 출력, 이미지간 합성, 이미지 자르기, 크기 변환 등등 이미지 편집에 필요한 다양한 기능을 제공한다.Wand: 이미지 매직 파이썬 API 라이브러리Wand는 깔끔한 인터페이스를 제공하는 이미지 매직용 파이썬 라이브러리이다.Wand 설치&gt; pip install WandWand를 이용한 이미지 편집Wand를 이용한 이미지 편집 프로그래밍도 관련 모듈을 코드에 반입하는 것으로 시작된다. 주로 사용할 모듈은 wand.image이다. 이 모듈 안에서도 특히 Image 클래스를 주로 사용한다.            기능      메소드 이름                  파일 형식 바꾸기      image.convert()              크기 바꾸기      image.resize()              이미지 자르기      슬라이스 연산자.              이미지 회전      image.retate()              이미지 뒤집기      image.flip() # 상하 뒤집기, image.flop() # 좌우 뒤집기              이미지 명도, 채도, 색상 변경하기      image.modulate()              이미지 합성      image.composite()              워터 마크      image.watermark()        이미지 도형이나 텍스트를 그려 넣을 때는 image.drawing 모듈의 Drawing 클래스도 함께 사용한다.            기능      메소드 이름                  이미지에 텍스트와 도형 넣기      Drawing.line(), Drawing.rectangle(), Drawing.text(), Drawing.draw()      이미지 파일 형식 바꾸기이미지 파일 형식을 바꿀 때에는 wand.Image 클래스의 convert() 메소드를 사용한다.convert() 메소드는 새 이미지 형식의 이름을 매개변수로 입력받는다.이미지 크기 바꾸기이미지의 크기를 바꿀 때에는 resize() 메소드를 이용한다. resize() 메소드는 다음과 같이 재조정할 이미지의 너비와 높이를 매개변수로 입력받는다.with Image(filename=original_path) as image:\timage.resize(100, 50) # 어떤 이미지건 너비 100, 높이 50으로 크기 변경이미지 자르기이미지 자르기를 위한 슬라이스 연산자([])는 다음과 같이 사용하며, (x1, y1)과 (x2, y2) 좌표로 이루어지는 사각형 영역을 잘라낸다.cropped = image[x1:y1, x2:y2]이미지 회전이미지 회전은 Image 클래스의 rotate() 메소드를 이용한다. rotate()의 매개변수는 두 가지이다. 하나는 회전 각도이고 하나는 이미지를 회전시켰을 때 남는 공간에 채워넣을 색상이다.rotated.rotate(degree, background=Color(bgcolor))이미지 뒤집기이미지를 상하로 뒤집을 때는 flip() 메소드를, 좌우로 뒤집을 때는 flop() 메소드를 사용한다.with Image(filename=original_path) as image:\timage.flip() # 상하 뒤집기\timage.flop() # 좌우 뒤집기이미지에 텍스트와 도형 넣기텍스트와 도형을 그려 넣을 때는 wand.drawing.Drawing 클래스의 도움이 필요하다. Drawing 클래스를 사용하는 방법은 먼저 wand.drawing 모듈부터 Drawing 클래스를 반입한다. Image 클래스도 반입해야 한다.from wand.drawing import Drawingfrom wand.image im\u0010port Image  그 다음에는 Image와 Drawing의 인스턴스를 생성한다.with Image(filename=original_path) as image:\twith Drawing() as draw:이미지의 명도, 채도, 색상 변경하기모든 색은 명도, 채도, 색상 이렇게 세 가지 속성을 가진다.ex) testimport sysfrom wand.image import Imageif len(sys.argv) &lt; 5:    print('{0} &lt;ORIGINAL PATH&gt; &lt;BRIGHTNESS&gt; &lt;SATURATION&gt; &lt;HUE&gt;'          .format(sys.argv[0]))    sys.exit()original_path = sys.argv[1]brightness = float(sys.argv[2])saturation = float(sys.argv[3])hue = (float(sys.argv[4]) * 100 / 180 ) + 100 with Image(filename=original_path) as image:    with image.clone() as clone:        clone.modulate(brightness, saturation, hue)         clone.save(filename= 'modulated_' + original_path)이미지 합성이미지의 합성은 Image 객체의 composite() 메소드로 수행 가능하다.image1.composite(image2, 100, 100) # image1 위의 (100, 100) 위치에 image2를 합성      한쪽 이미지를 약간 투명하게 만들어서 더 자연스럽게 합성하고 싶다면, 이미지를 투명하게 만들 때에는 Image 객체의 transparentize() 메소드를 이용한다. transparentize() 메소드는 투명도를 0에서 1사이의 값으로 입력받는다.        다음과 같이 transparentize() 메소드에 0.7을 매개변수로 입력하여 호출하면 해당 이미지의 투명도를 70%로 변환한다.  image2.transparentize(0.7)ex) 두개의 이미지를 사용자로부터 입력받고 그 중 하나를 70% 투명도로 다른 이미지 위에 합성하는 예import sysfrom wand.image import Imageif len(sys.argv) &lt; 3:    print('{0} &lt;Image 1&gt; &lt;Image 2&gt;'.format(sys.argv[0]))    sys.exit()image1_path = sys.argv[1]image2_path = sys.argv[2]with Image(filename=image1_path) as image1:    with Image(filename=image2_path) as image2:        with image1.clone() as clone:            image2.transparentize(0.7)            clone.composite(image2, 100, 100)            clone.save(filename= image1_path + \"_\" + image2_path)워터마크Image 클래스에는 composite() 메소드와 transparentize() 메소드의 기능을 한꺼번에 수행하는 메소드가 있는데, 바로 watermark()이다!  watermark() 메소드의 첫 번째 매개변수는 합성할 Image 객체, 두 번째 매개변수는 투명도, 세 번째와 네 번째 매개변수는 각각 합성할 이미지의 x,y 좌표를 나타낸다.ex) watermark() 메소드 예import sysfrom wand.image import Imageif len(sys.argv) &lt; 3:    print('{0} &lt;Image 1&gt; &lt;Image 2&gt;'.format(sys.argv[0]))    sys.exit()image1_path = sys.argv[1]image2_path = sys.argv[2]with Image(filename=image1_path) as image1:    with Image(filename=image2_path) as image2:        with image1.clone() as clone:            clone.watermark(image2, 0.7, 100, 100)            clone.save(filename= image1_path + \"_\" + image2_path)",
        "url": "/blackruby-code//back/2017/12/10/brain6.html"
      }
      ,
    
      "back-2017-12-10-brain5-html": {
        "title": "뇌를 자극하는 파이썬 3 - SQLite",
        "tags": "Python",
        "date": "December 10, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "SQLite데이터베이스에 대해데이터베이스(Database)는 자료를 저장하고 저장된 자료를 다시 운용하기 위한 목적으로 구축된 시스템이다.데이터베이스는 간단한 가계부에서부터 기업에서 사용하는 경영정보 시스템에 이르기까지 다양한 분야와 폭넓은 범위에 걸쳐 사용될 정도로 중요한 분야이다.데이터베이스의 역사태초에 ‘데이터’가 있었더라사람들이 데이터베이스를 생각해 내기전, 아니 컴퓨터라는 기계를 생각해 내기 훨씬 이전부터 데이터는 존재했었다. 아주 옛날 진흙판에 동그라미를 찍어 수를 표시하던 것에서부터 종이를 이용하여 기록할 때까지, 그 매체는 다르지만 사람들은 데이터를 잃어버리지 않기 위해 끊임없이 기록을 해왔다.계층형/네트워크형 데이터베이스늘어나는 데이터와 산업 전반에 걸쳐 거대해지는 시스템에 대응 하는 데이터 처리 방법을 연구하던 사람들은 ‘데이터 모델(Data Model)’이라는 도구를 사용하기 시작했고, 이것은 현실세계의 데이터를 다시 논리적으로 정의하고 표현하는 방법으로, 사람들은 이 기법을 통해 더욱 논리적인 데이터 베이스 시스템을 가질 수 있게 되었다. 이러한 모델링 기법을 이용한 초창기의 데이터베이스가 계층형, 네트워크형 데이터베이스이다!관계형 데이터베이스현재 가장 일반적으로 사용되는 데이터베이스 시스템이다. 관계형 데이터베이스는 데이터의 구조를 테이블(Table), 즉 표의 형태로 구성한다. SQLite가 바로 이 관계형 데이터베이스에 해당한다.DBMSDBMS(Database Management System)는 데이터베이스의 역할(데이터를 저장하고 이를 운용하게 하는 것)그 자체를 수행하는 소프트웨어를 말한다. Oracle, SQLServer 그리고 MySQL, 그리고 SQLite가 바로 이 DBMS이다.관계형 데이터베이스의 기본구조관계형 데이터베이스는 데이터베이스가 여러 개의 테이블을 소유하는 형식으로 구성된다. 각 테이블은 실제 데이터를 담고 있는데, 데이터가 담기는 구조는 ‘표’형태로 이루어져 있다. 해당 표의 속성이 담긴 열은 ‘필드(field)’라고 하고, 실제 데이터를 이루는 각 행은 ‘레코드’라고 한다.SQL 익히기SQL은 데이터베이스와 테이블의 생성과 수정, 삭제 기능부터 데이터의 검색, 추가, 삭제, 수정 등의 데이터 처리 기능을 모두 수행할 수 있다.테이블의 생성: CREATE TABLE레코드를 추가하고 조회하는 등의 작업을 하려면 테이블이 있어야 한다.CREATE TABLE문은 각 필드의 자료형과 크기 등으로 구성된 테이블의 구조(이것을 스키마(Schema)라고 한다)를 매개변수로 하여 테이블을 생성하며, 다음과 같은 형식으로 사용한다.CREATE TABLE &lt;테이블&gt; ( 필드1 필드형식1, 필드2 필드형식2, ... )레코드 추가: INSERT 문INSERT 문은 레코드를 테이블에 추가할 때 사용한다.INSERT INTO &lt;테이블&gt; ([필드1, 필드2, ...]) VALUE([데이터1, 데이터2, ...])레코드 조회: SELECT 문SELECT 문의 기본적인 구조는 아래의 형식과 같다. 우리말로 해석하면 “에서 를 선택하라.\"라는 뜻이 된다.SELECT &lt;필드&gt; FROM &lt;테이블&gt;WHERE: 특정 조건의 레코드에 대해 작업WHERE 절은 SELECT 문에 조건을 한정하는 기능을 한다. WHERE 절은 아래와 같이 SELECT 문 뒤에 붙여서 사용한다.&lt;SELECT 문 ...&gt; WHERE &lt;조건&gt;ORDER BY: 조회 결과의 정렬ORDER BY 절은 조회 결과가 여러 레코드로 구성되어 있을 경우, 이를 특정한 기준으로 정렬해 준다. WHERE절과 마찬가지로 SELECT문 뒤에 붙여서 사용한다.sqlite&gt; SELECT * FROM PHONEBOOK ORDER NAME ASC:윤경한|010-1111-1111|zizou0812@gmail.com윤경한1|010-1111-1111|zizou0812@gmail.com윤경한2|010-1111-1111|zizou0812@gmail.com레코드 수정: UPDATE 문UPDATE문은 테이블에 이미 존재하는 레코드의 특정 필드를 수정할 때 사용한다.UPDATE &lt;테이블&gt; Set [필드1]=[데이터1], [필드2]=[데이터2], ... WHERE [조건]레코드 삭제: DELETE 문DELETE 문은 레코드를 삭제할 때 사용한다. DELETE문은 모든 SQL 구문 중에서 가장 간단하다고 할 수 있다.DELETE FROM &lt;테이블&gt; WHERE [조건]SQLite의 파이썬 API파이썬3에는 SQLite 라이브러리가 기본 탑재되어 있다. 다음과 같이 import문으로 sqlite3모듈을 반입하면 SQLite API를 사용할 준비가 끝난것이다.import sqlite3커넥션 열고 닫기커넥션은 sqlite.connect() 함수를 이용해 생성한다. connect() 함수에는 데이터베이스 파일의 경로를 매개변수로 입력한다import sqlite3conn = sqlite3.connect('test.db') # 커넥션 열기 # test.db 파일이 있다면 그 파일을 열고, 그렇지 않다면 새로 만든다.conn.close() # 커넥션 닫기 커서로 작업하기커서는 커넥션 객체의 cursor() 메소드를 이용해서 얻을 수 있다.import sqlite3conn = sqlite3.connect('test.db')cursor = conn.cursor() # 커서 열기cursor.close() # 커서 닫기conn.close()테이블 생성다음은 test.db 파일안에 PHONEBOOK 테이블을 생성한다.import sqlite3conn = sqlite3.connect('test.db')cursor = conn.cursor()cursor.execute(\"\"\"CREATE TABLE PHONEBOOK (NAME CHAR(32), PHONE CHAR(32), EMAIL CHAR(64) PRIMARY KEY)\"\"\")cursor.close()conn.close()레코드 추가execute() 메소드는 매개변수 치환 기능을 지원한다. SQL문을 만들기 위해 일일히 문자열을 결합하는 대신 매개변수 치환 기능을 사용하면 읽기도 좋고 사용하기도 좋은 코드가 작성된다.SQL 문자열에 매개변수를 치환할 부분에 ?를 넣어놓고 ?에 들어갈 매개변수를 튜플 안에 넣어 execute() 메소드의 매개변수로 넘기면 된다.cursor.execute(\"\"\"INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL)VALUE(?, ?, ?) # 이곳에 '윤경한' '010-111-1111', 'zizou0812@gmail.com'가 입력된다\"\"\", ('윤경한', '010-111-1111', 'zizou0812@gmail.com'))  레코드의 추가, 수정, 삭제 등을 실행하고 난 뒤에는 반드시 Connection 객체의 commit() 함수를 불러줘야 한다. 그렇지 않으면 실제 데이터베이스 파일에는 아무 변경이 이루어지지 않는다. 이것은 SQLite가 데이터의 일관성(Consistency)을 위한 트랜젝션(Transaction)을 지원하기 때문이다.ex) 레코드 예제import sqlite3conn = sqlite3.connect('test.db')cursor = conn.cursor()cursor.execute(\"\"\"INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL) VALUES(?, ?, ?)\"\"\", ('윤경한', '010-111-1111', 'zizou0812@gmail.com'))id = cursor.lastrowidprint(id)cursor.execute(\"\"\"INSERT INTO PHONEBOOK (NAME, PHONE, EMAIL) VALUES(?, ?, ?)\"\"\", ('윤경한1', '010-111-1111', 'zizou0812@gmail.com'))id = cursor.lastrowidprint(id)conn.commit()cursor.close()conn.close()ex) 실행 결과&gt; insert_record.py12레코드 조회SELECT문을 실행한 후 결과를 얻어올 때는 커서 객체의 fetchone() 또는 fetchall() 메소드를 이용한다. fetchone() 메소드는 이름처럼 SELECT 실행 결과에서 레코드를 하나씩만 가져온다.row = cursor.fetchone()print(row)반면에, fetchall() 메소드는 한 번에 모든 결과 레코드를 가져온다.rows = cursor.fetchall()for row in rows:\tprint(\"NAME: {0}, PHONE: {1}, EMAIL: {2} \",\t\tformat(row[0], row[1], row[2]))ex) SELECT문을 실행하고 결과를 출력하는 예import sqlite3conn = sqlite3.connect('test.db')cursor = conn.cursor()cursor.execute(\"SELECT NAME, PHONE, EMAIL FROM PHONEBOOK\")rows = cursor.fetchall()for row in rows:   print (\"NAME: {0}, PHONE: {1}, EMAIL: {2} \".        format(row[0], row[1], row[2]))cursor.close()conn.close()ex) 실행 결과&gt; select_record.pyNAME: 윤경한, PHONE: 010-111-1111, EMAIL: zizou0812@gmail.comNAME: 윤경한1, PHONE: 010-111-1111, EMAIL: zizou0812@gmail.com",
        "url": "/blackruby-code//back/2017/12/10/brain5.html"
      }
      ,
    
      "back-2017-12-10-brain4-html": {
        "title": "뇌를 자극하는 파이썬 3 - 네크워크 프로그래밍",
        "tags": "Python",
        "date": "December 10, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "네트워크 프로그래밍네트워크 프로그래밍에 앞서 알아둬야 할 기초인터넷의 유래네트워크(Network)는 그물(Net)에서 파생된 단어로, 어떤 물건이나 사람 등의 상호 연결되어 있는 체계를 말한다. 보통 우리가 이야기하는 네트워크는 컴퓨터들이 상호 연결되어 있는 ‘컴퓨터 통신 네트워크’이다.냉전시대 미국은 소련과의 우주경쟁에서 뒤쳐졌다는 위기감에 DARPA라는 기관을 설립했다. DARPA의 각 연구기관에서는 컴퓨터를 이용해서 연구를 수행했고, 네트워크와 네트워크를 연결하는 새로운 구상을 하게 되었다. 이 방법을 이용하면 연구기관들을 잇는 회선을 일일히 구축하지 않고도 최소한의 비용으로 연구소들의 컴퓨터를 연결 할 수 있었다.필요한 자료들을 ‘빛의 속도’로 획득할 수 있게 되었다엄청난 혁신이었다  이른바 DARPANET이라고 불리던 이 네트워크는 더 많은 대학과 연구기관으로, 또한 세계의 연구기관과 민간으로 연결되기 시작하더니 1980년대 말에 이르러서는 인터넷이라고하는 국제 통신망을 형성하게 되었다.TCP/IP 스택컴퓨터끼리 네트워크에서 데이터를 주고 받으려면 그 네트워크에서 통용되는 ‘프로토콜(Protocol)’을 따라야한다. 프로토콜은 규약, 규칙이라는 뜻의 낱말로써, 여기에서는 컴퓨터들이 네트워크를 통해 데이터를 주고받기 위한 ‘통신규약’을 말한다.  TCP/IP는 다음과 같이 크게 네 개의 계층으로 구성되어 있으며, 한 계층 위에 다른 계층이 포개진 형태 때문에 이것을 TCP/IP 스택(stack)이라고 부르기도 한다.            Application Layer                  Transport Layer              Internet Layer              Link Layer        단순해 보이는 이 네 단계의 프로토콜 모음이 오늘날 인터넷을 떠받치고 있다링크 계층TCP/IP는 네트워크의 물리적인 구성으로부터 독립적인 프로토콜이다. 컴퓨터가 네트워크에 전화전에 모뎀으로 연결되어 있든, LAN에 이더넷 케이블로  연결되어 있든, 혹은 와이파이에 연결되어 있든 전혀 신경 쓰지 않는다.  이것은 링크 계층에서 네트워크의 물리적인 연결 매체를 통해 패킷을 주고 받는 작업을 담당해주기 때문이다.인터넷 계층인터넷 계층은 패킷을 수신해야 할 상대의 주소를 지정하고, 나가는 패킷에 대해서는 적절한 크기로 분할하며 들어오는 패킷에 대해서는 재조립을 수행한다! 이 계층에서 사용되는 규약이 바로 인터넷 프로토콜(Internet Protocol), 즉, IP이다. TCP/IP에서 IP가 바로 이것이다.전송 계층전송 계층(Transport Layer)에는 이름 그대로 패킷의 ‘운송’을 담당하는 프로토콜들이 정의되어 있다. 그 중에서도 전송 제어 프로토콜(TCP, Transmission Control Protocol)는 송신측과 수신측 간의 연결성을 제공하며, 신뢰할 수 있는 패킷 전송 서비스를 제공한다. 여러 개의 패킷을 송신하는 경우 패킷 사이의 순서를 보장하며, 패킷이 유실되기라도 하면 재전송을 해주기까지 한다. TCP/IP 프로토콜에서 TCP가 바로 이 프로토콜을 가리키는 것이며, TCP는 IP가 제공하지 않는 연결성, 신뢰성을 제공한다. 웹 문서를 전달하는 기능을 하는 HTTP를 비롯한 수많은 응용 프로토콜들이 바로 이 TCP와 IP 프로토콜 위에서 동작한다.애플리케이션 계층이 계층은 각 응용 프로그램 나름의 프로토콜들이 정의되는 곳이다. 웹 문서를 주고 받기 위한 HTTP, 파일 교환을 위한 FTP, 네트워크 관리를 위한 SNMP 등이 애플리케이션 계층에서 정의된 프로토콜의 대표적인 예이다. 애플리케이션의 계층의 프로토콜들은 전송 계층의 프로토콜 중 TCP에 기반할 수도 있고, UDP에 기반할 수도 있다.  HTTP와 FTP는 상대적으로 큰 데이터를 처리해야 하기 때문에 연결성과 신뢰성을 제공하는 TCP에 기반하고 있고, SNMP는 단순한 정보만을 다루는 데다 패킷을 일부 유실한다 해도 임무에 지장을 주지 않기 때문에 비용이 저렴한 UDP에 기반한다.TCP/IP의 주소 체계: IP 주소우편 배달부가 우편물을 배달하기 위해서는 ‘주소’가 필요하다. 인터넷에서도 패킷을 배달하려면 이것을 어디에서 보냈는지, 또 어디로 보낼지에 대한 정보 즉 주소가 필요하다. 그리고 인터넷에서 사용하는 이 주소를 일컬어 ‘IP 주소(Address)’라고 부른다.  현재는 주소 고갈이 임박한 IPv4 체계에서 IPv6체계로 전환이 전 세계적으로 진행되고 있다.포트큰 빌딩은 대개 출입구가 여러 개 있다. O마트의 예를 보면 주차장 출입구만 해도 일반 고객 승용차와 수화물 차량 출입구가 나눠져 있고, 살마들이 드나드는 출입구도 여러 곳이 있다. 이 출입구를 통해 차도, 사람도, 물건도 드나든다.컴퓨터도 네트워크 패킷이 드나들려면 ‘주소’뿐만아니라 출입문이 필요하다.이 출입문을 일컬어 포트(Port)라고 한다.TCP/IP의 동작 과정TCP/IP는 서버/클라이언트 방식으로 동작한다. 통신을 수행하는 양단 중 한쪽에서는 한쪽에게 서비스를 제공해야 한다는 것이다. 서버/클라이언트 방식으로 만들어진 TCP/IP 서비스의 예를 들면, FTP서버와 FTP클라이언트, SMTP 메일 서버와 메일 클라이언트 등등 이들 모두가 TCP/IP 기반으로 만들어졌다.socket과 TCPServer를 이용한 TCP/IP 프로그래밍파이썬의 라이브러리들이 공통으로 사용하는 라이브러리가 있다. 바로 socket 모듈이다.socket 모듈은 TCP/IP, UDP/IP를 지원하는 버클리 소켓 인터페이스를 여러 가지 함수와 socket클래스를 통해 제공한다.socket 클래스를 이용하면 거의 모든 인터넷 프로토콜을 구현할 수 있다는 장점이 있는 반면, 익히고 사용하기가 간단하지 않다는 단점도 있다.            클래스      메소드      설명                  TCPServer      serve_forever()      클라이언트의 접속 요청을 수신 대기한다. 접속 요청이 있을 경우 수락하고 BaseRequestHandler의 handler() 메소드를 호출한다.              BaseRequestHandler      handler()      클라이언트 접속 요청을 처리한다.              socket      connect()      서버에 접속 요청을 한다.                     send()      데이터를 상대방에게 전송한다.                     recv()      데이터를 수신한다.      ex) TCPServer와 BaseRequestHandler와 socket 클래스의 사용법 예class MyTCPHandler(socketserver.BaseRequestHandler):\tdef handle(self):\t\tprint(self.client_address[0]) # 클라이언트의 IP주소 출력\t\tbuffer = self.request.recv(1024).strip() # 데이터 수신\t\tself.request.send (buffer) # 데이터 송신  BaseRequestHandler로부터 상속을 받은 MyTCPHandler는 handle() 메소드를 재정의한다. handle() 메소드는 클라이언트의 연결 요청을 서버가 수락했을 때 호출된다. 다시 말하면 handle() 메소드가 호출되었다는 것은 통신을 수행할 준비가 됐다는 것이다!ex) 클라이언트가 보내오는 메세지를 서버가 그대로 ‘메아리’쳐 돌려보내는 프로그램 예import socketserverimport sysclass MyTCPHandler(socketserver.BaseRequestHandler):    def handle(self):        print('클라이언트 접속 : {0}'.format(self.client_address[0]))        sock = self.request                rbuff  = sock.recv(1024) # 데이터를 수신하고 그 결과를 rbuff에 담는다. rbuff는 bytes 형식이다.        received = str(rbuff, encoding=\"utf-8\")        print('수신 : {0}'.format(received))                # 수신한 데이터를 그대로 돌려보냄.        sock.send(rbuff) # 수신한 데이터를 그대로 클라이언트에게 다시 송신한다.        print('송신 : {0}'.format(received))        sock.close()if __name__ == '__main__':    if len(sys.argv) &lt; 2:        print('{0} &lt;Bind IP&gt;'.format(sys.argv[0]))        sys.exit()            bindIP = sys.argv[1]    bindPort = 5425 #     server = socketserver.TCPServer((bindIP, bindPort), MyTCPHandler)        print('메아리 서버 시작...')    server.serve_forever() # 클라이언트로부터 접속 요청을 받아들일 준비를 한다.ex) 메아리 클라이언트 예import socketimport sysif __name__ == '__main__':        if len(sys.argv) &lt; 4:        print(\"{0} &lt;Bind IP&gt; &lt;Server IP&gt; &lt;Message&gt;\".format(sys.argv[0]))        sys.exit()            bindIP = sys.argv[1]    serverIP = sys.argv[2]    message = sys.argv[3]    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # SOCK_STREAM = TCP socket     sock.bind((bindIP, 0))    try:        sock.connect((serverIP, 5425)) # 연결 요청을 수행한다.                # 메아리 송신        sbuff = bytes(message, encoding=\"utf-8\")        sock.send(sbuff) # 메세지를 송신한다.        print(\"송신 : {0}\".format(message))        # 메아리 수신        rbuff = sock.recv(1024) # 메세지를 수신한다.        received = str(rbuff, encoding=\"utf-8\")        print(\"수신 : {0}\".format(received))    finally:        sock.close()흐르는 패킷TCP 프로토콜은 연결 지향, 흐름 지향 프로토콜이다. 전기처럼 양쪽이 연결되어 있어야 하고 보내는 쪽에서 받는 쪽으로 패킷을 흘려 보낸다.하지만 TCP 프로토콜은 전기와 달리 흐름 속에서 각 개별 패킷의 경계를 구분해야 한다. 시작이 어디고 끝이 어디인지를 파악해야 한다.프로토콜 설계와 네트워크 애플리케이션 프로그래밍 예제파일 업로드 프로토콜파일 업로드 프로토콜(FUP)은 헤더와 바디의 두 부분으로 나뉜다. 바디에는 실제로 전달하고자 하는 데이터를 담고, 헤더에는 본문 길이를 비롯해 메세지의 속성 몇 가지를 담는다. 바디의 길이는 담는 데이터에 따라 달라지지만 헤더의 길이는 16바이트로 항상 일정하다. 따라서 수신한 패킷을 분석할 때는 가장 먼저 16바이트를 먼저 확인해서 (바디의 길이를 포함한) 메세지의 속성을 확인하고, 그 다음에 바디의 길이 만큼을 또 읽어 하나의 메세지 끝을 끊어내야 한다.파일 업로드 서버와 클라이언트 구현예제 프로그램의 구현은 세 가지 부분으로 나눠서 진행한다.      서버/클라이언트 공용 모듈 구현        서버 구현        클라이언트 구현  서버/클라이언트가 같이 사용할 모듈 만들기REQ_FILE_SEND  = 0x01 # 메세지 타입 상수 정의REP_FILE_SEND  = 0x02FILE_SEND_DATA = 0x03FILE_SEND_RES  = 0x04NOT_FRAGMENTED = 0x00 # 파일 분할 여부 상수 정의FRAGMENTED = 0x01NOT_LASTMSG = 0x00 # 분할된 메세지의 마지막 여부 상수 정의LASTMSG = 0x01ACCEPTED = 0x00 # 파일 전송 수락 여부 상수 정의DENIED = 0x01FAIL = 0x00 # 파일 전송 성공 여부 상수 정의SUCCESS = 0x01class ISerializable:    def GetBytes(self): # 메세지, 헤더, 바디는 모두 이 클래스를 상속한다. 즉, 이들은 자신의 데이터를 바이트 배열로 변환하고 그 바이트 배열의 크기를 반환해야 한다.        pass    def GetSize():        passclass Message(ISerializable):    def __init__(self):        self.Header = ISerializable()        self.Body = ISerializable()            def GetBytes(self):        buffer = bytes(self.GetSize())        header = self.Header.GetBytes()        body = self.Body.GetBytes()        return header + body    def GetSize(self):        return self.Header.GetSize() + self.Body.GetSize()  메세지의 헤더from message import ISerializableimport structclass Header(ISerializable):    def __init__(self, buffer):        self.struct_fmt = '=3I2BH' # 3 unsigned int, 2 byte, 1 unsigned short        self.struct_len = struct.calcsize(self.struct_fmt)        if buffer != None:                        unpacked = struct.unpack(self.struct_fmt, buffer)            self.MSGID = unpacked[0]            self.MSGTYPE = unpacked[1]            self.BODYLEN = unpacked[2]            self.FRAGMENTED = unpacked[3]            self.LASTMSG = unpacked[4]            self.SEQ = unpacked[5]    def GetBytes(self):        return struct.pack(            self.struct_fmt,             *(                 self.MSGID,                self.MSGTYPE,                self.BODYLEN,                self.FRAGMENTED,                self.LASTMSG,                self.SEQ            ))    def GetSize(self):        return self.struct_len  메세지 본문(body)를 표현하는 클래스from message import ISerializableimport messageimport structclass BodyRequest(ISerializable): # 파일 전송 요청 메세지(0x01)에 사용할 본문 클래스이다. FILESIZE와 FILENAME 데이터 속성을 갖는다.    def __init__(self, buffer):        if buffer != None:            slen = len(buffer)                        # 1 unsigned long long, N character            self.struct_fmt = str.format('=Q{0}s', slen-8)             self.struct_len = struct.calcsize(self.struct_fmt)            if slen &gt; 4: # unsigned long long의 크기                slen = slen - 4            else:                slen = 0            unpacked = struct.unpack(self.struct_fmt, buffer)            self.FILESIZE = unpacked[0]            self.FILENAME = unpacked[1].decode(                encoding='utf-8').replace('\\x00', '')        else:            self.struct_fmt = str.format('=Q{0}s', 0)            self.struct_len = struct.calcsize(self.struct_fmt)            self.FILESIZE = 0            self.FILENAME = ''    def GetBytes(self):        buffer = self.FILENAME.encode(encoding='utf-8')                # 1 unsigned long long, N character        self.struct_fmt = str.format('=Q{0}s', len(buffer))                 return struct.pack(            self.struct_fmt,             *(                 self.FILESIZE,                buffer            ))    def GetSize(self):        buffer = self.FILENAME.encode(encoding='utf-8')                # 1 unsigned long long, N character        self.struct_fmt = str.format('=Q{0}s', len(buffer))         self.struct_len = struct.calcsize(self.struct_fmt)        return self.struct_lenclass BodyResponse(ISerializable): # 파일 전송 요청에 대한 응답 메세지(0x02)에 사용할 본문 클래스이다. 요청 메세지의 MSGID와 수락 여부를 나타내는 RESPONSE 데이터 속성을 갖는다.    def __init__(self, buffer):            # 1 unsigned int, Byte        self.struct_fmt = '=IB'         self.struct_len = struct.calcsize(self.struct_fmt)        if buffer != None:            unpacked = struct.unpack(self.struct_fmt, buffer)            self.MSGID = unpacked[0]            self.RESPONSE = unpacked[1]        else:            self.MSGID = 0            self.RESPONSE = message.DENIED    def GetBytes(self):        return struct.pack(            self.struct_fmt,             *(                 self.MSGID,                self.RESPONSE            ))    def GetSize(self):        return self.struct_len        class BodyData(ISerializable): # 실제 파일을 전송하는 메세지(0x03)에 사용할 본문 클래스이다. 앞서 프로토콜 정의에서 언급되었던 것처럼 DATA 필드만 갖고 있다.    def __init__(self, buffer):        if buffer != None:            self.DATA = buffer    def GetBytes(self):        return self.DATA    def GetSize(self):        return len(self.DATA)class BodyResult(ISerializable): # 파일 전송 결과 메세지, 메세지(0x04)에 사용할 본문 클래스이다. 요청 메세지의 MSGID와 성공 여부를 나타내는 RESULT 데이터 속성을 갖는다.    def __init__(self, buffer):                # 1 unsigned int, Byte        self.struct_fmt = '=IB'         self.struct_len = struct.calcsize(self.struct_fmt)        if buffer != None:            unpacked = struct.unpack(self.struct_fmt, buffer)            self.MSGID = unpacked[0]            self.RESULT = unpacked[1]        else:            self.MSGID = 0            self.RESULT = message.FAIL    def GetBytes(self):        return struct.pack(            self.struct_fmt,            *(                 self.MSGID,                self.RESULT            ))    def GetSize(self):        return self.struct_len  MessageUtil 클래스의 구현import socketimport messagefrom message import Messagefrom message_header import Headerfrom message_body import BodyRequestfrom message_body import BodyResponsefrom message_body import BodyDatafrom message_body import BodyResultclass MessageUtil:    @staticmethod    def send(sock, msg): # send() 메소드는 msg 매개변수가 담고 있는 모든 바이트를 내보낼 때까지 반복해서 socket.send() 메소드를 호출한다.        sent = 0        buffer = msg.GetBytes()        while sent &lt; msg.GetSize():                        sent += sock.send(buffer)    @staticmethod    def receive(sock):        totalRecv = 0        sizeToRead = 16 # 헤더의 크기        hBuffer = bytes() # 헤더 버퍼        # 헤더 읽기        while sizeToRead &gt; 0: # 첫 반복문에서는 스트림으로부터 메세지 헤더의 경계를 끊어낸다.                        buffer = sock.recv(sizeToRead)            if len(buffer) == 0:                return None            hBuffer += buffer            totalRecv += len(buffer)            sizeToRead -= len(buffer)        header = Header(hBuffer)        totalRecv = 0        bBuffer = bytes()        sizeToRead = header.BODYLEN        while sizeToRead &gt; 0: # 첫 반복문에서 얻은 헤더에서 본문의 길이를 뽑아내어 그 길이만큼 다시 스트림으로부터 본문을 읽는다.            buffer = sock.recv(sizeToRead)            if len(buffer) == 0:                return None            bBuffer += buffer            totalRecv += len(buffer)            sizeToRead -= len(buffer)        body = None        if header.MSGTYPE == message.REQ_FILE_SEND:            body = BodyRequest(bBuffer)        elif header.MSGTYPE == message.REP_FILE_SEND:            body = BodyResponse(bBuffer)        elif header.MSGTYPE == message.FILE_SEND_DATA:            body = BodyData(bBuffer)        elif header.MSGTYPE == message.FILE_SEND_RES:            body = BodyResult(bBuffer)        else:            raise Exception(                                         \"Unknown MSGTYPE : {0}\".                    format(header.MSGTYPE))        msg = Message()        msg.Header = header        msg.Body = body                    return msg  파일 업로드 서버의 구현import osimport sysimport socketimport socketserverimport structimport messagefrom message import Messagefrom message_header import Headerfrom message_body import BodyDatafrom message_body import BodyRequestfrom message_body import BodyResponsefrom message_body import BodyResultfrom message_util import MessageUtilCHUNK_SIZE = 4096upload_dir = ''class FileReceiveHandler(socketserver.BaseRequestHandler):    def handle(self):        print(\"클라이언트 접속 : {0}\".format(self.client_address[0]))        client = self.request # client socket        reqMsg = MessageUtil.receive(client) # 클라이언트가 보내온 파일 전송 요청 메세지를 수신한다.        if reqMsg.Header.MSGTYPE != message.REQ_FILE_SEND:            client.close()            return        reqBody = BodyRequest(None)        print(            \"파일 업로드 요청이 왔습니다. 수락하시겠습니까? yes/no\")        answer = sys.stdin.readline()        rspMsg = Message()        rspMsg.Body = BodyResponse(None)        rspMsg.Body.MSGID = reqMsg.Header.MSGID        rspMsg.Body.RESPONSE = message.ACCEPTED        rspMsg.Header = Header(None)        msgId = 0        rspMsg.Header.MSGID = msgId        msgId = msgId + 1        rspMsg.Header.MSGTYPE = message.REP_FILE_SEND        rspMsg.Header.BODYLEN = rspMsg.Body.GetSize()        rspMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED        rspMsg.Header.LASTMSG = message.LASTMSG        rspMsg.Header.SEQ = 0        if answer.strip() != \"yes\": # 사용자가 'yes'가 아닌 답을 입력하면 클라이언트에게 '거부'응답을 보낸다.            rspMsg.Body = BodyResponse(None)            rspMsg.Body.MSGID = reqMsg.Header.MSGID            rspMsg.Body.RESPONSE = message.DENIED                    MessageUtil.send(client, rspMsg)            client.close()            return        else:            MessageUtil.send(client, rspMsg) # 물론'yes'를 입력하면 클라이언트에게 '승낙'응답을 보낸다.            print(\"파일 전송을 시작합니다...\")            fileSize = reqMsg.Body.FILESIZE            fileName = reqMsg.Body.FILENAME            recvFileSize = 0             with open(upload_dir + \"\\\\\" + fileName, 'wb') as file: # 업로드 받을 파일을 생성한다.                dataMsgId = -1                prevSeq = 0                                while True:                    reqMsg = MessageUtil.receive(client)                    if reqMsg == None:                        break                    print(\"#\", end='')                                        if reqMsg.Header.MSGTYPE != message.FILE_SEND_DATA:                        break                    if dataMsgId == -1:                        dataMsgId = reqMsg.Header.MSGID                    elif dataMsgId != reqMsg.Header.MSGID:                        break                                        if prevSeq != reqMsg.Header.SEQ: # 메세지 순서가 어긋나면 전송을 중단한다.                        print(\"{0}, {1}\".format(prevSeq, reqMsg.Header.SEQ))                        break                                        prevSeq += 1                    recvFileSize += reqMsg.Body.GetSize() # 전송받은 파일의 일부를 담고 있는 bytes 객체를 서버에서 생성한 파일에 기록한다.                    file.write(reqMsg.Body.GetBytes())                    if reqMsg.Header.LASTMSG == message.LASTMSG: # 마지막 메세지만 반복문을 빠져나온다.                        break                               file.close()                print()                print(\"수신 파일 크기 : {0} bytes\".format(recvFileSize))                rstMsg = Message()                rstMsg.Body = BodyResult(None)                rstMsg.Body.MSGID = reqMsg.Header.MSGID                rstMsg.Body.RESULT = message.SUCCESS                                rstMsg.Header = Header(None)                rstMsg.Header.MSGID = msgId                msgId += 1                rstMsg.Header.MSGTYPE = message.FILE_SEND_RES                rstMsg.Header.BODYLEN = rstMsg.Body.GetSize()                rstMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED                rstMsg.Header.LASTMSG = message.LASTMSG                rstMsg.Header.SEQ = 0                if fileSize == recvFileSize: # 파일 전송 요청에 담겨온 파일 크기와 실제로 받은 파일의 크기를 비교하여 같으면 성공 메세지를 보낸다.                    MessageUtil.send(client, rstMsg)                else:                    rstMsg.Body = BodyResult(None)                    rstMsg.Body.MSGID = reqMsg.Header.MSGID                    rstMsg.Body.RESULT = message.FAIL                    MessageUtil.send(client, rstMsg) # 파일 크기에 이상이 있다면 실패 메세지를 보낸다.            print(\"파일 전송을 마쳤습니다.\")                            client.close()if __name__ == '__main__':    if len(sys.argv) &lt; 2:        print(\"사용법 : {0} &lt;Directory&gt;\".format(sys.argv[0]))        sys.exit(0)    upload_dir = sys.argv[1]    if os.path.isdir(upload_dir) == False:        os.mkdir(upload_dir)             bindPort = 5425    server = None    try:        server = socketserver.TCPServer(            ('', bindPort), FileReceiveHandler)                    print(\"파일 업로드 서버 시작...\")        server.serve_forever()    except Exception as err:        print(err)    print(\"서버를 종료합니다.\")  클라이언트의 구현import osimport sysimport socketimport structimport messagefrom message import Messagefrom message_header import Headerfrom message_body import BodyDatafrom message_body import BodyRequestfrom message_body import BodyResponsefrom message_body import BodyResultfrom message_util import MessageUtilCHUNK_SIZE = 4096if   __name__ == '__main__':    if len(sys.argv) &lt; 3:        print(\"사용법 : {0} &lt;Server IP&gt; &lt;File Path&gt;\".              format(sys.argv[0]))        sys.exit(0)    serverIp   = sys.argv[1]    serverPort = 5425    filepath   = sys.argv[2]        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # TCP 소켓을 생성한다.            try:        print(\"서버:{0}/{1}\".format(serverIp, serverPort))                    sock.connect((serverIp, serverPort)) # 접속 요청을 수락한다.        msgId = 0        reqMsg = Message()                filesize = os.path.getsize(filepath)        reqMsg.Body = BodyRequest(None)        reqMsg.Body.FILESIZE = filesize        reqMsg.Body.FILENAME = filepath[filepath.rindex('\\\\')+1:]            msgId += 1        reqMsg.Header = Header(None)        reqMsg.Header.MSGID = msgId        reqMsg.Header.MSGTYPE = message.REQ_FILE_SEND        reqMsg.Header.BODYLEN = reqMsg.Body.GetSize()        reqMsg.Header.FRAGMENTED = message.NOT_FRAGMENTED        reqMsg.Header.LASTMSG = message.LASTMSG        reqMsg.Header.SEQ = 0                  MessageUtil.send(sock, reqMsg) # 클라이언트는 서버에 접속하자마자 파일 전송 요청 메세지를 보낸다.        rspMsg = MessageUtil.receive(sock) # 그리고 서버의 응답을 받는다.        if rspMsg.Header.MSGTYPE != message.REP_FILE_SEND:            print(\"정상적인 서버 응답이 아닙니다.{0}\".                format(rspMsg.Header.MSGTYPE))            exit(0)        if rspMsg.Body.RESPONSE == message.DENIED:            print(\"서버에서 파일 전송을 거부했습니다.\")            exit(0)        with open(filepath, 'rb') as file: # 서버에서 전송 요청을 수락했다면, 파일을 열어 서버로 보낼 준비를 한다.            totalRead = 0            msgSeq = 0 #ushort            fragmented = 0 #byte            if filesize &lt; CHUNK_SIZE:                fragmented = message.NOT_FRAGMENTED            else:                fragmented = message.FRAGMENTED                while totalRead &lt; filesize:                rbytes = file.read(CHUNK_SIZE)                totalRead += len(rbytes)                fileMsg = Message()                            fileMsg.Body = BodyData(rbytes) # 모든 파일의 내용이 전송될 때까지 파일을 0x03 메세지에 담아 서버로 보낸다.                header = Header(None)                header.MSGID = msgId                header.MSGTYPE = message.FILE_SEND_DATA                header.BODYLEN = fileMsg.Body.GetSize()                header.FRAGMENTED = fragmented                if totalRead &lt; filesize:                    header.LASTMSG = message.NOT_LASTMSG                else:                    header.LASTMSG = message.LASTMSG                header.SEQ = msgSeq                msgSeq += 1                            fileMsg.Header = header                print(\"#\", end = '')                MessageUtil.send(sock, fileMsg)            print()            rstMsg = MessageUtil.receive(sock) # 서버에서 파일을 제대로 받았는지에 대한 응답을 받는다.                                result = rstMsg.Body            print(\"파일 전송 성공 : {0}\".                format(result.RESULT == message.SUCCESS))    except Exception as err:        print(\"예외가 발생했습니다.\")        print(err)    sock.close()        print(\"클라이언트를 종료합니다.\")",
        "url": "/blackruby-code//back/2017/12/10/brain4.html"
      }
      ,
    
      "back-2017-12-10-brain3-html": {
        "title": "뇌를 자극하는 파이썬 3 - 파일에 데이터 읽고 쓰기",
        "tags": "Python",
        "date": "December 10, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "파일에 데이터 읽고 쓰기열라, 읽으라(쓰라), 닫으라애플리케이션이 디스크 같은 하드웨어를 직접 제어해 파일에 접근하는 경우는 거의 없다. 운영체제가 파일관리 업무를 담당하고 있기 때문에, 애플리케이션이 운영체제에게 API 함수를 통해 파일 처리를 의뢰하면 운영체제가 요청한 업무를 수행해주고, 그 결과를 애플리케이션에게 돌려준다.파일 열기 - 읽기/쓰기 - 닫기에 필요한 파이썬 함수는 다음과 같다.1. 파일 열기 # file = open()2. 파일 읽기/쓰기 # file.read()/file.write()3. 파일 닫기 # file.close()ex) 파일에 데이터를 기록하는 프로그램 예file = open('test.txt', 'w')file.write('hello')file.close()ex) 실행 결과&gt; write.pyex) 파일의 내용을 읽는 프로그램 예file = open('test.txt', 'r')str = file.read()print(str)file.close()ex) 실행 결과&gt; read.pyhello자원 누수 방지를 돕는 with ~ asopen() 함수와 함께 with ~ as 문을 사용하면 명시적으로 close() 함수를 호출하지 않아도 파일이 항상 닫힌다. with ~ as 문을 사용하는 방법은 다음과 같다.with open(파일이름) as 파일 객체: # \"파일객체 = open(파일이름)\"과 같다.\t# 코드 블록\t# 이곳에서 읽거나\t# 쓰기를 한 후\t# 그냥 코드를 빠져나가면 된다 # with문 덕분에 close()을 하지 않아도 된다.with문의 비밀: 컨텍스트 매니저아무 함수나 with절에 올 수 있는 것은 아니다. 컨텍스트 매니저(Context Manager)를 제공하는 함수여야 with문과 함께 사용할 수 있다.컨텍스트 매니저는 __enter__()메소드와 __exit__()메소드를 구현하고 있는 객체이다. with문은 컨텍스트 매니저를 획득한 후 코드 블록의 실행을 시작할 때 컨텍스트 매니저의 __enter__()메소드를 호출하고, 코드블록이 끝날 때 __exit__()를 호출한다.  __exit__()메소드에 프로그래머들이 흔하게 잊곤 한느 자원 해제 코드를 구현해 놓으면 자원을 해제하는 명시적인 코드가 없어도 자원 획득/해제를 안전하게 처리할 수 있게 된다. (with문을 사용한다는 전제하)with open('test.txt', 'r') as file: # 코드블록 시작하기 전에 컨텍스트 매니저 __exit__()호출\ts = file.read()\tprint(s) # 컨텍스트 매니저 __exit__()호출ex) 컨텍스트 매니저 구현 예class open2(object):    def __init__(self, path):        print ('initialized')        self.file = open(path)    def __enter__(self):        print ('entered')        return self.file    def __exit__(self, ext, exv, trb):        print (\"exited\")        self.file.close()        return Truewith open2(\"test.txt\") as file:    s = file.read()    print(s)ex) 실행 결과&gt; open2.pyinitializedenteredhelloexited컨텍스트 매니저를 훨씬 간편하게 구현 할 수 있는 방법이 있다.  바로 @contextmanager 데코레이터를 이용하는 것이다.@contextmanager 데코레이터는 __call__()메소드는 물론이고, 컨텍스트 매니저 규약을 준수하는 데 필요한 __enter__() 메소드와 __exit__() 메소드를 모두 갖추고 있다.from contextlib import contextmanager # contextlib 모듈로부터 contextmanager를 반입@contextmanager # @contextmanager 데코레이터로 함수 수식def 함수이름():\t# 자원 획득\ttry:\t\tyield 자원 # yield문을 통해 자원 반환: with문의 코드블록이 시작될 때 실행.\tfinally:\t\t# 자원 해제 # with문의 코드블록이 종료될 때 실행된다.  @contextmanager로 수식되는 함수의 구조에서 눈여겨봐야 할 곳은 크게 3가지이다.      try ~ finally 블록을 갖고 있다.        try 블록에서는 yield문을 통해 자원을 반환한다. 이때 yield문은 자신의 매개변수로 넘겨진 자원을 반환한 뒤 임시적으로 현재 함수의 실행을 정지시킨다. yield에 의해 정지된 함수는 with문의 코드블록 실행이 끝날 때 다시 실행된다.        finally 블록에서 획득한 자원을 해제한다.  요약하면, @contextmanager로 수식하는 함수는 try 블록이 __enter__() 메소드의 역할을, finally 블록이 __exit__() 메소드의 역할을 수행한다고 할 수 있다.open()함수 다시보기컴퓨터가 다루는 모든 파일은 바이너리 파일이다. 바이너리 파일 중에서 텍스트 데이터만 기록하고 있는 파일을 텍스트 파일이라고 한다. open() 함수는 코드에서 입력되는 매개변수에 따라 텍스트 파일을 처리할 것인가 또는 바이너리 파일을 처리할 것인가를 결정한다.  open() 함수는 모두 8개의 매개변수를 받아들인다. 이들 매개변수는 하나의 필수 매개변수과 일곱 개의 선택적 매개변수로 이루어져 있다. open() 함수의 반환값은 물론 파일 객체이다.open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closed=True, opener=None)텍스트 파일 읽고/쓰기문자열을 담은 리스트를 파일에 쓰는 writelines() 메소드writelines()는 문자열을 요소로 가지는 순서열 객체를 매개변수로 입력받아 해당 순서열 객체의 내용을 모두 파일에 기록한다.lines = [\"we'll find a way we always have - Interstellar\\n\",          \"I'll find you and I'll kill you - Taken\\n\",         \"I'll be back - Terminator 2\\n\"]         with open('movie_quotes.txt', 'w') as file:    file.writelines(lines)ex) 실행 결과&gt; writelist.py&gt; type movie_quotes.txtwe'll find a way we always have - InterstellarI'll find you and I'll kill you - TakenI'll be back - Terminator 22줄 단위로 텍스트를 읽는 readline()과 redlines() 메소드ex) readline() method 예with open('movie_quotes.txt', 'r') as file:        line = file.readline()        while line != '': # readline() 메소드는 파일의 끝에 도달하면 ''를 반환한다. 그런데 실제로 빈 줄을 읽어 들였을 경우에는? 빈 줄을 읽어 들인 경우에는 개행 문자를 반환한다.        print(line, end='')        line = file.readline()ex) 실행 결과&gt; readline.pywe'll find a way we always have - InterstellarI'll find you and I'll kill you - Taken I'll be back - Terminator2ex) readlines() method 예with open('movie_quotes.txt', 'r') as file:        lines = file.readlines()        line = ''    for line in lines:        print(line, end='')ex) 실행 결과&gt; readlines.pywe'll find a way we always have - InterstellarI'll find you and I'll kill you - TakenI'll be back - Terminator 2문자 집합과 인코딩컴퓨터의 발명, 발전이 미국의 학계와 기업을 중심으로 이루어지다 보니 문자 집합도 미국을 기준으로 제정되었고, 미국에서 제정된 ASCII는 1960년대에 제정된 문자 집합으로, 이후에 개발된 문자 집합들의 토대를 이루고 있다.미국의 엔지니어들은 ASCII으로 행복하게 살아가고 있었지만, 다른나라의 사람들은 그렇지 못했다. 자국언어에서 사용해야 하는 문자들을 ASCII로는 표현 할 수가 없었다.그래서 미국 표준을 보완한 새로운 국제 표준이 등장했는데 그것이 ISO/IEC 8859-1이다.이 표준 제정 이후 중앙 유럽어, 남유럽어, 북유럽어, 아랍어 등을 지원하는 ISO/IEC 8859-N 표준이 새로 제정 되었다.      DBCS라는 2바이트(16비트)를 활용해서 문자 집합을 구성하는 방법으로 한글 문자 집합 표준도 만들어졌다.          KS X 1001, EUC-KR, CP949 등이 있다.      문자 집합을 저장하고 표현하는 방법을 통일해서 문서와 소프트웨어를 작성하고 열람한다면 얼마나 좋을까?이런 배경에서 소프트웨어 회사들이 힘을 모아 유니코드 협회를 만들고 유니코드(Unicode)를 제정했다.하지만 기존의 시스템을 추가하자 코드 포인트가 2바이트를 넘어서게 되었고, 새로운 문자를 위한 코드 포인트가 부족해지게 되었다.      이런 요구사항들을 충족시키려다보니 유니코드를 인코딩(부호화)하는 방법을 정의하는 표준이 필요해졌다.          UTF-7, UTF-8, UTF-16, UTF-32등이 바로 그것이다.      UTF는 우리 말로 하면 변환 인코딩 형식(Unicode Transformation Format)이라고 하는데, 이 중에서 가장 많이 사용하는 것은 UTF-8이다!바이너리 파일 다루기파이썬에서 struct 모듈의 도움이 없이는 바이너리 파일을 제대로 다루기가 어렵다. struct 모듈은 일반 데이터 형식과 bytes 형식 사이의 변환을 수행하는 함수들을 담고 있다.ex) struct 예&gt;&gt;&gt; import struct &gt;&gt;&gt; packed = struct.pack('i', 123) # pack() 함수는 첫 번째에 매개변수 1에 따라 4바이트 크기의 bytes 객체 packed를 준비하고 두 번째 매개변수를 bytes에 복사해 넣는다.&gt;&gt;&gt; for b in packed:      \tprint(b) # bytes 객체 packed의 각바이트에 있는 내용을 출력.    \t123000&gt;&gt;&gt; unpacked = struct.unpack('i', packed) &gt;&gt;&gt; unpacked (123,)&gt;&gt;&gt; type(unpacked) # unpack() 함수는 튜플 형식을 반환한다.&lt;&lt;class 'tuple'&gt;&gt;  struct.pack(), struct.unpack() 함수의 예는 형식 문자열을 ‘i’로만 지정했는데 이것은 ‘바이트 순서:시스템 기본값, 데이터 구조:4바이트 크기의 정수형식 1개’로 데이터를 반환하겠다는 뜻이다.",
        "url": "/blackruby-code//back/2017/12/10/brain3.html"
      }
      ,
    
      "back-2017-12-10-brain2-html": {
        "title": "뇌를 자극하는 파이썬 3 - 클래스, 예외 처리",
        "tags": "Python",
        "date": "December 10, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "클래스객체 지향 프로그래밍객체와 클래스객체 지향 프로그래밍에서의 객체는 다음과 같이 정의된다.객체(Object) = 속성(Attribute) + 기능(Method)속성은 사물의 특징을 말한다.자동차로 예를 들면, 몸체의 색, 바퀴의 크기, 엔진의 배기량 등이 자동차의 속성이라 할 수 있다. 기능은 어떤 것의 특징적인 동작을 말한다.다시 자동차로 예를 들면, 전진, 후진, 좌회전, 우회전등이 자동차의 기능이라고 할 수 있다!  속성을 ‘변수’, 기능을 ‘함수’로 바꿔 ‘객체 = 변수 + 함수’라고 할 수 있다.class Car: # Car 클래스의 정의 시작을 알린다\tdef __init__(self):\t\tself.color = 0xFF0000 # Car 클래스 안에 차의 색, 바퀴 크기, 배기량을 나타내는 변수를 정의한다.\t\tself.wheel_size = 16\t\tself.displacement = 2000\t\t\tdef forward(self): # 전진\t\tpass\t\t\tdef backward(self): # 후진\t\tpass\t\t\tdef turn_left(self): # 좌회전\t\tpass\t\t\tdef turn_right(self): # 우회전 # Car 클래스 안에 전진, 후진, 좌회전, 우회전 함수를 정의\t\tpass      클래스는 자료형이고, 객체는 변수이다!        객체 대신에 인스턴스(Instance)라는 용어를 사용하기도 한다. 인스턴스는 실체, 사례라는 뜻으로 클래스가 설계도라면, 객체는 그 설계를 바탕으로 실체화 한 것이라는 뜻에서 유래한다.  객체 지향 프로그래밍을 해야하는 이유!한번 만들어서 세상에 내놓으면 고칠 일이 별로 없는 하드웨어와는 달리 소프트웨어는 세상에 내놓는 순간부터 챙겨줘야 할 것이 매우 많아진다. 이때 소프트웨어의 결합도가 높으면 코드를 고칠 때마다 부작용이 발생할 가능성이 높아진다. 결합도가 낮은 소프트웨어는 어느 한 부분을 수정하더라도 부작용에 대한 걱정을 줄일 수 있다.같은 목적과 기능을 위해 객체로 묶인 코드 요소(변수, 함수)들은 객체 내부에서만 강한 응집력을 발휘하고 객체 외부에 주는 영향은 줄이게 된다.  코드가 객체 위주로 이루어질 수 있도록 지향하는 프로그래머의 노력은 코드의 결합도를 낮추는 결과는 낳게 된다. 객체 지향 프로그래밍의 장점은 여기에 있다.클래스의 정의클래스는 class 키워드를 이용하여 정의한다.class 클래스이름:\t코드블록  파이썬에서는 콜론으로 끝나는 문장의 다음 줄에는 코드 블록이 위치할 것을 요구하는데, 클래스의 코드블록은 변수와 메소드(Method)로 이루어진다. 여기서 메소드는 클래스에 속해있는 함수를 말한다.클래스 안에 정의되어 있는 변수와 메소드는 클래스의 멤버라고도 한다. 메소드는. 이미 용어 자체로 함수와 달리 클래스에 소속되어 있음을 알 수 있지만 변수의 경우에는 일반 변수와 클래스의 멤버 변수를 구분하기 어려우므로 ‘데이터 속성(Data Attribute)’이라는 용어가 사용된다.class Car:    def __init__(self):        self.color = 0xFF0000    # 바디의 색        self.wheel_size = 16     # 바퀴의 크기        self.displacement = 2000 # 엔진 배기량    def forward(self): # 전진        pass    def backward(self): # 후진        pass    def turn_left(self): # 좌회전        pass    def turn_right(self): # 우회전        passif __name__ == '__main__':            my_car = Car() # 앞에서 정의한 Car클래스의 객체 my_car를 생성한다.    print('0x{:02X}'.format(my_car.color)) # my_car의 정보를 출력    print(my_car.wheel_size)    print(my_car.displacement)    my_car.forward() # my_car의 메소드를 호출    my_car.backward()    my_car.turn_left()    my_car.turn_right()ex) 실행 결과&gt; Car.py0xFF0000162000__init__() 메소드를 이용한 초기화클래스의 생성자가 호출되면 내부적으로 또 다른 두 개의 메소드가 호출된다. 하나는 __new__()이고 또 다른 하나는 우리가 알고 있는 __init__()이다. 이들은 마법(Magic)메소드 또는 특별(Special)메소드라고 불리운다.데이터 속성을 __init__()메소드가 아닌 클래스에 직접 정의한다면 어떤 일이 일어날까?class ClassVar: # text_list는 ClassVar클래스의 정의 시점에 함께 메모리에 할당된다.\ttext_list = []\tobj = ClassVar() # obj객체가 생성되기 전부터 text_list는 메모리에 적재되어 있다.ex) 왜 __init__()메소드를 사용해야하는가?class ClassVar:    text_list = []    def add(self, text):        self.text_list.append(text)        def print_list(self):        print(self.text_list)if __name__ == '__main__':            a = ClassVar()    a.add('a')    a.print_list() # ['a'] 출력을 기대        b = ClassVar()    b.add('b')    b.print_list() # ['b'] 출력을 기대ex) 실행 결과&gt; ClassVar.py['a'] # 객체 a를 통해 'a'를 입력하고 a의 text_list 내용을 출력.['a','b']\t# 객체 b를 통해 'b'를 입력하고 b의 text_list 내용을 출력했다. 하지만 객체 'b'에서는 입력하지 않은 'a'가 들어 있다. 이것은 클래스 속성으로 정의된 text_list변수를 ClassVar의 모든 인스턴스가 공유하게 되어 생긴 문제이다!  인스턴스가 생성될 때에만 __init__()메소드가 실행되므로 이 메소드 안에 변수 정의/초기화 코드를 넣어 놓으면 모든 인스턴스가 변수를 공유하게 되는 불상사는 피할 수 있다.class InstanceVar:    def __init__(self):        self.text_list = []    def add(self, text):        self.text_list.append(text)        def print_list(self):        print(self.text_list)if __name__ == '__main__':            a = InstanceVar()    a.add('a')    a.print_list() # ['a'] 출력을 기대        b = InstanceVar()    b.add('b')    b.print_list() # ['b'] 출력을 기대ex) 실행 결과&gt; InstanceVar.py['a']['b'] # __init__()메소드 안에서 정의한 text_list는 각 객체마다 고유한 인스턴스로 사용하므로 ClassVar.py에서와 같은 부작용이 사라졌다!!!  __init__() 메소드의 이름은 ‘초기화하다’는 뜻의 initailize를 줄여서 붙여진 것이다.self에 대해self는 ‘자아’또는 ‘자신’이라는 뜻이다. 파이썬의 메소드에 사용되는 self는 메소드가 소속되어 있는 객체이다.class ContactInfo:\tdef __init__(self, name, email):\t\tself.name = name\t\tself.email = email\t\t\tkyeonghan = ContactInfo('윤경한', 'zizou0812@gmail.com')  ContactInfo 외부에서는 kyeonghan 이라는 이름으로 객체를 다룰 수 있다. 내부에서는 kyeonghan처럼 객체를 지칭할 수 있는 이름이 없다. 그래서 self를 도입한 것이다!정적 메소드와 클래스 메소드인스턴스 메소드는 인스턴스(객체)에 속한 메소드를 말한다인스턴스 메소드가 “인스턴스에 속한다”라는 표현은 “인스턴스를 통해 호출가능하다”라는 뜻이다. 그렇다면 클래스에 속한(클래스를 통해 호출 가능한) 메소드도 있을까? 있다. 정적 메소드(Static Method)와 클래스 메소드(Class Method)가 바로 그런 메소드 이다.ex) 정적메소드의 예class Calculator:\t\t@staticmethod\tdef plus(a, b): # 당연히 정적 메소드도 매개변수를 받는다. self는 제외!\t\treturn a+bex) 사칙연산 함수를 활용하는 정적메소드 예제class Calculator:    @staticmethod # 클래스 안에 정의되었지만 self를 매개변수로 받지 않는다.    def plus(a, b):        return a+b    @staticmethod    def minus(a, b):        return a-b    @staticmethod    def multiply(a, b):        return a*b    @staticmethod            def divide(a, b):        return a/b        if __name__ == '__main__':            print(\"{0} + {1} = {2}\".format(7, 4, Calculator.plus(7, 4))) # 정적 메소드는 인스턴스 대신 클래스 이름을 통해 메소드에 접근한다. \"클래스이름.메소드()\"의 형태!    print(\"{0} - {1} = {2}\".format(7, 4, Calculator.minus(7, 4)))    print(\"{0} * {1} = {2}\".format(7, 4, Calculator.multiply(7, 4)))    print(\"{0} / {1} = {2}\".format(7, 4, Calculator.divide(7, 4)))ex) 실행 결과&gt; Calculator.py7 + 4 = 117 + 4 = 37 + 4 = 287 + 4 = 1.75      정적 메소드는 self 매개변수를 전달받을 방법이 없으므로(self 매개변수는 인스턴스 메소드에게만 파이썬이 전달해준다) 객체/인스턴스의 변수에 접근 할 수 없다.        따라서, 정적 메소드는 객체의 데이터 속성과는 관계가 없는 코드로 구현되는 것이 일반적이다.  ex) 클래스 메소드의 예class 클래스이름:\t# ...  \t\t@classmethod # 클래스 메소드를 정의하기 위해서는 1. @classmethod 데코레이터를 앞에 붙여준다. \tdef 메소드이름(cls): # 2. 메소드의 매개변수를 하나 이상 정의한다.\t\tpassex) cls 매개변수를 통해 클래스 속성에 접근하는 방법 예제class InstanceCounter:    count = 0    def __init__(self): # 인스턴스가 만들어질 때마다 __init__()메소드가 실행된다. 인스턴스의 수를 세기에는 이곳이 적절하다!        InstanceCounter.count += 1        @classmethod    def print_instance_count(cls): # print_instance_count() 메소드는 InstanceCounter의 클래스 속성인 count를 출력한다.        print(cls.count)if __name__ == '__main__':            a = InstanceCounter()    InstanceCounter.print_instance_count()        b = InstanceCounter()    InstanceCounter.print_instance_count()        c = InstanceCounter()    c.print_instance_count()ex) 실행 결과&gt; InstanceCounter.py123클래스 내부에게만 열려있는 프라이빗 멤버클래스의 안에서만 접근이 가능한 멤버를 일컬어 ‘프라이빗(Private)’멤버라고 한다. 반대로 안과 밖 모두에서 접근이 가능한 멤버는 ‘퍼블릭(Public)’멤버라고 한다.파이썬은 다른 프로그래밍 언어들과는 달리 작명법(Naming)으로 둘을 구분한다!프라이빗 멤버의 명명 규칙은 다음과 같다!      두 개의 밑줄 __이 접두사여야 한다. 예) _number        접미사는 밑줄이 한 개까지만 허용된다. 예) _number_          접미사의 밑줄이 두 개 이상이면 퍼블릭 멤버로 간주한다. 예) __number__      상속클래스끼리 데이터를 물려주는 것을 일컬어 ‘상속(Inheritance)’이라고 한다.객체 지향 프로그래밍에서는 물려 받는 클래스(파생 클래스(Derived Class) 또는 자식 클래스라고 한다)가 유산을 물려줄 클래스(기반 클래스(Base Class)또는 부모 클래스라고 한다)를 지정한다.ex) 상속 개념class 기반 클래스:\t# 멤버 정의\tclass 파생 클래스(기반 클래스)\t# 아무 멤버를 정의하지 않아도 기반 클래스의 모든 것을 물려받아 갖게 된다.\t# 단, 프라이빗 멤버(_로 시작하는 이름을 갖는 멤버)는 제외super()super()는 부모 클래스의 객체 역할을 하는 프록시(Proxy)를 반환하는 내장 함수이다!  사실상, super()함수의 반환값을 상위 클래스의 객체로 간주하고 코딩을 해도 된다.super()를 사용함으로써, 기반 클래스가 다른 클래스로 교체되거나 수정되어도 파생 클래스가 받는 영향을 최소화 할 수 있다.다중 상속파이썬에서는 파생 클래스를 정의할때 기반 클래스의 이름을 콤마(,)로 구분해서 쭉 적어주면 다중 상속이 이루어진다.ex) 다중 상속의 예class A:\tpass\tclass B:\tpass\tclass C:\tpass\tclass D(A, B, C): # 클래스 D는 A, B, C로부터 상속받는다.\tpass오버라이딩오버 라이딩(Overriding)은 영어로 짓밟다. (결정 등을) 무효로 하다. ~에 우선하다 등의 뜻을 갖고 있다. OOP에서 오버라이딩의 뜻은 “기반(부모) 클래스로부터 상속받은 메소드를 다시 정의하다”이다.ex) 오버라이딩의 예&gt;&gt;&gt; class A:     \tdef method(self):     \t\tprint(\"A\")     \t\t&gt;&gt;&gt; class B(A):    \tdef method(self):    \t\tprint(\"B\")    \t\t&gt;&gt;&gt; class C(A):    \tdef method(self):    \t\tprint(\"C\")    \t\t&gt;&gt;&gt; A().method()A&gt;&gt;&gt; B().method()B&gt;&gt;&gt; C().method()C  위의 코드에서 클래스 B와 C는 A를 상속하고 있기 때문에 가만히 있어도 method()를 물려받을 수 있었다. 하지만 그렇게 하지 않았다. 자신만의 method()를 새로 정의했다. 이것이 오버라이딩이다!데코레이터: 함수를 꾸미는 객체데코레이터는 __call__() 메소드를 구현하는 클래스__call__() 메소드는 객체를 함수 호출 방식으로 사용하게 만드는 마법 메소드이다!ex) __call__() 예class MyDecorator:\tdef __init__(self, f): # __init__() 메소드의 매개변수를 통해 함수를 받아들이고 데이터 속성에 저장해둔다.\t\tprint(\"Initializing MyDecorator...\")\t\tself.func = f\t\t\tdef __call__(self):\t\tprint(\"Begin :{0}\".format( self.func.__name__))\t\t\t\tself.func() # __call__() 메소드가 호출되면서 생성자에서 저장해둔 함수(데이터 속성)를 호출한다!\t\t\t\tprint(\"End :{0}\".format(self.func.__name__))데코레이터를 생성하는 방법 1: 생성자앞서 정의한 MyDecorator 클래스의 경우는 다음과 같이 데코레이터의 인스턴스를 만들어 사용한다.def print_hello():\tprint(\"Hello\")\tprint_hello = MyDecorator(print_hello)ex) 데코레이터의 예class MyDecorator:    def __init__(self, f):        print(\"Initializing MyDecorator...\")        self.func = f # MyDecorator의 func 데이터 속성이 print_hello를 받아둔다.    def __call__(self):        print (\"Begin :{0}\".format( self.func.__name__))        self.func()        print (\"End :{0}\".format(self.func.__name__))def print_hello():    print(\"Hello.\")print_hello = MyDecorator(print_hello) # MyDecorator의 인스턴스가 만들어지며 __init__()메소드가 호출된다. print_hello 식별자는 앞에서 정의한 함수가 아닌 MyDecorator의 객체이다.    print_hello() # __call__()메소드 덕에 MyDecorator 객체를 호출하듯 사용 할 수 있다.ex) 실행 결과&gt; decorator.pyInitializing MyDecorator ...Begin :print_helloHello.End :print_hello데코레이터를 사용하는 방법 2: @ 기호데코레이터(장식)이라는 이름답게 사용하려면 @데코레이터의 꼴로 사용하는 것이 바람직하다. 앞에서는 생성자를 호출해서 데코레이터의 인스턴스를 만들었지만, @ 기호로 시작하는 데코레이터 전용 문법을 이용하면 함수에 꽃장식을 꽂아놓듯 간단하게 데코레이터의 인스턴스를 만들 수 있다.ex) @ 데코레이터 예class MyDecorator:    def __init__(self, f):        print(\"Initializing MyDecorator...\")        self.func = f    def __call__(self):        print (\"Begin :{0}\".format( self.func.__name__))        self.func()        print (\"End :{0}\".format(self.func.__name__))@MyDecorator        def print_hello():    print(\"Hello.\")print_hello()ex) 실행 결과&gt; decorator2.pyInitializing MyDecorator ...Begin :print_helloHello.End :print_hellofor문으로 순회를 할 수 있는 객체 만들기이터레이터와 순회 가능한 객체파이썬에서 for문을 실행할 때 가장먼저 하는 일은 순회하려는 객체의 __iter__()메소드를 호출하는 것이다. __iter__()메소드는 이터레이터(Iterator)라고 하는 특별한 객체를 for문에게 반환한다.이터레이터는 __next__()메소드를 구현하는 객체를 말하는데, for문은 매 반복을 수행할 때마다 바로 이 __next__()메소드를 호출하여 다음 요소를 얻어낸다.ex) 이터레이터 예class MyDecorator:    def __init__(self, f):        print(\"Initializing MyDecorator...\")        self.func = f    def __call__(self):        print (\"Begin :{0}\".format( self.func.__name__))        self.func()        print (\"End :{0}\".format(self.func.__name__))@MyDecorator        def print_hello():    print(\"Hello.\")print_hello()ex) 실행 결과01234제네레이터제네레이터(Generator)는 이터레이터처럼 동작하는 함수이다. 하지만 이터레이터보다 훨씬 더 간편하게 구현가능하다.클래스를 정의하지 않아도 되고 __init__()메소드나 __next__()메소드를 구현 할 필요도 없다. 그저 함수 안에서 yield문을 이용하여 값을 반환하면 된다.  yeild문은 상당히 독특하다. return문처럼 함수를 실행하다가 값을 반환하지만, return문과는 달리 함수를 종료시키지는 않고 중단시켜 놓기만 한다.ex) 제네레이터 예def YourRange(start, end):    current = start    while current &lt; end:        yield current        current += 1    returnfor i in YourRange(0, 5):    print(i)ex) 실행 결과01234상속의 조건: 추상 기반 클래스“미운 오리 새끼”에서 아기 오리가 엄마 오리에게 미움을 받았던 이유는 단 하나.외모이다. 미운 아기 오리는 사실 오리가 아니라 백조였다. 엄마 오리는 아무리 봐도 오리라고는 할 수 없는 아기 백조를 내치고 다른 아기 오리들만을 챙겼다.프로그래머도 종종 엄마 오리와같은 입장이 될 때가 있다. 부모 클래스를 정의할 때 자식 클래스가 갖춰야 하는 모습을 규약으로 정의해 두고 이 규약을 따르지 않는 자식은 자식으로 인정하지 않는것이다. 추상 기반 클래스(Abstract Base Class)는 자식 클래스가 갖춰야 할 특징(메소드)을 강제하는 기능을 한다. 만약 추상 기반 클래스가 요구하는 메소드를 자식 클래스가 구현하지 않는다면, 자식 클래스의 인스턴스를 생성하고자 할 때 파이썬은 TypeError 예외를 일으킨다!from abc import ABCMetafrom abc import abstractmethodclass AbstractDuck(metaclass=ABCMeta):\t@abstractmethod\tdef Quack(self):\t\tpass  파이썬에서는 모든 것이 객체이다. 심지어 클래스도 객체이다. 그러니 이 객체의 자료형인 클래스가 존재해야 한다. 메타 클래스는 ‘클래스에 대한 정보를 갖고 있는 클래스’를 말한다. 클래스를 정의할 때 metaclass에 별도의 메타 클래스를 지정하지 않으면 type 클래스가 기본적으로 사용된다.오류를 어떻게 다뤄야 할까?예외파이썬에서 예외(Exception)는 문법적으로는 문제가 없는 코드를 실행하는 중에 발생하는 오류를 말한다.try ~ except로 예외 처리하기파이썬의 예외 처리는 try ~ except구문을 이용한다.      try 절 안에는 문제가 없을 경우, 정상적인 경우에 실행할 코드블록을 배치한다.        except 절에는 문제가 생겼을 때 뒤처리를 하는 코드 블록을 배치한다.  try: \t# 문제가 없을 경우 실행할 코드except:\t# 문제가 생겼을 때 실행할 코드여러 개의 except절 사용하기프로그램이 하는 일이 많아지고 코드의 양이 늘어나면 처리해야 할 예외도 늘어난다. 늘어난 예외의 종류에 따른 예외처리를 구현하려면 하나 이상의 except절을 사용해야 한다.try:\t# 문제가 없을 경우 실행할 코드except 예외형식1:\t# 문제가 생겼을 때 실행할 코드except 에외형식2:\t# 문제가 생겼을 때 실행할 코드try절을 무사히 실행하면 만날 수 있는 elsetry와 함께 사용하는 else는 if문에서 사용하는 else와는 다르다. 이 else절은 try절에 있는 코드블록 실행중에 아무런 예외가 일어나지 않으면 실행된다.  말하자면, try에 대한 else가 아닌 ‘except절에 대한 else’인 것이다.try:\t# 실행할 코드블록except: \t# 예외 처리 코드블록else:\t# except절을 만나지 않았을 경우 실행하는 코드블록ex) else 예my_list = [1, 2, 3]try:    print(\"첨자를 입력하세요:\")    index = int(input())    print(\"my_list[{0}]: {1}\".format(index, my_list[index]))except Exception as err:    print(\"예외가 발생했습니다 ({0})\".format(err))else:    print(\"리스트의 요소 출력에 성공했습니다.\")ex) 실행 결과&gt; try_except_else.py첨자를 입력하세요:1my_list[1]: 2리스트의 요소 출력에 성공했습니다.&gt; try_except_else.py첨자를 입력하세요:10예외가 발생했습니다 (list index out of range)어떤 일이 있어도 반드시 실행되는 finallyfinally는 else와 비슷하면서도 매우 다르다. else는 except절이 실행되면 실행되지 않고, except절이 실행되지 않으면 실행됐었다. finally는 예외가 발생했든 아무 일이 없든 간에 ‘무조건’실행된다.Exception 클래스파이썬은 오류 상황에 대한 정보를 담는 예외 형식을 다양하게 제공한다. 그 예외 형식들의 맨 위에는 BaseException 클래스가 있다. 파이썬의 모든 예외 형식은 BaseException 클래스로부터 상속받는다.  BaseException이 예외 클래스 족보의 시조이긴 하지만, 실질적인 시조로 간주되는 것은 그 밑에 있는 Exception클래스이다. 파이썬 코드를 작성하면서 사용되는 예외 형식은 거의 모두 Exception 클래스로부터 상속을 받는다.우리도 예외 좀 일으켜보자우리가 작성한 코드도 파이썬의 함수나 연산자처럼 예외를 일으킬 수 있다. 예외 객체를 매개변수로 넘겨 raise문을 실행하면 된다.ex) raise 예text = input()if text.isdigit() == False:\traise Exception(\"입력받은 문자열이 숫자로 구성되어 있지 않습니다.\"):raise문을 통해 발생시킨 예외는 except문으로 받아 처리하지 않으면 자신을 받아주는 곳이 나올 때 까지 상위 코드로 나아간다.  함수에서 일어난 예외를 함수 안에서 처리하지 않으면 그 예외는 함수의 호출자에게로 던져진다. 그 호출자도 처리를 안하고 그 호출자의 호출자도 처리를 안하다 보면 앞에서 본 것처럼 파이썬 인터프리터가 받나낸다.ex) 함수 안에서 예외를 일으키고 이것을 호출자에서 받아 처리하는 예def some_function():    print(\"1~10 사이의 수를 입력하세요:\")    num = int(input())    if num &lt; 1 or num &gt; 10:        raise Exception(\"유효하지 않은 숫자입니다.: {0}\".format(num))    else:        print(\"입력한 수는 {0}입니다.\".format(num))try:    some_function()except Exception as err: # 함수 안에서 일어난 예외가 except문으로 처리되지 않으면 함수 밖으로 다시 던져진다.    print(\"예외가 발생했습니다. {0}\".format(err))ex) 실행 결과&gt; raise_in_function.py1~10 사이의 수를 입력하세요:5입력한 수는 5입니다.&gt; raise_in_function.py1~10 사이의 수를 입력하세요:12예외가 발생했습니다. 유효하지 않은 숫자입니다.: 12내가 만든 예외 형식필요한 예외 형식(사용자 정의 예외 형식)을 직접 만들어 사용하려면 Exception 클래스를 상속하는 클래스를 정의하면 된다.class MyException(Exception):\tpassex) 직접 정의한 예외 형식 예class InvalidIntException(Exception):    def __init__(self, arg):        super().__init__('정수가 아닙니다.: {0}'.format(arg)) def convert_to_integer(text):    if text.isdigit(): # 부호(+, -) 처리 못함.        return int(text)    else:        raise InvalidIntException(text)if __name__ == '__main__':    try:        print('숫자를 입력하세요:')        text = input()        number = convert_to_integer(text)            except InvalidIntException as err:        print('예외가 발생했습니다 ({0})'.format(err))    else:        print('정수 형식으로 변환되었습니다 : {0}({1}'.format(number, type(number)))ex) 실행 결과&gt; InvalidIntException.py숫자를 입력하세요:123정수 형식으로 변환되었습니다 : 123(&lt;class 'int'&gt;&gt; InvalidIntException.py숫자를 입력하세요:abc예외가 발생했습니다. (정수가 아닙니다.: abc)",
        "url": "/blackruby-code//back/2017/12/10/brain2.html"
      }
      ,
    
      "back-2017-12-10-brain1-html": {
        "title": "뇌를 자극하는 파이썬 3 - 함수로 코드 간추리기",
        "tags": "Python",
        "date": "December 10, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "함수로 코드 간추리기이 단원을 시작하기에 앞서 알아둬야하는 용어!!정의정의(Definition)는 어떤 이름을 가진코드가 구체적으로 어떻게 동작하는지를 ‘구체적으로 기술’하는것을 말한다.호출과 반환모든 함수는 이름을 갖고 있다.이 이름을 불러주면 파이썬은 그 이름 아래 정의되어 있는 코드를 실행한다.      함수가 자신의 코드를 실행하면 결과가 나오는데, 그 결과를 자신의 이름을 부른 코드에게 돌려준다.        이때 함수를 부르는 행위를 호출(Call)이라고 하고, 함수를 부르는 코드를 호출자(Caller)라고 한다.        함수가 호출자에게 결과를 돌려주는 것을 반환(Return)이라고 한다.  함수 정의하기ex) 함수를 정의하는 문법&gt;&gt;&gt; def 함수이름( 매개변수 목록 ):&gt;&gt;&gt; \t# 코드블록&gt;&gt;&gt; \treturn 결과매개변수를 입력받는 여러가지 방법매개변수는 호출자와 함수 사이의 관계를 맺어주는 변수를 뜻한다.매개변수에 어떤 값이 들어있느냐에 따라서 함수의 동작이 달라진다def my_abs( arg ): # arg: 매개변수\tif ( arg &lt; 0 ):\t\tresult = arg * -1\telse:\t\tresult = arg\t\t\treturn result기본값 매개변수와 키워드 매개변수ex) 기본값 매개변수&gt;&gt;&gt; def print_string(text, count=1): # 매개변수를 정의 할 때 값을 할당해 놓으면 기본값 매개변수가 된다!\t \tfor i in range(count):\t \t\tprint(text)\t\t \t\t&gt;&gt;&gt; print_string('안녕하세요') # 호출할 때 두 번째 매개변수를 생략하면 기본값 1이 사용된다!안녕하세요&gt;&gt;&gt; print_string('안녕하세요', 2)안녕하세요안녕하세요ex) 키워드 매개변수&gt;&gt;&gt; def print_personel(name, position='staff', nationality='Korea'):\t \tprint('name = {0}'.format(name))\t \tprint('position = {0}'.format(position))\t \tprint('nationality = {0}'.format(nationality))\t \t&gt;&gt;&gt; print_personnel(name='윤경한') # position과 nationality는 기본값이 사용된다name = 윤경한position = staffnationality = Korea \t&gt;&gt;&gt; print_personnel(name='윤경한', nationality='ROK') # position만이 기본값을 사용!name = 윤경한position = staffnationality = ROK&gt;&gt;&gt; print_personnel(name='윤경한', position='인턴') # nationality만이 기본값을 사용!name = 윤경한position = 인턴nationality = Korea가변 매개변수상황에 따라 매개변수의 수가 달라지는 함수는 매개변수(Arbitrary Argument List)를 이용하면 된다!&gt;&gt;&gt; def 함수이름(*매개변수): # 매개변수 앞에 *를 붙이면 해당 매개변수는 가변으로 지정된다!\t \t코드블록*를 이용하여 정의된 가변 매개변수는 튜플이다!호출자에게 반환하기!함수가 호출자에게 값을 반환할 때에는 return문이 이용된다. return문은 대체로 다음 3가지 방법으로 사용된다!      return문에 결과 데이터를 담아 실행하기 =&gt; 함수가 즉시 종료되고 호출자에게 결과가 전달        return문에 아무 결과도 넣지 않고 실행하기 =&gt; 함수가 즉시 종료!        return문 생략하기 =&gt; 함수의 모든 코드가 실행되면 종료!  ex) return문에 결과 데이터를 담아 실행하기&gt;&gt;&gt; def multiply(a, b):\t \treturn a+b # return문은 함수의 실행을 종료시키고 자신에게 넘겨진 데이터를 호출자에게 전달한다!\t \t&gt;&gt;&gt; result = multiply(2, 3)&gt;&gt;&gt; resutl6  한 함수 안에 return문을 여러 개 두는 것이 문법적인 문제를 일으키는 것은 아니지만, 가급적이면 return문은 함수 코드블록의 마지막에 하나만 실행하도록 하는 것이 좋다!ex) return문에 아무 결과도 넣지 않고 실행하기&gt;&gt;&gt; def ogamdo(num):\t \tfor i in range(1, num+1):\t \t\tprint('제 {0}의 이해'.format(i))\t \t\tif i == 5:\t \t\t\treturn # 반환할 데이터 없이 실행하는 return문은 '반환'의 의미보다는 '함수종료'의 의미로 사용된다!&gt;&gt;&gt; ogamdo(3)제 1의 이해제 2의 이해제 3의 이해&gt;&gt;&gt; ogamdo(5)제 1의 이해제 2의 이해제 3의 이해제 4의 이해제 5의 이해&gt;&gt;&gt; ogamdo(8) # 8을 입력하면 for반복문은 8번 반복을 수행하려고 준비하겠지만 실행되는 return문 때문에 다섯 번 수행하면 함수가 종료되고 만다!제 1의 이해제 2의 이해함수 밖의 변수, 함수 안의 변수&gt;&gt;&gt; def scope_test(): \t \ta = 1 # 함수를 정의하는 시점에서는 a가 메모리에 생성되지 않았다. 함수를 호출하면 그제서야 함수의 코드가 실행되면서 a가 메모리에 생성된다! \t \tprint('a:{0}'.format(a)) \t \t&gt;&gt;&gt; a = 0 # 함수 밖에서 a를 정의하고 0으로 초기화한다!&gt;&gt;&gt; scope_test() # scope_test()가 호출되면 함수 내부에서 a를 정의하고 1로 초기화한다!a:1&gt;&gt;&gt; print('a:{0}'.format(a)) # 하지만 함수 밖에서 정의한 a를 출력해보면 여전히 0을 갖고 있음을 확인할 수 있다!a:0&gt;&gt;&gt; def scope_test(): \t \tglobal a # global 키워드는 지정한 변수의 유효 범위가 전역임을 알리고, 지역 변수의 생성을 막는다. 이 a는 scope_test() 함수 안에서 전역 변수로 사용된다! \t \ta = 1  \t \tprint('a:{0}'.format(a)) \t \t&gt;&gt;&gt; a = 0&gt;&gt;&gt; scope_test() # scope_test()는 0으로 초기화된 a에 접근해 1로 값을 변경한다!a:1&gt;&gt;&gt; print('a:{0}'.format(a)) # a를 출력해보면 scope_test() 함수 안에서 변경한 값 1이 들어있음을 확인 할 수 있다!a:1 \t자기 스스로를 호출하는 함수: 재귀 함수재귀 함수(Recursive Function)는 자기 스스로를 호출하는 함수를 말한다! 함수가 자기 자신을 부르는 것을 재귀 호출(Recursive Call)이라고 한다!  함수 자신이 호출자이자 피호출자가 되는것이다&gt;&gt;&gt; def some_func(count): \t \tif count &gt; 0: \t \t\tsome_func(count-1) \t\tprint(count)  재귀 함수는 편리하지만 호출 비용이 크다!컴퓨터가 더 많은 일을 하게 만들어서 성능이 떨어지는 소프트웨어를 만들게 된다. 좋은 성능이 요구되는 코드에서는 재귀 함수를 반복문으로 대체해서 사용하는 것이 좋다.함수를 변수에 담아 사용하기파이썬에서는 함수를 변수에 담아 사용할 수 있다!&gt;&gt;&gt; def print_something(a):  \t \tprint(a)  \t \t&gt;&gt;&gt; p = print_something # ()없이 함수의 이름만을 변수에 저장한다!&gt;&gt;&gt; p(123) # 변수의 이름 뒤에 ()를 붙여 함수처럼 호출한다!123&gt;&gt;&gt; p('abc')abc함수안의 함수: 중첩 함수함수 안에 정의된 함수를 중첩함수(Nested Fuction)라고 한다. 이 중첩 함수는 자신이 소속된 함수의 매개변수에 접근 할 수 있다.&gt;&gt;&gt; import math&gt;&gt;&gt; def stddev(*args):  \t \tdef mean():\t# 중첩 함수 ...  \t \t\treturn sum(args)/len(args) # ... 중첩 함수  \t \t\t  \t \tdef variance(m): # 중첩 함수 ...  \t \t\ttotal = 0   \t \t\tfor arg in args:  \t \t\t\ttotal += (arg - m ) ** 2 \t\t\treturn total/len(args)-1) # ... 중첩 함수 \t\t\t\tv = variance(mean())\treturn math.sqrt(v)\t&gt;&gt;&gt; stddev(2.3, 1.7, 1.4, 0.7, 1.9)0.6\t  mean()과 variance()는 중첩 함수의 특징을 활용하여, stddev()의 매개변수인 args에 접근해서 평균과 분산을 각각 계산한다!모듈과 패키지모듈(Module)은 대체적으로 ‘독자적인 기능을 갖는 구성 요소’를 의미한다!  파이썬에서는 각각의 소스파일을 일걸어 ‘모듈’이라고 한다.두 개의 소스 파일로 만드는 하나의 프로그램 예제ex) calculator.pydef plus(a, b):    return a+bdef minus(a, b):    return a-bdef multiply(a, b):    return a*b;def divide(a, b):    return a/bex) calc_tester.pyimport calculator # 불러올 모듈의 이름 calculator.py에서 '.py'는 생략한다.print(calculator.plus(10, 5))print(calculator.minus(10, 5)) # 모듈이름.함수()의 꼴로 clculator모듈의 함수를 호출한다.print(calculator.multiply(10, 5))print(calculator.divide(10, 5))ex) 실행 결과&gt; calc_tester.py155502.0함수들은 모두 calculator.py 모듈에 정의되어 있다. calc_tester.py 모듈에서 import문을 이용해 calculator.py 모듈을 불러들였기 때문에 이들 함수를 사용할 수 있었다.  모듈을 분리함으로써 코드를 재사용할 수 있는 장점이 있다.import에 대해import를 사용하는 방법의 2가지1.import 모듈 # 모듈의 실제 파일 명은 \"모듈.py\"2.from 모듈 import 변수 또는 함수모듈을 찾아서import문을 만나면 파이썬은 다음과 같은 순서로 모듈 파일을 찾아 나선다!      파이썬 인터프리터 내장 모듈        sys.path에 정의되어 있는 디렉토리  sys.path에 정의되어 있는 디렉토리는 크게 3가지로 나눌 수 있다.      파이썬 모듈이 실행되고 있는 현재 디렉토리        PYTHONPATH 환경변수에 정의되어 있는 디렉토리        파이썬과 함께 설치된 기본 라이브러리  메인 모듈과 하위 모듈“도대체 메인(main) 함수는 어디에 있는 거지?”  파이썬에서는 이른바’최상위 수준(Top Level)’에서 실행되는 스크립트가 있을 뿐, 메인 함수가 따로 없다. 최상위 수준 실행은 별 다른게 아니라 명령 프롬프트 창이나 탐색기를 이용하여 파이썬 모듈을 실행하는 것이다.파이썬에서는 “어떻게 만드느냐”가 아닌 “어떻게 실행하느냐”에 따라 메인 모듈이 결정된다.패키지파이썬에서는 모듈을 모아놓는 디렉토리를 패키지(Package)라고 한다. 영어로 패키지는 ‘꾸러미’라는 뜻을 가지고 있으니 파이썬에서는 ‘모듈 꾸러미’ 정도로 생각하면 된다.from my_package import calculator # 'from 패키지 import 모듈'의 골로 모듈을 불러온다! print(calculator.plus(10, 5))print(calculator.minus(10, 5))print(calculator.multiply(10, 5))print(calculator.divide(10, 5))__init__.py의 이해패키지란, ‘__init__.py파일을 갖고 있는 디렉토리’임을 뜻한다.      __init__.py파일은 대개 비워두는 것이 보통이다. 이 파일을 손대는 경우는 __all__이라는 변수를 조정할때 정도이다.        __all__은 패키지로부터 반입할 모듈의 목록을 정의하기 위해서 사용한다.  site-packages에 대해site-packags는 파이썬의 기본 라이브러리 패키지 외에 추가적인 패키지를 설치하는 디렉토리이다.만든 패키지나 모듈을 site-packages 디렉토리에 위치시키면 어느 경로에서든 접근해 반입할 수 있다.",
        "url": "/blackruby-code//back/2017/12/10/brain1.html"
      }
      ,
    
      "back-2017-12-09-brain-html": {
        "title": "뇌를 자극하는 파이썬 3 - 프로그램의 흐름 제어 1 ~ 6",
        "tags": "Python",
        "date": "December 9, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "뇌를 자극하는 파이썬 3코딩으로의 초대코딩의 즐거움 요소      무언가를 창조한다는 순수한 즐거움        다른 사람들에게 쓸모 있는 것을 만드는 기쁨        복잡한 퍼즐을 맞추듯 정교한 부품을 조립하여 완성하는 것에서 얻는 희열        항상 배우고 성장하는 즐거움        다루기 쉬운 매체를 이용해 작업하는 즐거움  코딩의 재미는 글로 다 표현이 불가능하다!!!축구를 제대로 해보기전까지는 축구가 얼마나 재미있는지 알 수 없는 것과 같다고 할 수 있다  취미로서의 코딩의 장점: 코딩은 전기세 이외에는 돈이 들지 않는다!!!문제 해결 능력을 키우는 코딩      이미 교육계에서 이루어진 여러 연구가 컴퓨터 프로그래밍이 논리적 추론 능력의 향상에 도움을 준다는 사실을 뒷받침하고 있다!        코딩을 즐겁게 하다보면 논리적 추론능력 뿐만 아니라 논리적 사고, 계획하는 능력, 일반적인 문제 해결능력이 저절로 향상된다!  우리가 페이스북 CEO처럼 수십조 원에 달하는 기업을 경영하고 있지는 않더라도 직장이나 삶에서 만나는 문제들을 풀어나가는데 코딩이 도움을 줄 수 있다!아이디어를 현실로!      재미있는 이야기 거리가 있어도 그림을 그릴 줄 알아야 그 이야기를 만화로 만들 수 있고, 글을 쓸 줄 알아야 소설을 만들 수 있다!        아무리 좋은 아이디어가 있더라도 코딩을 할 줄 모른다면 그것을 실체화 할 수 없다!  코딩을 할 수 있는 과학도는 얼마든지 컴퓨터 시뮬레이션을 만들어 이론을 검증해 볼 수 있다!보통의 발명가라면 아이디어가 떠올랐을 때 갖가지 재료를 구입해서 먼지 날리는 가공을 해야 하겠지만, 코드는 돈도 들지 않고 먼지도 날리지 않는 멋진 재료이다. 시간만 투자한다면 여러분의 아이디어를 살아 움직이는 것으로 만들 수 있다.누구나 할 수 있는 코딩컴퓨터가 세상에 처음 나왔을 때 얼마동안은 과학자와 기술자의 전유물이었지만, 오늘날에는 초등학생이나 식당주인처럼 누구나 배울 수 있다.      의식하지 못하고 코딩을 해왔을 수 있다. 워드프로세서나 스프레드 시트에서 매크로를 이용해서 작업을 자동화 시켜봤다면 그것이 프로그래밍이다!        2011년부터 영국에서는 ‘코딩은 새로운 라틴어’라는 캠패인을 통해 청소년들의 프로그래밍 교육을 확대하고 있다.        뉴욕의 블룸버그 시장도 자신의 2012년 새해 목표가 ‘코딩 익히기’라고 발표하여 사람들에게 코딩에 대한 관심을 불러 일으켰다!  코딩을 배우기 전에 읽는 컴퓨터 구조론폰노이만 구조천재 과학자 폰노이만은 1945년에 데이터와 명령어를 보관하는 기억 장치(MEMORY) 그리고 데이터의 가공을 담당하는 중앙처리장치(CPU)로 구성되는 현대 컴퓨터의 구조를 최초로 정의했다.  현재 우리가 사용하고 있는 거의 모든 전자 기기들은 폰노이만 구조를 이용하고 있다.중앙 처리 장치 (CPU)중앙처리장치는 컴퓨터에서 가장 중요한 장치라고 할 수 있다. 컴퓨터가 수행하는 계산은 모두 이 CPU를 통해서 이루어지기 때문이다.  자동차로 비유하면 엔진과 같다*컴퓨터를 여러 연주자로 이루어진 오케스트라에 비한다면, 제어 장치는 이 오케스트라의 지휘자라고 할 수 있다. 제어장치와 산술 논리 장치는 다음과 같은 과정을 통햇 곡을 연주한다.1. 먼저 제어장치가 기억 장치로부터 명령어를 가져온다(Fetch)2. 제어장치는 가져온 명령어를 해독(Decode)한다.3. 제어장치는 해독한 명령어에 따라 산술 논리 장치에 데이터를 옮기고 어떤 연산을 수행할지를 지시한다.4. 산술 논리 장치는 제어 장치가 지시한 대로 계산을 수행(Execute)한다.5. 그리고 수행한 결과를 기억 장치에 다시 저장(Store)한다.ex) 어떤 CPU의 클럭 주파수가 1GHz라고 한다면, 그 CPU는 1초에 10억회의 명령 주기를 수행하는 성능을 지닌것이다!!!기억 장치 (Memory)기억장치는 데이터와 함께 명령어를 저장하는 역할을 한다. 메모리의 용량이 클 수록 더 많은 데이터와 명령어를 저장할 수 있고, 메모리가 빠르게 동작할수록 더 빠르게 CPU와 데이터와 명령어를 교환 할 수 있다.입력/출력 장치다양한 입출력 장치들은 ‘입출력 버스’를 통해 중앙 처리 장치, 기억 장치와 정보를 주고 받는다.  버스는 우리가 자주 이용하는 대중교통 수단인 바로 그 버스와 철자가 동일하지만 컴퓨터 과학에서 버스라고 하면 ‘컴퓨터의 정보 전송 회로’를 말한다.중앙처리장치와 기억 장치, 그리고 입출력 장치는 버스로 연결되어 있다.컴퓨터에서는 중앙 처리 장치, 기억 장치, 입출력 장치가 동일한 입출력 버스를 사용함으로써 빠르게 동작하는 중앙 처리 장치가 느려터진 입출력 장치 때문에 제 성능을 낼 수 없는 문제가 발생한다!이문제를 해결하기 위해서 버스를 두가지로 나누었다!      먼저 CPU와 기억장치는 시스템 버스로 묶고, 그 다음 다양한 입출력 장치들은 입출력 버스로 묶어 CPU의 입출력 모듈에 연결한다.        4차선 고속도로에서 바깥쪽 차선은 저속차량이 이용하고 안쪽 차선은 고속차량이 달리도록 하는 것과 같다.  운영체제와 애플리케이션운영체제는 애플리케이션에 API(Application Programming Interface)를 제공하여 운영체제가 제어하고 있는 하드웨어를 이용할 수 있도록 한다.  만약 운영체제가 없었다면 맥북 에어의 하드웨어 제어코드와 MS 서피스 하드웨어 제어코드를 일일이 애플리케이션안에 작성하는 대참사가 발생했을 것이다.소프트웨어는 무엇으로 만드는가?“허리를 바로 세우고 왼팔을 앞으로 내저으며 오른팔을 뒤로 내저어라. 동시에 몸의 중심을 앞으로 옮기며 왼발을 받침으로 삼고 오른발을 앞으로 내밀어라. 그리고 별도의 지시가 있기 전까지 이 행동을 계속하라.”그냥 “앞으로 가”라고 하면 되는데 저런 식으로 사람에게 지시를 내리는 경우는 거의 없을 것이다.  컴퓨터는 어떤 일이든 세세하게 지시해주지 않으면 아무것도 하지 못한다.이점을 역으로 이용해서 개발된 프로그래밍 언어가 어셈블리이다!!어셈블리어는 복잡한 기계어 명령을 사람이 이해할 수 있는 기호나 단어로 바꿔 만든 것이다.물론 컴퓨터는 “앞으로 가”라는 명령어를 전혀 이해하지 못한다. 컴퓨터는 0과 1만 알아듣기 때문이다!  프로그래머가 어셈블리어로 프로그램 코드를 작성한 후에는 컴파일러라는 소프트웨어를 이용하여 실행 파일을 만들어 냈는데, 이 실행 파일이 바로 프로그램이었다.어셈플리어처럼 프로그램을 작성하기 위해 만들어진 인공 언어체계를 ‘프로그래밍 언어’라고 한다      컴파일러는 소스코드를 컴파일하여 실행파일로 만들기 때문에 프로그램을 실행하기 위해서는 ‘실행파일’만 있으면 되며, 소스코드는 전혀 필요하지 않다.        인터프리터는 소스코드를 미리 실행파일로 만드는 작업이 필요하지 않다. 소스코드를 실시간으로 기계어로 해석해서 실행해주기 때문이다.  데이터 다루기: 수와 텍스트와 비트변수변수는 데이터를 담는 메모리 공간이다!여기에는 수를 담을 수도 있고, 글을 담을 수도 있다. 목록이나 이미지 데이터도 담을 수 있다.&gt;&gt;&gt; a = 2020&gt;&gt;&gt; a2020‘a = 2020’은 “a라는 이름의 변수를 만들고 2020을 해당변수에 입력하라”라는 의미의 코드이다.변수 = 데이터를 담는 공간수 다루기정수정수는 음의 정수, 0, 양의 정수를 모두 통틀어 일컫는 말이다!  파이썬에서는 메모리가 허용하는한, 무한대의 정수를 다룰 수 있다.파이썬은 코드가 실행될 때 변수의 형식을 결정한다.파이썬 인터프리터는 f = -3을 실행할 때가 되어서야 f가 정수라고 판단한다!&gt;&gt;&gt; f = -3&gt;&gt;&gt; type(f)&lt;&lt;class 'int'&gt;&gt;여러 가지 진법으로 수 출력하기파이썬에서 16진수와 2진수로 표현하는 방법!      숫자를 16진수로 출력하려면 hex() 함수를 사용해야 한다.        숫자를 2진수로 출력하려면 bin() 함수를 사용해야 한다.  실수파이썬은 실수를 지원하기 위해 부동 소수형을 제공한다.부동소수형은 컴퓨터로 소수의 소수점을 표현하는 방식 중 하나이다.      부동 소수형은 8바이트만을 이용해서 수를 표현한다. 즉, 한정된 범위의 수만 표현할 수 있다.        디지털 방식으로 소수를 표현해야 하므로 정밀도에 한계가 있다.  다음과 같이 변수에 소수점이 있느 수를 대입하면 부동 소수형 변수가 만들어진다!!&gt;&gt;&gt; a = 3.14&gt;&gt;&gt; a3.14type() 함수를 사용해서 자료형을 확인하기!&gt;&gt;&gt; type(a) # a는 3.14&lt;&lt;class 'float'&gt;&gt;  ‘float’은 부동소수점을 나타낸다부동 소수형의 8바이트부동 소수형은 8바이트만을 이용해서 실수를 표현한다. 비록 8바이트만 가지고 수를 표현하지만, 굉장히 넓은 범위의 수를 다룬다.  파이썬의 부동 소수형은 IEEE754라는 표준을 따른다.ex) 7.25를 정규화하여 가수 비트에 담는다면?7은 2진수로 111, 0.25는 0.01이니 합치면 111.01이 된다. 이를 정규화하면 1.1101이 된다. 시작되는 1은 제거하고 담는다.  이러한 일련의 과정들을 ‘정규화’라고 한다.한편, 8바이트(64비트) 부동 소수형의 경우 지수는 -1024부터 +1023까지의 값을 가질 수 있는데, 2의 보수로 이 값을 표현하면 비교 연산이 복잡해지기 때문에, 성능은 저하된다. 따라서 지수에는 실제 값에 1023을 더해 저장하는 바이어싱(biasing)을 사용한다.  결국 지수부에 담기는 비트에는 0보다 큰 양수만 담긴다.math 모듈을 이용한 계산파이썬 코드를 담고 있는 .py 확장자를 가진 파일을 ‘모듈(module)’이라고 한다. 파이썬은 인터프리터와 함께 매우 다양한 모듈을 제공한다.  모듈을 사용하려면 import구문을 이용한다&gt;&gt;&gt; import math π와 e원주율 π와 자연상수 e는 수학에서 사용되는 주요 상수이다&gt;&gt;&gt; math.pi # 원주율 π3.141592 ... &gt;&gt;&gt; math.e # 자연상수 e2.718818 ...절대값, 버림과 반올림            함수      설명      비고                  abs()      절대값 계산 함수      내장 함수              round()      반올림 계산 함수      내장 함수              trunc()      버림 계산 함수      math 모듈        내장 함수(Built-in function)은 파이썬이 인터프리터에 함께 탑재해 놓은 함수로써 별도의 import 구문을 통하지 않고도 사용할 수 있는 함수이다.abs() 함수의 사용 예 :&gt;&gt;&gt; abs(10)10&gt;&gt;&gt; abs(-10)10round() 함수의 사용 예 :&gt;&gt;&gt; round(1.4)1&gt;&gt;&gt; round(1.5)2trunc() 함수는 1.4, 1.5, 1.9를 모두 1로 만든다. trunc() 함수는 앞의 두 함수와는 달리 내장 함수가 아니기 때문에 사용할 때 ‘math.’를 붙여야 한다.trunc() 함수의 사용 예 :&gt;&gt;&gt; import math&gt;&gt;&gt; math.trunc(1.4)1&gt;&gt;&gt; math.trunc(1.5)1&gt;&gt;&gt; math.trunc(1.9)1팩토리얼팩토리얼은 1부터 어떤 양의 정수 n까지의 정수를 모두 곱한 것을 말한다. 예를 들어 5팩토리얼을 수식을 나타내면 다음과 같다.5! = 5x4x3x2x1  math 모듈에서 제공하는 팩토리얼 함수의 이름은 factorial()이다.            함수      설명                  factorial()      팩토리얼 계산 함수      도와 라디안도(degree)는 원을 360도로 표현한 것이고, 라디안(radian)은 반지름의 1인 원에서 호의 길이가 1인 부채꼴의 각을 기본단위로 삼아 2π로 표현한 것이다. 즉 360도 = 2π 인 것이다!삼각 함수math 모듈에서 제공하는 삼각함수 목록            함수      설명                  cos()      입력된 라디안에 대한 코사인 값을 계산              sin()      입력된 라디안에 대한 사인 값을 계산              tan()      입력된 라디안에 대한 탄젠트 값을 계산              acos()      cos()의 역함수              asin()      sin()의 역함수              atan()      tan()의 역함수      제곱과 제곱근파이썬으로 제곱을 계산한다면 다음과 같이 가능하다&gt;&gt;&gt; 3*39&gt;&gt;&gt; 3*3*327텍스트 다루기컴퓨터는 수를 계산하기 위해 만들어진 기계이다.이 수 기게를 이용해서 컴퓨터 과학자들이 글을 다루는 방법을 고안해 냈는데, 각 문자마다 번호를 붙이고 메모리에 저장하거나 계산을 할 때에는 수로 처리하고 모니터나 프린터에 출력할 때는 사람이 아는 문자로 출력하는 방식이다.파이썬에서는 텍스트를 다루는 자료형으로 String을 제공한다. String은 영어로 끈, 줄 등의 뜻을 가지고 있으므로 문자를 끈으로 가지런히 묶어놓는 것으로 이해하면 된다.문자열 메소드순서열로부터 물려받은 기능외에도, 문자열은 다양한 기능의 함수를 자체적을 탑재하고 있다.내장 함수들과는 달리 이런 함수는 문자열 자료형 안에 들어 있다. 이렇게 특정 자료형이 갖고 있는 함수를 메소드(Method)라고 한다.수에서 텍스트로, 텍스트에서 수로print(\"첫 번째 수를 입력하세요. : \")a = input()print(\"두 번째 수를 입력하세요. : \")b = input()result = int(a) * int(b)print(\"{0} * {1} = {2}\".format(a, b, result))  실행 결과&gt;input_multiply.py첫 번째 수를 입력하세요 :5두 번째 수를 입력하세요 :45 * 4 = 20파이썬은 숫자 형식의 생성자 안에 문자열을 해당 형식으로 변환하는 기능을 탑재했다.비트 다루기컴퓨터는 원래 0과 1의 비트 데이터만을 다루는 기계이다. 하지만 파이썬에서 다루는 데이터의 기본 단위는 ‘바이트(Byte)’이다. 1바이트는 비트를 무려 8개나 담을 수 있는 크기다.비트 수준에서 데이터를 가공해야 하는 경우도 종종 생기는데 비트 연산자는 바로 이를 위한 연산자이다!시프트 연산자시프트 연산자(Shift Operator)는 비트를 왼쪽이나 오른쪽으로 이동시키는 기능을 한다.비트 논리 연산자논리 연산은 참 또는 거짓의 진리 값을 피연산자로 하는 연산이다. 비트 논리 연산(Bitwise Logical Operation)은 데이터의 각 비트에 대해 수행하는 논리 연산이다. 파이썬에서 제공하는 비트 논리 연산자는 네 가지가 있다.            연산자      이름                  &amp;      논리곱(AND)연산자              |      논리합(OR)연산자              ^      배타적 논리합(XOR)연산자              ~      보수(NOT)연산자        비트 논리 연산자는 bool 형식 외에도 정수 계열 형식의 피연산자에 대해서도 사용 할 수 있다.데이터 다루기: 리스트와 튜플과 딕셔너리리스트리스트(List)는 이름에서도 알 수 있듯이 데이터의 목록을 다루는 자료형이다.단일 데이터가 명함이라면, 리스트는 명함을 모아두는 명함집이라고 할 수 있다.명함집에 명함을 꽂아 넣을 수 있는 슬롯(Slot)이 있는 것처럼, 리스트들도 슬롯이 있다.리스트의 각 슬롯에 꽂혀있는 개별 데이터를 일컫어 요소(Element)라고 한다.리스트 메소드            메소드      설명                  append()      리스트의 끝에 새 요소를 추가한다.              extend()      기존 리스트에 다른 리스트를 이어 붙입니다. + 연산자와 같은 기능을 한다고 할 수 있다.              insert()      첨자로 명시한 리스트 내의 위치에 새 요소를 삽입한다.              remote()      매개변수로 입력한 데이터를 리스트에서 찾아 발견한 첫 번째 요소를 제거한다.              pop()      리스트의 마지막 요소를 뽑아내어 리스트에서 제거한다.              index()      리스트 내에서 매개변수로 입력한 데이터와 일치하는 첫 번째 요소의 첨자를 알려준다.              count()      매개변수로 입력한 데이터와 일치하는 요소가 몇 개 있는지 센다.              sort()      리스트 내의 요소를 정렬한다.              reverse()      리스트 내 요소의 순서를 반대로 뒤집는다.      튜플리스트는 sort()메소드를 이용해 요소의 순서를 정렬하지만 튜플은 변경이 불가능하므로 아예 해당 메소드가 제공되지 않는다. 새로운 요소를 추가하거나 삽입할 수 있고, 기존 요소를 삭제할 수도 있지만 튜플은 이러한 작업을 허용하지 않는다.튜플 = 변경이 불가능한 자료형!  튜플도 리스트와 문자열처럼 순서열 자료형이기 때문에 대괄호를 이용한 참조 연산과 슬라이싱, 튜플간 결합 등의 연산이 가능하다!ex) 슬라이싱 예:&gt;&gt;&gt; a = (1, 2, 3, 4, 5, 6)&gt;&gt;&gt; a[:3](1, 2, 3)&gt;&gt;&gt; a[4:6](5, 6)ex) + 연산자 튜플 결합의 예:&gt;&gt;&gt; a = (1, 2, 3)&gt;&gt;&gt; b = (4, 5, 6)&gt;&gt;&gt; c = a + b&gt;&gt;&gt; a (1, 2, 3)&gt;&gt;&gt; b(4, 5, 6)&gt;&gt;&gt; c(1, 2, 3, 4, 5, 6)패킹과 언패킹!다음과 같이 여러가지 데이터를 튜플로 묶는 것을 튜플 패킹(Tuple Packing)이라고 한다!&gt;&gt;&gt; a = 1, 2, 3&gt;&gt;&gt; a(1, 2, 3)그리고 다음과 같이 튜플의 각 요소를 여러 개의 변수에 할당하는 것을 튜플 언패킹(Tuple Unpacking)이라고 한다!&gt;&gt;&gt; one, two, three = a&gt;&gt;&gt; one 1&gt;&gt;&gt; two2&gt;&gt;&gt; three3  튜플의 언패킹을 활용하면 여러 개의 변수에 한번에 할당을 수행할 수 있다!튜플 메소드튜플은 변형이 불가능한 자료형이라서 제공하는 메소드가 index()와 count() 두개뿐이다!!!            메소드      설명                  index()      매개변수로 입력한 데이터와 일치하는 튜플 내 요소의 첨자를 알려준다!              count()      매개변수로 입력한 데이터와 일치하는 요소가 몇 개 있는지 센다!      딕셔너리딕셔너리(Dictionary)는 사용법 측면에서 보면 리스트와 비슷하다고 볼 수 있다!  리스트처럼 첨자를 이용해서 요소에 접근하고, 또 그 요소를 변경 할 수도 있다!딕셔너리의 첨자는 키(Key)라고 하고, 이 키가 가리키는 슬롯에 저장되는 데이터를 값(Value)라고 한다!딕셔너리는 키-값의 쌍으로 구성된다.  딕셔너리는 키를 이용해서 단번에 데이터가 저장된 위치의 주소를 계산해내는데 이런 작업을 해싱(Hashing)이라고 한다!프로그램 흐름 제어하기!흐름 제어를 시작하기 전에bool 자료형bool은 True와 False 두 가지 값을 나타내는 자료형이다!&gt;&gt;&gt; a = 3 &gt; 2&gt;&gt;&gt; aTrue&gt;&gt;&gt; a = 2 &gt; 3&gt;&gt;&gt; aFalse&gt;&gt;&gt; type(a)&lt;&lt;class 'bool'&gt;&gt;논리 연산자not, and, or는 참과 거짓을 다루는 논리 연산자이다!흐름 제어문과 조건문흐름 제어문은 흐름을 분기하거나 반복하기 전에 조건문의 결과가 참인지를 평가한다!  bool 형식을 비롯해서 숫자, 문자열, 딕셔너리 등 다양한 객체가 사용된다- False- None- 숫자 0 예) 0, 0.0등- 비어있는 순서열: 예)\",(),[]등- 비어있는 딕셔너리: 예) {}코드블록과 들여쓰기코드블록(Code Block)은 여러 코드가 이루는 일정한 구역을 말하는데, 프로그래밍 언어마다 이것을 표현하는 방법은 각기 다르다!비교 연산자            연산자      설명                  ==      양쪽에 위치한 피연산자가 서로 같으면 True, 그렇지 않으면 False이다!              !=      양쪽에 위치한 피연산자가 서로 다르면 True, 그렇지 않으면 False이다!              &gt;      왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 크면 True, 그렇지 않으면 False이다!              &gt;=      왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 크거나 같으면 True, 그렇지 않으면 False이다!              &lt;      왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 작으면 True, 그렇지 않으면 False이다!              &lt;=      왼쪽에 위치한 피연산자가 오른쪽 피연산자보다 작거나 같으면 True, 그렇지 않으면 False이다!      분기문프로그램의 흐름을 가르는 문장을 일컬어 나눌 분, 갈림길 기, 분기문이라고 한다!if문if는 어떤 상황을 가정할 때 사용하는 말이다!  ‘만약 ~라면’의 뜻을 갖고 있다. ‘만약 입력받은 수 a가 0이라면’처럼if문은 참아니면 거짓으로 평가될 수 있어야한다.&gt;&gt;&gt; if 조건: # if 뒤에 흐름을 가를 조건이 위치하고, 그 뒤에 콜론(:)이 온다&gt;&gt;&gt; \t명령1\t# :뒤에는 들여쓰기로 이루어진 코드블록이 온다. 이 코드블록은 if문의 조건이 True일 경우 실행된다!&gt;&gt;&gt; \t명령2&gt;&gt;&gt; else: # if문의 조건을 충족하지 않을 때, 즉 조건 평가의 결과가 False일 때의 흐름은 else로 향한다!. else뒤에도 코드블록이 오므로 콜론(:)이 위치해야 한다.&gt;&gt;&gt; \t명령1\t&gt;&gt;&gt; \t명령2*ex) if else의 예제:import sysprint('수를 입력하세요 : ')a = int(input())if a == 0 :    print('0은 나눗셈에 이용할 수 없습니다.')    sys.exit(0)print('3 /', a, '=', 3/a)      파이썬 프로그램을 종료하는 exit() 함수를 사용하기 위해 sys패키지를 임포트한다        a가 0인 경우에 경고 메세지를 출력한 뒤 프로그램을 종요시킨다.  ex) elif는 else if를 줄여 만든 파이썬 키워드 이다.print('요일(월~일)을 입력하세요 : ')dow = input()if dow == '월' : # 첫번째 조건은 항상 if로 시작    print('Monday')elif dow == '화' : # 두번째 조건부터는 elif를 이용!    print('Tuesday')elif dow == '수' :    print('Wednesday')elif dow == '목' :    print('Thursday')elif dow == '금' :    print('Friday')elif dow == '토' :    print('Saturday')elif dow == '일' :    print('Sunday')else : # 마지막의 else는 생략가능!    print('잘못 입력된 요일입니다.')반복문루프문(Loop Statement)이라고도 한다.while문while문은 코드의 흐름을 반복시킬 수 있는 파이썬의 코드이다.ex) while&gt;&gt;&gt; while 조건:&gt;&gt;&gt; \t코드블록   while키워드가 먼저 위치하고 그 다음에 조건이 오게 된다.조건뒤에는 코드블록을 위치시켜서 전에 콜론(:)이 있어야 한다.while이 영어로 ‘~하는동안’이라는 뜻이므로 while코드를 읽을 때에는 ‘조건이 참인 동안’이라고 해석하면 된다!print('몇 번 반복할까요? : ')limit = int(input())count = 0while count &lt; limit :    count = count + 1    print('{0}회 반복.'.format(count))        print('반복이 종료되었습니다.')for 문for문은 조건을 평가하는 것이 아니라 순서열을 순회하다가 순서열의 끝에 도달했는지를 본다ex) for&gt;&gt;&gt; for 반복변수 in 순서열:&gt;&gt;&gt; \t코드블록  for문에서 사용하는 순서열은 리스트, 튜플, 심지어 문자열 등 어떤 것을 사용해도 괜찮다!for문은 순서열의 각 원소를 처음부터 차례로 순회하면서 반복변수에 담아낸다.for s in '뇌를 자극하는 파이썬' :    print(s)ex) 중첩 for문for i in range(1, 6) :        for j in range(i) : # 바깥의 for문에서 입력한 반복변수 i가 멈춤값이다!            print( \"*\", end = \"\", ) # end=\"\"을 매개변수로 입력하면 줄바꿈을 출력하지 않는다!                print() # 아무것도 입력하지 않으면 줄바꿈만 출력continue와 break로 반복문 제어하기파이썬에서 continue문은 반복문이 실행하는 코드블록의 나머지 부분을 실행하지 않고 다음 반복으로 건너가도록 흐름을 조정한다.for i in range(10) :    if i % 2 == 1 :        continue # i가 홀수일 때 코드블록의 나머지 부분을 실행하지 않고 다음 반복으로 바로 건너간다.            print(i) # continue가 실행되는 경우에는 이 코드는 실행되지 않는다.        ",
        "url": "/blackruby-code//back/2017/12/09/brain.html"
      }
      ,
    
      "restfulapi-2017-12-01-restful-html": {
        "title": "RESTful API 작성 팁",
        "tags": "RESTfulAPI",
        "date": "December 1, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "restfulAPI 문서 작성하는 방법API가 세상을 집어삼키고 있다는 말이 사실이라면, API를 이해하기 쉽고 사용하기도 쉽게 만드는 일이 굉장히 중요해 진다. API 문서를 일종의 요리법이라고 생각해본다면, 잘 작성된 요리법을 따라 요리사가 멋진 음식을 만들 듯이, 간결하면서 유익하며 읽기에도 쉬운 API문서가 있어야만 다른 개발자들이 API를 사용하여 멋진 무언가를 만들 수 있다.1. 코드를 작성하기 전에 스스로에게 도움이 되기API를 잘 설계해 두었다면 문서화하기도 쉬울 것이다. 일관성을 유지해야한다. 일관된 명명 규칙을 사용하고 기존의 표준을 따른다면, 한번만 문서화를 해도 된다. HTTP 상태 코드를 예로 들면, 의미를 왜곡시키지말고, 새로운 상태 코드를 만들지도 않아야 한다!  역시 200은 정상(OK)이라는 의미이고, 404는 찾지 못했다(Not Found)라는 의미이다.HTTP 메소드도 마찬가지다. 새로 만들 땐 POST, 삭제는 DELETE를 사용해야 한다. 이들은 이미 정립된 규약이다. 단 하나의 예외가 있다면 PUT과 PATCH이다. 이 메소드들은 아직 문서가 불분명하다.2. 사용자 관점에서 문서 작성하기사용자들은 여러분이 작업할 때 생각하는 방식으로 API에 접근한다는 점을 기억해야 한다. 예를 들어, 여러분이 결제 처리기를 제공한다면, 사용자들은 요금과 환불, 소비자, 신용카드 등을 떠올릴 것이다. 그렇다면 API문서 역시도 이런 과정들을 그룹화 해야 한다. 깃헙은 훌륭한 RESTfulAPI 문서의 모범을 제공한다.3. URI를 전면에 내세우거나 중심에 두지 말아야한다문서에서 URI를 가장 명확하게 만드는 방법은 사용자에게 API 로직과 HTTP 클라이언트 사이의 연결 관계를 이해시키는 것이다. 많은 사용자들이 URI를 하드코딩하기 때문에, 만약에 여러분이 하이퍼링크가 포함된 콘트롤을 사용하다가 변경한다면 API를 사용하는 클라이언트들도 망가질 것이다.4. 글쓰기 도구로 작성하기가능한 한 글쓰기에 적합한 형태로 작성해야 한다.5. 예제 코드는 자동으로 생성하고, 설명과 잘 연결되어야 한다6. 미래를 대비해야 한다리처드슨의 성숙도 모델을 통해 여러분의 API가 어느 단계에 와 있는 지 알 수 있다. 문서화 도구가 허용하는 범위 이상으로 코드를 RESTful하게 하고 싶다면(혹은 그럴 계획이 있다면), 문서화 도구가 발목을 잡을지도 모른다.",
        "url": "/blackruby-code//restfulapi/2017/12/01/restful.html"
      }
      ,
    
      "back-2017-11-29-jump6-html": {
        "title": "Jump to Python - 정규표현식과 XML",
        "tags": "Python",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "정규표현식과 XML정규 표현식 살펴보기정규 표현식(Regular Expressions)은 복잡한 문자열을 처리할 때 사용하는 기법으로, 파이썬만의 고유 문법이 아니라 문자열을 처리하는 모든 곳에서 사용된다.정규 표현식 시작하기정규 표현식의 기초, 메타 문자정규 표현식에서 사용하는 메타 문자(meta characters)에는 다음과 같은 것들이 있다.. ^ $ * + ? { } [ ] \\ | ( )문자 클래스 [ ]우리가 가장 먼저 살펴 볼 메타 문자는 바로 문자 클래스(character class)인 [ ]이다. 문자 클래스로 만들어진 정규식은 “[와 ] 사이의 문자들과 매치”라는 의미를 갖는다.Dot(.)정규 표현식의 Dot(.) 메타 문자는 줄바꿈 문자인 \\n를 제외한 모든 문자와 매치됨을 의미한다.반복 (*)ca*t이 정규식에는 반복을 의미한는 * 메타문자가 사용되었다. 여기서 사용된 *의 의미는 *바로 앞에 있는 문자 a가 0부터 무한대로 반복될 수 있다는 의미이다.반복 (+)반복을 나타내는 또 다른 메타 문자로 +가 있다. +는 최소 1번 이상 반복될 때 사용한다. 즉, *가 반복 횟수 0부터라면 +는 반복 횟수 1부터인 것이다.ca+t  위 정규식의 의미는 다음과 같다.“c + a(1번 이상 반복) + t”반복 ({m,n}, ?){ } 메타 문자를 이용하면 반복 횟수를 고정시킬 수 있다. {m, n} 정규식을 사용하면 반복 횟수가 m부터 n까지인 것을 매치할 수 있다. 또한 m 또는 n을 생략할 수도 있다. 만약 {3,} 처럼 사용하면 반복 횟수가 3 이상인 경우이고 {,3} 처럼 사용하면 반복 횟수가 3 이하인 것을 의미한다※ {1,}은 +와 동일하며 {0,}은 *와 동일하다.1. {m}ca{2}t“c + a(반드시 2번 반복) + t”2. {m, n}ca{2,5}t“c + a(2~5회 반복) + t”파이썬에서 정규 표현식을 지원하는 re 모듈파이썬은 정규 표현식을 지원하기 위해 re(regular expression의 약어) 모듈을 제공한다&gt;&gt;&gt; import re&gt;&gt;&gt; p = re.compile('ab*')re.compile 을 이용하여 정규표현식(위 예에서는 ab*)을 컴파일하고 컴파일된 패턴객체(re.compile의 결과로 리턴되는 객체 p)를 이용하여 그 이후의 작업을 수행할 것이다.정규식을 이용한 문자열 검색            Method      목적                  match()      문자열의 처음부터 정규식과 매치되는지 조사한다.              search()      문자열 전체를 검색하여 정규식과 매치되는지 조사한다.              findall()      정규식과 매치되는 모든 문자열(substring)을 리스트로 리턴한다.              finditer()      정규식과 매치되는 모든 문자열(substring)을 iterator 객체로 리턴한다      match 객체의 메서드            method      목적                  group()      매치된 문자열을 리턴한다              start()      매치된 문자열의 시작 위치를 리턴한다              end()      매치된 문자열의 끝 위치를 리턴한다              span()      매치된 문자열의 (시작, 끝)에 해당하는 튜플을 리턴한다.      컴파일 옵션정규식을 컴파일할 때 다음과 같은 옵션을 사용할 수 있다.      DOTALL(S) - . 이 줄바꿈 문자를 포함하여 모든 문자와 매치할 수 있도록 한다.        IGNORECASE(I) - 대소문자에 관계없이 매치할 수 있도록 한다.        MULTILINE(M) - 여러줄과 매치할 수 있도록 한다. (^, $ 메타문자의 사용과 관계가 있는 옵션이다)        VERBOSE(X) - verbose 모드를 사용할 수 있도록 한다. (정규식을 보기 편하게 만들수 있고 주석등을 사용할 수 있게된다.)  옵션을 사용할 때는 re.DOTALL처럼 전체 옵션명을 써도 되고 re.S처럼 약어를 써도 된다.강력한 정규 표현식의 세계로메타 문자      +, *, [], {} 등의 메타문자는 매치가 진행될 때 현재 매치되고 있는 문자열의 위치가 변경된다. (보통 소모된다고 표현한다.) 하지만 이와 달리 문자열을 소모시키지 않는 메타 문자들도 있다.        |          | 메타문자는 “or”의 의미와 동일하다. A|B 라는 정규식이 있다면 이것은 A 또는 B라는 의미가 된다.            ^          ^ 메타문자는 문자열의 맨 처음과 일치함을 의미한다. 이전에 알아보았던 컴파일 옵션 re.MULTILINE 을 사용할 경우에는 여러줄의 문자열에서는 각 라인의 처음과 일치하게 된다.            $          $ 메타문자는 ^ 메타문자의 반대의 경우이다. $는 문자열의 끝과 매치함을 의미한다.            \\A          \\A는 문자열의 처음과 매치됨을 의미한다            \\Z          \\Z는 문자열의 끝과 매치됨을 의미한다            \\b          \\b는 단어 구분자(Word boundary)이다            \\B          \\B 메타문자는 \\b 메타문자의 반대의 경우이다.      그룹핑ABC라는 문자열이 계속해서 반복되는지 조사하는 정규식을 작성하고 싶다고 하자. 어떻게 해야 할까? 지금까지 공부한 내용으로는 위 정규식을 작성할 수 없다. 이럴 때 필요한 것이 바로 그룹핑(Grouping) 이다.  위의 경우는 다음처럼 그룹핑을 이용하여 작성할 수 있다.(ABC)+그룹을 만들어 주는 메타문자는 바로 (과 )이다.&gt;&gt;&gt; p = re.compile('(ABC)+')&gt;&gt;&gt; m = p.search('ABCABCABC OK?')&gt;&gt;&gt; print(m)&lt;_sre.SRE_Match object at 0x01F7B320&gt;&gt;&gt;&gt; print(m.group())ABCABCABC  다음의 예를 보자!!!&gt;&gt;&gt; p = re.compile(r\"\\w+\\s+\\d+[-]\\d+[-]\\d+\")&gt;&gt;&gt; m = p.search(\"park 010-1234-1234\")  \\w+\\s+\\d+[-]\\d+[-]\\d+은 이름 + \" \" + 전화번호 형태의 문자열을 찾는 정규표현식이다그룹핑된 문자열 재참조하기정규식 내에 그룹이 무척 많아진다고 가정해 보자. 예를 들어 정규식 내에 그룹이 10개 이상만 되어도 매우 혼란스러울 것이다. 거기에 더해 정규식이 수정되면서 그룹이 추가, 삭제되면 그 그룹을 인덱스로 참조했던 프로그램들도 모두 변경해 주어야 하는 위험도 갖게 된다.      약 그룹을 인덱스가 아닌 이름(Named Groups)으로 참조할 수 있다면 어떨까? 그렇다면 이런 문제들에서 해방되지 않을까?          이러한 이유로 정규식은 그룹을 만들 때 그룹명을 지정할 수 있게 했다.          (?P&lt;name&gt;\\w+)\\s+((\\d+)[-]\\d+[-]\\d+)      전방탐색정규식에 막 입문한 사람들이 가장 어려워하는 것이 바로 전방 탐색(Lookahead Assertions) 확장 구문이다&gt;&gt;&gt; p = re.compile(\".+:\")&gt;&gt;&gt; m = p.search(\"http://google.com\")&gt;&gt;&gt; print(m.group())http:      정규식 .+: 과 일치하는 문자열로 “http:”가 리턴되었다. 하지만 “http:” 라는 검색 결과에서 “:”을 제외하고 출력하려면 어떻게 해야 할까? 위 예는 그나마 간단하지만 훨씬 복잡한 정규식이어서 그룹핑은 추가로 할 수 없다는 조건까지 더해진다면 어떻게 해야 할까?        이럴 때 사용할 수 있는 것이 바로 전방 탐색이다. 전방 탐색에는 긍정(Positive)과 부정(Negative)의 2종류가 있고 다음과 같이 표현된다.                  긍정형 전방 탐색((?=...)) - ... 에 해당되는 정규식과 매치되어야 하며 조건이 통과되어도 문자열이 소모되지 않는다.                    부정형 전방 탐색((?!...)) - ...에 해당되는 정규식과 매치되지 않아야 하며 조건이 통과되어도 문자열이 소모되지 않는다.            긍정형 전방 탐색긍정형 전방 탐색을 이용하면 http:의 결과를 http로 바꿀 수 있다&gt;&gt;&gt; p = re.compile(\".+(?=:)\")&gt;&gt;&gt; m = p.search(\"http://google.com\")&gt;&gt;&gt; print(m.group())http  정규식 중 :에 해당하는 부분이 긍정형 전방탐색 기법이 적용되어 (?=:) 으로 변경되었다. 이렇게 되면 기존 정규식과 검색에서는 동일한 효과를 발휘하지만 :에 해당되는 문자열이 정규식 엔진에 의해 소모되지 않아(검색에는 포함되지만 검색 결과에는 제외됨) 검색 결과에서는 :이 제거된 후 리턴되는 효과가 있다.부정형 전방 탐색.*[.](?!bat$).*$  확장자가 bat가 아닌 경우에만 통과된다는 의미이다. bat라는 문자열이 있는지 조사하는 과정에서 문자열이 소모되지 않으므로 bat가 아니라고 판단되면 그 이후 정규식 매칭이 진행된다.문자열 바꾸기sub 메서드를 이용하면 정규식과 매치되는 부분을 다른 문자로 쉽게 바꿀 수 있다.&gt;&gt;&gt; p = re.compile('(blue|white|red)')&gt;&gt;&gt; p.sub('colour', 'blue socks and red shoes')'colour socks and colour shoes'  sub 메서드의 첫 번째 입력 인수는 “바꿀 문자열(replacement)”이 되고, 두 번째 입력 인수는 “대상 문자열”이 된다. 위 예에서 볼 수 있듯이 blue 또는 white 또는 red라는 문자열이 colour라는 문자열로 바뀌는 것을 확인할 수 있다.sub 메서드 사용 시 참조 구문 사용하기sub 메서드를 사용할 때 참조 구문을 사용할 수 있다&gt;&gt;&gt; p = re.compile(r\"(?P&lt;name&gt;\\w+)\\s+(?P&lt;phone&gt;(\\d+)[-]\\d+[-]\\d+)\")&gt;&gt;&gt; print(p.sub(\"\\g&lt;phone&gt; \\g&lt;name&gt;\", \"park 010-1234-1234\"))010-1234-1234 park  위 예는 이름 + 전화번호의 문자열을 전화번호 + 이름으로 바꾸는 예이다. sub의 바꿀 문자열 부분에 \\g&lt;그룹명&gt;을 이용하면 정규식의 그룹명을 참조할 수 있게된다.sub 메서드의 입력 인수로 함수 넣기sub 메서드의 첫 번째 입력 인수로 함수를 넣을 수도 있다.&gt;&gt;&gt; def hexrepl(match):...     \"Return the hex string for a decimal number\"...     value = int(match.group())...     return hex(value)...&gt;&gt;&gt; p = re.compile(r'\\d+')&gt;&gt;&gt; p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')'Call 0xffd2 for printing, 0xc000 for user code.'",
        "url": "/blackruby-code//back/2017/11/29/jump6.html"
      }
      ,
    
      "back-2017-11-29-jump5-html": {
        "title": "Jump to Python - 파이썬 프로그래밍, 어떻게 시작해야할까?",
        "tags": "Python",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "내가 프로그램을 만들 수 있을까?“문법도 어느 정도 알겠고, 책 내용도 대부분 이해된다. 하지만 이러한 지식을 바탕으로 내가 도대체 어떤 프로그램을 만들 수 있을까?”  이럴 때는 “어떤 프로그램을 짜야지”라는 생각보다는 다른 사람들이 만든 프로그램 파일을 자세히 들여다보고 분석하는 데서 시작하는 것이 좋다!!!프로그램을 만들려면 가장 먼저 \"입력\"과 \"출력\"을 생각하라.연습!  함수 이름은? GuGu로 짓자  입력받는 값은? 2  출력하는 값은? 2단(2, 4, 6, 8, …, 18)  결과는 어떤 형태로 저장하지? 연속된 자료형이니까 리스트!  에디터를 열고 다음과 같이 입력한다. GuGu라는 함수에 2를 입력값으로 주면 result라는 변수에 결과값을 넣으라는 뜻이다.result = GuGu(2)      이제 결과값을 어떤 형태로 받을 것인지 고민해 보자. 2단이니까 2, 4, 6, … 18까지 갈 것이다. 이런 종류의 데이터는 리스트 자료형이 딱이다        자, 일단 이름을 GuGu로 지은 함수를 다음과 같이 만들어 보자.  def GuGu(n):    print(n)  위와 같은 함수를 만들고 GuGu(2)처럼 실행하면 2를 출력하게 된다. 즉, 입력값으로 2가 잘 들어오는지 확인하는 것이다.  이제 결과값을 담을 리스트를 하나 생성하자. 앞에서 작성한 print(n)은 입력이 잘 되는지를 확인하기 위한 것이었으므로 지워도 좋다.def GuGu(n):    result = []  다음으로 result에 2, 4, 6,… 18을 어떻게 넣어야 할지 생각해 보자. 필자는 다음과 같이 리스트에 요소를 추가하는 append 내장 함수를 사용하기로 결정했다.def GuGu(n):    result = []    result.append(n*1)    result.append(n*2)    result.append(n*3)    result.append(n*4)    result.append(n*5)    result.append(n*6)    result.append(n*7)    result.append(n*8)    result.append(n*9)    return resultprint(GuGu(2))결과값: [2, 4, 6, 8, 10, 12, 14, 16, 18]정말 무식한 방법이지만 입력값 2를 주었을 때 원하는 결과값을 얻을 수 있다.  그런데 위의 함수는 반복이 너무 많다. 가만히 보면 result.append(n*□)의 □위치에 1부터 9까지 숫자만 다르게 들어가 있다는 것을 알 수 있다. 똑같은 일을 반복할 때는 “반복문”을 사용한다고 했다. 그렇다면 1부터 9까지 출력해 주는 반복문을 만들면 되지 않을까?&gt;&gt;&gt; i = 1&gt;&gt;&gt; while i &lt; 10:...     print(i)...     i = i + 1결과값:123456789  이상의 생각들을 바탕으로 완성한 GuGu 함수는 다음과 같다.def GuGu(n):    result = []    i = 1    while i &lt; 10:        result.append(n * i)        i = i + 1    return resultTESTprint(GuGu(2))결과값: [2, 4, 6, 8, 10, 12, 14, 16, 18]결과는 대만족이다!!!3과 5의 배수 합치기10 미만의 자연수에서 3과 5의 배수를 구하면 3, 5, 6, 9이다. 이들의 총합은 23이다.1000 미만의 자연수에서 3의 배수와 5의 배수의 총합을 구하라.result = 0for n in range(1, 1000):    if n % 3 == 0 or n % 5 == 0:         result += nprint(result)  이 문제에는 한가지 함정이 있는데 3으로도 5로도 나누어지는 15와 같은 수를 이중으로 더해서는 안 된다는 점이다. 따라서 15와 같이 3의 배수도 되고 5의 배수도 되는 값이 이중으로 더해지지 않기 위해 or 연산자를 사용게시판 페이징하기A 씨는 게시판 프로그램을 작성하고 있다. 그런데 게시물의 총 건수와 한 페이지에 보여줄 게시물 수를 입력으로 주었을 때 총 페이지수를 출력하는 프로그램이 필요하다고 한다.  A씨가 필요한 프로그램을 만들기 위해 입력값과 결과값이 어떻게 나와야 하는지 먼저 살펴봐야한다. 게시물의 총 건수가 5이고 한 페이지에서 보여 줄 게시물 수가 10이면 총 페이지수는 당연히 1이 된다. 만약 게시물의 총 건수가 15이고 한 페이지에서 보여 줄 게시물 수가 10이라면 총 페이지수는 2가 될 것이다.  다음과 같이 총 건수(m)를 한 페이지에 보여줄 게시물 수(n)로 나누고 1을 더하면 총 페이지수를 얻을 수 있다.총 페이지수 = 총 건수 / 한 페이지당 보여줄 건수 + 1  이러한 공식을 적용했을 경우 총 페이지수가 표의 값처럼 구해지는지 확인해 보자(m을 n으로 나눌 때 소수점 아래 자리를 버리기 위해서 / 대신 // 연산자를 사용하였다).def getTotalPage(m, n):    return m // n + 1print(getTotalPage(5, 10))    # 1 출력print(getTotalPage(15, 10))   # 2 출력print(getTotalPage(25, 10))   # 3 출력print(getTotalPage(30, 10))   # 4 출력  실패 케이스는 총 게시물 수와 한 페이지에 보여줄 게시물 수를 나눈 나머지 값이 0이 될 때 발생함을 유추할 수 있을 것이다. 이 실패 케이스를 해결하려면 다음과 같이 코드를 변경해야 한다.def getTotalPage(m, n):    if m % n == 0:        return m // n    else:        return m // n + 1print(getTotalPage(5, 10))print(getTotalPage(15, 10))print(getTotalPage(25, 10))print(getTotalPage(30, 10))간단한 메모장 만들기# C:/Python/memo.pyimport sysoption = sys.argv[1]memo = sys.argv[2]print(option)print(memo)  memo.py를 작성했다면 다음과 같은 명령을 수행해 보자.C:\\Python&gt;python memo.py -a \"Life is too short\"-aLife is too short  이제 입력으로 받은 메모를 파일에 쓰도록 코드를 변경해 보자.# c:/Python/memo.pyimport sysoption = sys.argv[1]if option == '-a':    memo = sys.argv[2]    f = open('memo.txt', 'a')    f.write(memo)    f.write('\\n')    f.close()  이제 다음과 같은 명령을 수행해 보자.C:\\Python&gt;python memo.py -a \"Life is too short\"  C:\\Python&gt;python memo.py -a \"You need python\"  그리고 파일에 정상적으로 메모가 기입되었는지 다음과 같이 확인해 보자.C:\\Python&gt;type memo.txtLife is too shortYou need python  이번에는 작성한 메모를 출력하는 부분을 만들 차례이다. 메모 출력은 다음과 같이 동작하도록 만들어 보자.python memo.py -v  이제 메모 출력을 위해서 다음과 같이 코드를 변경해 보자.# c:/Python/memo.pyimport sysoption = sys.argv[1]if option == '-a':    memo = sys.argv[2]    f = open('memo.txt', 'a')    f.write(memo)    f.write('\\n')    f.close()elif option == '-v':    f = open('memo.txt')    memo = f.read()    f.close()    print(memo)  코드를 수정한 후 다음과 같은 명령을 수행해 보자.C:\\Python&gt;python memo.py -vLife is too shortYou need python탭을 4개의 공백으로 바꾸기문서 파일을 읽어서 그 문서 파일 내에 있는 탭(tab)을 공백(space) 4개로 바꾸어주는 스크립트  우선 다음과 같이 tabto4.py 파일을 작성해 보자.# c:/Python/tabto4.pyimport syssrc = sys.argv[1]dst = sys.argv[2]print(src)print(dst)  다음과 같이 수행했을 때 입력값들이 정상적으로 출력되는지 확인해 보자.C:\\Python&gt;python tabto4.py a.txt b.txta.txtb.txt  입력으로 전달한 a.txt와 b.txt가 정상적으로 출력되는 것을 확인할 수 있다.  테스트를 위한 원본 파일(탭을 포함하는 파일)인 a.txt를 다음과 같이 작성한다. 각 단어들은 탭(\\t) 문자로 분리되도록 입력해야 한다.Life    is  too shortYou need    python  이제 탭 문자를 포함한 a.txt 파일을 읽어서 탭을 공백 4개로 변환할 수 있도록 코드를 변경해 보자.# c:/Python/tabto4.pyimport syssrc = sys.argv[1]dst = sys.argv[2]f = open(src)tab_content = f.read()f.close()space_content = tab_content.replace(\"\\t\", \" \"*4)print(space_content)  tabto4.py를 위와 같이 변경한 후 다음과 같은 명령을 수행해 보자.C:\\Python&gt;python tabto4.py a.txt b.txtLife    is    too    shortYou    need    python  이제 변경된 내용을 b.txt 파일에 저장할 수 있도록 다음과 같이 프로그램을 변경해 보자.# c:/Python/tabto4.pyimport syssrc = sys.argv[1]dst = sys.argv[2]f = open(src)tab_content = f.read()f.close()space_content = tab_content.replace(\"\\t\", \" \"*4)f = open(dst, 'w')f.write(space_content)f.close()  프로그램을 실행하기 위해 다음과 같은 명령을 수행한다.C:\\Python&gt;python tabto4.py a.txt b.txt하위 디렉토리 검색하기  우선 다음과 같이 sub_dir_search.py 파일을 작성해 보자.# C:/Python/sub_dir_search.pydef search(dirname):    print (dirname)search(\"c:/\")  이제 이 디렉터리에 있는 파일들을 검색할 수 있도록 소스를 변경해 보자.# C:/Python/sub_dir_search.pyimport osdef search(dirname):    filenames = os.listdir(dirname)    for filename in filenames:        full_filename = os.path.join(dirname, filename)        print (full_filename)search(\"c:/\")  이제 C:/ 디렉터리에 있는 파일들 중 확장자가 .py인 파일들만을 출력하도록 코드를 변경해 보자.# C:/Python/sub_dir_search.pyimport osdef search(dirname):    filenames = os.listdir(dirname)    for filename in filenames:        full_filename = os.path.join(dirname, filename)        ext = os.path.splitext(full_filename)[-1]        if ext == '.py':             print(full_filename)search(\"c:/\")  하지만 우리가 원하는 것은 C:/ 디렉터리 바로 밑에 있는 파일 뿐만 아니라 그 하위 디렉터리(sub directory)를 포함한 모든 파이썬 파일들을 검색하는 것이다. 하위 디렉터리도 검색이 가능하게 하기 위해서는 다음과 같이 코드를 변경해야 한다.# C:/Python/sub_dir_search.pyimport osdef search(dirname):    try:        filenames = os.listdir(dirname)        for filename in filenames:            full_filename = os.path.join(dirname, filename)            if os.path.isdir(full_filename):                search(full_filename)            else:                ext = os.path.splitext(full_filename)[-1]                if ext == '.py':                     print(full_filename)    except PermissionError:        passsearch(\"c:/\")  try … except PermissionError로 함수 전체를 감싼 이유는 os.listdir 수행 시 권한이 없는 디렉터리에 접근하더라도 프로그램이 오류로 종료되지 않고 그냥 수행되도록 하기 위해서이다.",
        "url": "/blackruby-code//back/2017/11/29/jump5.html"
      }
      ,
    
      "back-2017-11-29-jump4-html": {
        "title": "Jump to Python - 파이썬 날개 달기",
        "tags": "Python",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "클래스클래스는 도대체 왜 필요한가?가장 많이 사용하는 프로그래밍 언어 중 하나인 C 언어에는 클래스가 없다. 이 말은 굳이 클래스 없이도 프로그램을 충분히 만들 수 있다는 말과도 같다. 파이썬으로 잘 만들어진 프로그램들을 살펴보아도 클래스를 이용하지 않고 작성된 것들이 상당히 많다. 클래스는 지금까지 공부한 함수나 자료형처럼 프로그램 작성을 위해 꼭 필요한 요소는 아니다.      계산기를 사용해 봤을 것이다. 계산기에 3이라는 숫자를 입력하고 + 기호를 입력한 후 4를 입력하면 결과값으로 7을 보여준다. 다시 한 번 + 기호를 입력한 후 3을 입력하면 기존 결과값 7에 3을 더해 10을 보여준다. 즉, 계산기는 이전에 계산된 결과값을 항상 메모리 어딘가에 저장하고 있어야 한다.          다음은 계산기의 “더하기” 기능을 구현한 파이선 코드이다          result = 0  def adder(num):      global result      result += num      return result\t  print(adder(3))  print(adder(4))              이전에 계산된 결과값을 유지하기 위해서 \tresult라는 전역 변수(global)를 사용했다. 실행하면 예상한 대로 다음과 같은 결과값이 출력된다.          3  7      그런데 만약 한 프로그램에서 2개의 계산기가 필요한 상황이 발생하면 어떻게 해야 할까? 각각의 계산기는 각각의 결과값을 유지해야 하기 때문에 위와 같이 adder 함수 하나만으로는결과값을 따로 유지할 수 없다.result1 = 0result2 = 0def adder1(num):    global result1    result1 += num    return result1def adder2(num):    global result2    result2 += num    return result2print(adder1(3))print(adder1(4))print(adder2(3))print(adder2(7))      똑같은 일을 하는 adder1과 adder2라는 함수가 만들어졌고 각각의 함수에서 계산된 결과값을 유지하면서 저장하기 위한 전역 변수 result1, result2가 필요하게 되었다.          결과값은 다음과 같이 의도한 대로 출력된다.          3  7  3  10      클래스와 객체과자를 만드는 과자틀과 만들어진 과자들이다.  과자틀 -&gt; 클래스(class)  과자틀에 의해서 만들어진 과자들 -&gt; 객체(object)클래스는 과자틀과 비슷하다클래스(class)란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고(과자 틀), 객체(object)란 클래스에 의해서 만들어진 피조물(과자틀에 의해서 만들어진 과자)을 뜻한다.  클래스에 의해서 만들어진 객체에는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 과자틀에 의해서 만들어진 과자에 구멍을 뚫거나 조금 베어먹더라도 다른 과자들에는 아무 영향이 없는것과 마찬가지로 동일한 클래스에의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다.&gt;&gt;&gt; class Cookie:&gt;&gt;&gt;  \tpass  위의 클래스는 아무런 기능도 갖고 있지 않은 껍질뿐인 클래스이다. 하지만 이렇게 껍질뿐인 클래스도 객체를 생성하는 기능은 가지고 있다. “과자 틀”로 “과자”를 만드는 것처럼 말이다.사칙연산 클래스 만들기클래스를 어떻게 만들지 먼저 구상하기  사칙연산을 가능하게 하는 FourCal이라는 클래스가 다음처럼 동작한다고 가정해 보자.클래스는 무작정 만들기 보다는 클래스에 의해서 만들어진 객체를 중심으로 어떤 식으로 동작하게 할 것인지 미리 구상을 한 후에 생각했던 것들을 하나씩 해결하면서 완성해 나가는 것이 좋다.클래스 구조 만들기&gt;&gt;&gt; class FourCal:...     pass... &gt;&gt;&gt;  현재 상태에서 FourCal 클래스는 아무런 변수나 메서드도 포함하지 않지만 우리가 원하는 객체 a를 만들 수 있는 기능은 가지고 있다&gt;&gt;&gt; a = FourCal()&gt;&gt;&gt; type(a)&lt;class '__main__.FourCal'&gt;  위와 같이 a = FourCal()로 a라는 객체를 먼저 만들고 그 다음에 type(a)로 a라는 객체가 어떤 타입인지 알아보았다. 역시 객체 a가 FourCal 클래스의 인스턴스임을 알 수 있다.객체에 숫자 지정할 수 있게 만들기하지만 생성된 객체 a는 아직 아무런 기능도 하지 못한다. 이제 더하기, 나누기, 곱하기, 빼기등의 기능을 하는 객체를 만들어야 한다&gt;&gt;&gt; a.setdata(4, 2)  연산을 수행할 대상(4, 2)을 객체에 지정할 수 있게 만들어 보자.&gt;&gt;&gt; class FourCal:...     def setdata(self, first, second):...         self.first = first...         self.second = second...&gt;&gt;&gt;  이전에 만들었던 FourCal 클래스에서 pass라는 문장을 삭제하고 class 내부에 setdata라는 함수를 만들었다. 클래스 안에 구현된 함수는 다른말로 메서드(Method)라고 부른다setdata 메서드를 다시 보면 아래와 같다.def setdata(self, first, second):   # ① 메서드의 입력 인수    self.first = first              # ② 메서드의 수행문    self.second = second            # ② 메서드의 수행문① setdata 메서드의 입력 인수  setdata 메서드는 입력 인수로 self, first, second라는 3개의 입력값을 받는다. 그런데 일반적인 함수와는 달리 메서드의 첫 번째 입력 인수 self는 특별한 의미를 가지고 있다.&gt;&gt;&gt; a = FourCal()&gt;&gt;&gt; a.setdata(4, 2)  위에서 보는 것처럼 a라는 객체를 만든 다음에 a.setdata(4, 2)처럼 호출하면 FourCal 클래스의 setdata 메서드가 호출되고 setdata 메서드의 첫 번째 인수 self에는 자동으로 a라는 객체가 대입된다.② setdata 메서드의 수행문setdata 메서드는 수행할 문장이 2개 있다!self.first = firstself.second = second  위 수행문이 뜻하는 바는 무엇일까? 입력 인수로 받은 first는 4이고 second는 2라는 것은 앞에서 이미 알았다. 그렇다면 위의 문장은 다음과 같이 바뀔 것이다.self.first = 4self.second = 2여기서 중요한 것은 바로 self이다. self는 a.setdata(4, 2)처럼 호출했을 때 자동으로 들어오는 객체 a라고 했다. 그렇다면 self.first의 의미는 무엇이겠는가? 당연히 a.first가 될 것이다. 또한 self.second는 당연히 a.second가 될 것이다.따라서 위의 두 문장을 풀어서 쓰면 다음과 같이 된다.a.first = 4a.second = 2위와 같이 바뀐 문장이 실행되어 결국 a객체에는 first와 second라는 객체변수가 생성된다.  객체변수는 다음과 같이 만들어진다.객체.객체변수 = 값객체변수는 객체에 정의된 변수를 의미하며 객체간 서로 공유되지 않는 특징을 갖는다!더하기 기능 만들기2개의 숫자값을 설정해 주었으니 2개의 숫자를 더하는 기능을 추가해 보자!  더하기 기능을 갖춘 클래스를 만들어야 한다!&gt;&gt;&gt; class FourCal:...     def setdata(self, first, second):...         self.first = first...         self.second = second...     def sum(self):...         result = self.first + self.second...         return result...&gt;&gt;&gt;  새롭게 추가된 것은 sum이라는 메서드이다def sum(self):    result = self.first + self.second    return result      sum 메서드의 입력 인수는 self이고 리턴값은 result이다.          리턴 값인 result를 계산하는 부분은 다음과 같다.          result = self.first + self.second              a.sum() 과 같이 a 객체에 의해 sum 메서드가 수행되면 sum 메서드의 self에는 객체 a가 자동으로 입력되므로 위의 내용은 아래와 같이 해석된다.          result = a.first + a.second      곱하기, 빼기, 나누기 기능 만들기&gt;&gt;&gt; class FourCal:...     def setdata(self, first, second):...         self.first = first...         self.second = second...     def sum(self):...         result = self.first + self.second...         return result...     def mul(self):...         result = self.first * self.second...         return result...     def sub(self):...         result = self.first - self.second...         return result...     def div(self):...         result = self.first / self.second...         return result...&gt;&gt;&gt;  mul, sub, div 모두 sum 메서드에서 배운 것과 동일한 방법이다!&gt;&gt;&gt; a = FourCal()&gt;&gt;&gt; b = FourCal()&gt;&gt;&gt; a.setdata(4, 2)&gt;&gt;&gt; b.setdata(3, 7)&gt;&gt;&gt; a.sum()6&gt;&gt;&gt; a.mul()8&gt;&gt;&gt; a.sub()2&gt;&gt;&gt; a.div()2&gt;&gt;&gt; b.sum()10&gt;&gt;&gt; b.mul()21&gt;&gt;&gt; b.sub()-4&gt;&gt;&gt; b.div()0생성자 (Constructor)&gt;&gt;&gt; a = FourCal()&gt;&gt;&gt; a.sum()Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;  File \"&lt;stdin&gt;\", line 6, in sumAttributeError: 'FourCal' object has no attribute 'first'      FourCal 클래스의 인스턴스 a에 setdata메서드를 수행하지 않고 sum 메서드를 수행하면 “AttributeError: ‘FourCal’ object has no attribute ‘first’” 라는 오류가 발생하게 된다. setdata 메서드를 수행해야 객체 a의 객체변수 first와 second에 값이 할당되기 때문이다          이렇게 객체에 초기값을 설정해야 할 필요가 있을때는 setdata와 같은 메서드를 호출하여 초기값을 설정하기 보다는 생성자를 구현하는 것이 안전한 방법이다.      생성자(Constructor)란 객체가 생성될 때 자동으로 호출되는 메서드를 의미한다.파이썬 메서드명으로 __init__ 을 사용하면 이 메서드는 생성자가 된다.  FourCal클래스에 생성자를 추가해 보자.&gt;&gt;&gt; class FourCal:...     def __init__(self, first, second):...         self.first = first...         self.second = second...     def setdata(self, first, second):...         self.first = first...         self.second = second...     def sum(self):...         result = self.first + self.second...         return result...     def mul(self):...         result = self.first * self.second...         return result...     def sub(self):...         result = self.first - self.second...         return result...     def div(self):...         result = self.first / self.second...         return result...&gt;&gt;&gt;  __init__ 메서드는 setdata메서드와 이름만 틀리고 모든게 동일하다. 단, 메서드 이름을 __init__으로 했기 때문에 생성자로 인식되어 객체가 생성되는 시점에 자동으로 호출되는 차이가 있다.클래스의 상속상속(Inheritance)이란 “물려받다”라는 뜻으로, “재산을 상속받다”라고 할 때의 상속과 같은 의미이다. 클래스에도 이런 개념을 적용할 수가 있다. 어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만드는 것이다.클래스를 상속하기 위해서는 다음처럼 클래스명 뒤 괄호 안에 상속할 클래스명을 넣어 주면 된다class 클래스명(상속할 클래스명)메서드 오버라이딩부모 클래스(상속한 클래스)에 있는 메서드를 동일한 이름으로 다시 만드는 것을 메서드 오버라이딩(Overriding, 덮어쓰기)이라고 한다.  메서드를 오버라이딩하면 부모 클래스의 메서드 대신 오버라이딩한 메서드가 호출된다.모듈모듈이란 함수나 변수 또는 클래스 들을 모아 놓은 파일이다. 모듈은 다른 파이썬 프로그램에서 불러와 사용할수 있게끔 만들어진 파이썬 파일이라고도 할 수 있다.모듈 만들고 불러 보기# mod1.pydef sum(a, b):    return a + b  위와 같이 sum 함수만 있는 파일 mod1.py를 만들고 C:\\Python 디렉터리에 저장하면, 그 파일이 바로 모듈이다.import의 사용 방법은 다음과 같다.import 모듈이름클래스나 변수 등을 포함한 모듈지금까지 살펴본 모듈은 함수만 포함했지만 클래스나 변수 등을 포함할 수도 있다# mod2.py PI = 3.141592class Math:     def solv(self, r):         return PI * (r ** 2) def sum(a, b):     return a+b if __name__ == \"__main__\":     print(PI)    a = Math()     print(a.solv(2))     print(sum(PI , 4.4))      이 파일은 원의 넓이를 계산하는 Math 클래스와 두 값을 더하는 sum 함수 그리고 원주율 값에 해당되는 PI 변수처럼 클래스, 함수, 변수 등을 모두 포함하고 있다          대화형 인터프리터를 열고 다음과 같이 따라해보면,          C:\\Python&gt;python  &gt;&gt;&gt; import mod2  &gt;&gt;&gt;               __name__ == \"__main__\"이 거짓이 되므로 아무런 값도 출력되지 않는다.      예외 처리때때로 오류를 무시하고 싶을 때도 있고 별도로 처리하고 싶을 때도 있다. 이에 파이썬은 try, except를 이용해서 오류를 처리할 수 있게 해준다.오류는 어떤 때 발생하는가?  디렉터리 안에 없는 파일을 열려고 시도했을 때 발생하는 오류이다.&gt;&gt;&gt; f = open(\"나없는파일\", 'r')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;FileNotFoundError: [Errno 2] No such file or directory: '나없는파일'  위의 예에서 볼 수 있듯이 없는 파일을 열려고 시도하면 “FileNotFoundError”라는 이름의 오류가 발생하게 된다.&gt;&gt;&gt; 4 / 0Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ZeroDivisionError: division by zero  4를 0으로 나누려니까 “ZeroDivisionError”라는 이름의 오류가 발생한다.오류 예외 처리 기법try, except문  다음은 오류 처리를 위한 try, except문의 기본 구조이다.try:    ...except [발생 오류[as 오류 메시지 변수]]:    ...  try 블록 수행 중 오류가 발생하면 except 블록이 수행된다. 하지만 try블록에서 오류가 발생하지 않는다면 except 블록은 수행되지 않는다.try .. elsetry문은 else절을 지원한다. else절은 예외가 발생하지 않은 경우에 실행되며 반드시 except절 바로 다음에 위치해야 한다.try .. finallytry문에는 finally절을 사용할 수 있다. finally절은 try문 수행 도중 예외 발생 여부에 상관없이 항상 수행된다. 보통 finally절은 사용한 리소스를 close해야 할 경우에 많이 사용된다.여러개의 오류처리하기try문 내에서 여러개의 오류를 처리하기 위해서는 다음과 같은 구문을 이용한다.try:    ...except 발생 오류1:   ... except 발생 오류2:   ...오류 회피하기프로그래밍을 하다 보면 특정 오류가 발생할 경우 그냥 통과시켜야 할 때가 있을 수 있다!try:    f = open(\"나없는파일\", 'r')except FileNotFoundError:    pass  try문 내에서 FileNotFoundError가 발생할 경우 pass를 사용하여 오류를 그냥 회피하도록 한 것이다!오류 일부러 발생시키기이상하게 들리겠지만 프로그래밍을 하다 보면 종종 오류를 일부러 발생시켜야 할 경우도 생긴다. 파이썬은 raise라는 명령어를 이용해 오류를 강제로 발생시킬 수 있다.  예를 들어 Bird라는 클래스를 상속받는 자식 클래스는 반드시 fly라는 함수를 구현하도록 만들고 싶은 경우(강제로 그렇게 하고 싶은 경우)가 있을 수 있다.class Bird:    def fly(self):        raise NotImplementedError  위 예제는 Bird 클래스를 상속받는 자식 클래스는 반드시 fly라는 함수를 구현해야 한다는 의지를 보여준다.오류 만들기프로그램 수행 도중 특수한 경우에만 예외처리를 하기 위해서 종종 오류를 만들어서 사용하게 된다.내장 함수무엇인가 새로운 프로그램을 만들기 전에는 이미 만들어진 것들, 그중에서도 특히 파이썬 배포본에 함께 들어 있는 파이썬 라이브러리들을 살펴보는 것이 매우 중요하다.abs  abs(x)는 어떤 숫자를 입력으로 받았을 때, 그 숫자의 절대값을 돌려주는 함수이다.&gt;&gt;&gt; abs(3)3&gt;&gt;&gt; abs(-3)3&gt;&gt;&gt; abs(-1.2)1.2allall(x)은 반복 가능한(iterable) 자료형 x를 입력 인수로 받으며, 이 x가 모두 참이면 True, 거짓이 하나라도 있 으면 False를 리턴한다.&gt;&gt;&gt; all([1, 2, 3])Trueanyany(x)는 x 중 하나라도 참이 있을 경우 True를 리턴하고, x가 모두 거짓일 경우에만 False를 리턴한다. all(x)의 반대 경우라고 할 수 있다.chrchr(i)는 아스키(ASCII) 코드값을 입력으로 받아 그 코드에 해당하는 문자를 출력하는 함수이다.dirdir은 객체가 자체적으로 가지고 있는 변수나 함수를 보여 준다.divmoddivmod(a, b)는 2개의 숫자를 입력으로 받는다. 그리고 a를 b로 나눈 몫과 나머지를 튜플 형태로 리턴하는 함수이다.enumerateenumerate는 “열거하다”라는 뜻이다. 이 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 리턴한다.for문처럼 반복되는 구간에서 객체가 현재 어느 위치에 있는지 알려주는 인덱스 값이 필요할때 enumerate 함수를 사용하면 매우 유용하다.evaleval(expression)은 실행 가능한 문자열(1+2, ‘hi’ + ‘a’ 같은 것)을 입력으로 받아 문자열을 실행한 결과값을 리턴하는 함수이다.보통 eval은 입력받은 문자열로 파이썬 함수나 클래스를 동적으로 실행하고 싶은 경우에 사용된다.filterfilter란 무엇인가를 걸러낸다는 뜻으로, filter 함수도 동일한 의미를 가진다. filter 함수는 첫 번째 인수로 함수 이름을, 두 번째 인수로 그 함수에 차례로 들어갈 반복 가능한 자료형을 받는다. 그리고 두 번째 인수인 반복 가능한 자료형 요소들이 첫 번째 인수인 함수에 입력되었을 때 리턴값이 참인 것만 묶어서(걸러내서) 돌려준다.hexhex(x)는 정수값을 입력받아 16진수(hexadecimal)로 변환하여 리턴하는 함수이다.idid(object)는 객체를 입력받아 객체의 고유 주소값(레퍼런스)을 리턴하는 함수이다.inputinput([prompt])은 사용자 입력을 받는 함수이다. 입력 인수로 문자열을 주면 그 문자열은 프롬프트가 된다.&gt;&gt;&gt; a = input()hi&gt;&gt;&gt; a'hi'&gt;&gt;&gt; b = input(\"Enter: \")Enter: hiintint(x)는 문자열 형태의 숫자나 소수점이 있는 숫자 등을 정수 형태로 리턴하는 함수로, 정수를 입력으로 받으면 그대로 리턴한다.&gt;&gt;&gt; int('3')3&gt;&gt;&gt; int(3.4)3isinstanceisinstance(object, class)는 첫 번째 인수로 인스턴스, 두 번째 인수로 클래스 이름을 받는다. 입력으로 받은 인스턴스가 그 클래스의 인스턴스인지를 판단하여 참이면 True, 거짓이면 False를 리턴한다.&gt;&gt;&gt; class Person: pass...&gt;&gt;&gt; a = Person()&gt;&gt;&gt; isinstance(a, Person)Truelambdalambda는 함수를 생성할 때 사용하는 예약어로, def와 동일한 역할을 한다. 보통 함수를 한줄로 간결하게 만들 때 사용한다. 우리말로는 “람다”라고 읽고 def를 사용해야 할 정도로 복잡하지 않거나 def를 사용할 수 없는 곳에 주로 쓰인다.lambda 인수1, 인수2, ... : 인수를 이용한 표현식&gt;&gt;&gt; sum = lambda a, b: a+b&gt;&gt;&gt; sum(3,4)7  lambda를 이용한 sum 함수는 인수로 a, b를 받아 서로 더한 값을 돌려준다.lenlen(s)은 입력값 s의 길이(요소의 전체 개수)를 리턴하는 함수이다.&gt;&gt;&gt; len(\"python\")6&gt;&gt;&gt; len([1,2,3])3&gt;&gt;&gt; len((1, 'a'))2listlist(s)는 반복 가능한 자료형 s를 입력받아 리스트로 만들어 리턴하는 함수이다.&gt;&gt;&gt; list(\"python\")['p', 'y', 't', 'h', 'o', 'n']&gt;&gt;&gt; list((1,2,3))[1, 2, 3]mapmap(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다. map은 입력받은 자료형의 각 요소가 함수 f에 의해 수행된 결과를 묶어서 리턴하는 함수이다.maxmax(iterable)는 인수로 반복 가능한 자료형을 입력받아 그 최대값을 리턴하는 함수이다.&gt;&gt;&gt; max([1, 2, 3])3&gt;&gt;&gt; max(\"python\")'y'minmin(iterable)은 max 함수와 반대로, 인수로 반복 가능한 자료형을 입력받아 그 최소값을 리턴하는 함수이다.&gt;&gt;&gt; min([1, 2, 3])1&gt;&gt;&gt; min(\"python\")'h'octoct(x)는 정수 형태의 숫자를 8진수 문자열로 바꾸어 리턴하는 함수이다.&gt;&gt;&gt; oct(34)'0o42'&gt;&gt;&gt; oct(12345)'0o30071'openopen(filename, [mode])은 “파일 이름”과 “읽기 방법”을 입력받아 파일 객체를 리턴하는 함수이다. 읽기 방법(mode)이 생략되면 기본값인 읽기 전용 모드(r)로 파일 객체를 만들어 리턴한다.            mode      설명                  w      쓰기 모드로 파일 열기              r      읽기 모드로 파일 열기              a      추가 모드로 파일 열기              b      바이너리 모드로 파일 열기      ordord(c)는 문자의 아스키 코드값을 리턴하는 함수이다.&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; ord('0')48powpow(x, y)는 x의 y 제곱한 결과값을 리턴하는 함수이다.&gt;&gt;&gt; pow(2, 4)16&gt;&gt;&gt; pow(3, 3)27rangerange([start,] stop [,step])는 for문과 함께 자주 사용되는 함수이다. 이 함수는 입력받은 숫자에 해당되는 범위의 값을 반복 가능한 객체로 만들어 리턴한다.인수가 하나일 경우시작 숫자를 지정해 주지 않으면 range 함수는 0부터 시작한다.&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]인수가 2개일 경우입력으로 주어지는 2개의 인수는 시작 숫자와 끝 숫자를 나타낸다. 단, 끝 숫자는 해당 범위에 포함되지 않는다는 것에 주의해야 한다!!!!&gt;&gt;&gt; list(range(5, 10))[5, 6, 7, 8, 9]인수가 3개일 경우세 번째 인수는 숫자 사이의 거리를 말한다.&gt;&gt;&gt; list(range(1, 10, 2))[1, 3, 5, 7, 9]&gt;&gt;&gt; list(range(0, -10, -1))[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]sortedsorted(iterable) 함수는 입력값을 정렬한 후 그 결과를 리스트로 리턴하는 함수이다.&gt;&gt;&gt; sorted([3, 1, 2])[1, 2, 3]&gt;&gt;&gt; sorted(['a', 'c', 'b'])['a', 'b', 'c']&gt;&gt;&gt; sorted(\"zero\")['e', 'o', 'r', 'z']&gt;&gt;&gt; sorted((3, 2, 1))[1, 2, 3]  리스트 자료형에도 sort라는 함수가 있다. 하지만 리스트 자료형의 sort 함수는 리스트 객체 그 자체를 정렬만 할 뿐 정렬된 결과를 리턴하지는 않는다.strstr(object)은 문자열 형태로 객체를 변환하여 리턴하는 함수이다.&gt;&gt;&gt; str(3)'3'&gt;&gt;&gt; str('hi')'hi'&gt;&gt;&gt; str('hi'.upper())'HI'tupletuple(iterable)은 반복 가능한 자료형을 입력받아 튜플 형태로 바꾸어 리턴하는 함수이다. 만약 튜플이 입력으로 들어오면 그대로 리턴한다.&gt;&gt;&gt; tuple(\"abc\")('a', 'b', 'c')&gt;&gt;&gt; tuple([1, 2, 3])(1, 2, 3)&gt;&gt;&gt; tuple((1, 2, 3))(1, 2, 3)typetype(object)은 입력값의 자료형이 무엇인지 알려주는 함수이다.&gt;&gt;&gt; type(\"abc\")&lt;class 'str'&gt;&gt;&gt;&gt; type([ ])&lt;class 'list'&gt;&gt;&gt;&gt; type(open(\"test\", 'w'))&lt;class '_io.TextIOWrapper'&gt;zipzip(iterable*)은 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수이다.&gt;&gt;&gt; list(zip([1, 2, 3], [4, 5, 6]))[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip([1, 2, 3], [4, 5, 6], [7, 8, 9]))[(1, 4, 7), (2, 5, 8), (3, 6, 9)]&gt;&gt;&gt; list(zip(\"abc\", \"def\"))[('a', 'd'), ('b', 'e'), ('c', 'f')]외장 함수syssys 모듈은 파이썬 인터프리터가 제공하는 변수들과 함수들을 직접 제어할 수 있게 해주는 모듈이다.명령 행에서 인수 전달하기 - sys.argvC:/User/home&gt;python test.py abc pey guido  도스 창에서 위의 예처럼 test.py 뒤에 또 다른 값들을 함께 넣어 주면 sys.argv라는 리스트에그 값들이 추가된다.강제로 스크립트 종료하기 - sys.exit&gt;&gt;&gt; sys.exit()자신이 만든 모듈 불러와 사용하기 - sys.pathpicklepickle은 객체의 형태를 그대로 유지하면서 파일에 저장하고 불러올 수 있게 하는 모듈이다OS 모듈OS 모듈은 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈이다.내 시스템의 환경 변수값을 알고 싶을 때 - os.environ시스템은 제각기 다른 환경 변수값을 가지고 있는데, os.environ은 현재 시스템의 환경 변수 값들을 보여 준다디렉터리 위치 변경하기 - os.chdir디렉터리 위치 리턴받기 - os.getcwd시스템 명령어 호출하기 - os.system실행한 시스템 명령어의 결과값 리턴받기 - os.popen  os.popen은 시스템 명령어를 실행시킨 결과값을 읽기 모드 형태의 파일 객체로 리턴한다.&gt;&gt;&gt; f = os.popen(\"dir\")파일 복사하기 - shutil.copy(src, dst)glob가끔 파일을 읽고 쓰는 기능이 있는 프로그램을 만들다 보면 특정 디렉터리에 있는 파일 이름 모두를 알아야 할 때가 있다. 이럴 때 사용하는 모듈이 바로 glob이다.디렉터리에 있는 파일들을 리스트로 만들기 - glob(pathname)glob 모듈은 디렉터리 내의 파일들을 읽어서 리턴한다. *, ? 등의 메타 문자를 써서 원하는 파일만 읽어 들일 수도 있다.tempfile파일을 임시로 만들어서 사용할 때 유용한 모듈이 바로 tempfile이다. tempfile.mktemp()는 중복되지 않는 임시 파일의 이름을 무작위로 만들어서 리턴한다.timetime.timetime.time()은 UTC(Universal Time Coordinated 협정 세계 표준시)를 이용하여 현재 시간을 실수 형태로 리턴하는 함수이다. 1970년 1월 1일 0시 0분 0초를 기준으로 지난 시간을 초 단위로 리턴한다.time.localtimetime.localtime은 time.time()에 의해서 반환된 실수값을 이용해서 연도, 월, 일, 시, 분, 초,.. 의 형태로 바꾸어 주는 함수이다.time.asctimetime.localtime에 의해서 반환된 튜플 형태의 값을 인수로 받아서 날짜와 시간을 알아보기 쉬운 형태로 리턴하는 함수이다.time.ctimetime.asctime(time.localtime(time.time()))은 time.ctime()을 이용해 간편하게 표시할 수 있다time.strftimestrftime 함수는 시간에 관계된 것을 세밀하게 표현할 수 있는 여러 가지 포맷 코드를 제공한다.time.sleeptime.sleep 함수는 주로 루프 안에서 많이 사용된다. 이 함수를 사용하면 일정한 시간 간격을 두고 루프를 실행할 수 있다.calendarcalendar는 파이썬에서 달력을 볼 수 있게 해주는 모듈이다.randomrandom은 난수(규칙이 없는 임의의 수)를 발생시키는 모듈이다webbrowserwebbrowser는 자신의 시스템에서 사용하는 기본 웹 브라우저가 자동으로 실행되게 하는 모듈이다.",
        "url": "/blackruby-code//back/2017/11/29/jump4.html"
      }
      ,
    
      "back-2017-11-29-jump3-html": {
        "title": "Jump to Python - 프로그램의 입력과 출력",
        "tags": "Python",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "함수함수를 사용하는 이유는 무엇일까?프로그래밍을 하다 보면 똑같은 내용을 반복해서 작성하고 있는 자신을 발견할 때가 종종 있다. 이때가 바로 함수가 필요한 때이다. 즉, 반복되는 부분이 있을 경우 “반복적으로 사용되는 가치 있는 부분”을 한 뭉치로 묶어서 “어떤 입력값을 주었을 때 어떤 결과값을 돌려준다”라는식의 함수로 작성해야 한다.파이썬 함수의 구조파이썬 함수의 구조는 다음과 같다.def 함수명(입력 인수):\t&lt;수행할 문장1&gt;\t&lt;수행할 문장2&gt;\t...  def는 함수를 만들 때 사용하는 예약어이며, 함수명은 함수를 만드는 사람이 임의로 만들 수 있다.&gt;&gt;&gt; def sum(a, b):... \treturn a+b...&gt;&gt;&gt;      위의 함수는 이렇게 해석할 수 있다.          이 함수의 이름(함수명)은 sum이고 입력 인수로 2개의 값을 받으며 결과값은 2개의 입력값을 더한 값이다      입력값과 결과값에 따른 함수의 형태함수는 들어온 입력값을 받아 어떤 처리를 하여 적절한 결과값을 돌려준다.입력값–&gt;함수–&gt;리턴값일반적인 함수입력값이 있고 결과값이 있는 함수가 일반적인 함수이다.def 함수이름(입력인수):\t&lt;수행할 문장&gt;\t...\treturn 결과값입력값이 없는 함수입력값이 없는 함수가 존재할까? 당연히 존재한다.&gt;&gt;&gt; def say():... \treturn 'Hi'...&gt;&gt;&gt;  say라는 이름의 함수를 만들었다. 그런데 입력 인수 부분을 나타내는 함수명 뒤의 괄호 안이 비어있다. 이 함수는 어떻게 사용하는걸까?&gt;&gt;&gt; a = say()&gt;&gt;&gt; print(a)Hi  위의 함수를 쓰기 ㄹ위해서는 say()처럼 괄호 안에 아무런 값도 넣지 않아야 한다.결과값이 없는 함수결과값이 없는 함수 역시 존재한다&gt;&gt;&gt; def sum(a, b):... \tprint(\"%d, %d의 합은 %d입니다.\" % (a, b, a+b))...&gt;&gt;&gt;  결과값이 없는 함수는 호출해도 돌려주는 값이 없기 때문에 다음과 같이 사용한다.&gt;&gt;&gt; sum(3, 4)3, 4의 합은 7입니다.  위의 예제에서 결과값은 당연히 없다. 결과값은 오직 return 명령어로만 돌려받을 수 있다.&gt;&gt;&gt; a = sum(3, 4)&gt;&gt;&gt; print(a)None  a의 값은 None이다. None이란 거짓을 나타내는 자료형이라고 언급한 적이 있다. sum 함수처럼 결과값이 없을 때 a = sum(3, 4)처럼 쓰게 되면 함수 sum은 리턴값으로 a 변수에 None을 돌려준다. 이것을 가지고 결과값이 있다고 생각하면 안된다.입력값도 결과값도 없는 함수&gt;&gt;&gt; def say():... \tprint('Hi')...&gt;&gt;&gt;  입력 인수를 받는 곳도 없고 return문도 없으니 입력값도 결과값도 없는 함수이다.이 함수를 사용하는 방법은 단 한가지이다.&gt;&gt;&gt; say()Hi즉, 입력값도 결과값도 없는 함수는 다음과 같이 사용한다.함수명()입력값이 몇 개가 될지 모를 때는 어떻게 해야 할까?입력값이 여러 개일 때 그 입력값들을 모두 더해 주는 함수를 생각해보자. 하지만 몇개가 입력될지 모를 때는 어떻게해야할까? 파이썬은 이런 문제를 해결하기 위해 다음과 같은 방법을 제공한다.def 함수이름(*입력변수):\t&lt;수행할 문장&gt;\t...여러 개의 입력값을 받는 함수 만들기  sum_many(1, 2)이면 3을, sum_many(1,2,3)이면 6을, sum_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)이면 55를 돌려주는 함수를 만들어 보자&gt;&gt;&gt; def sum_many(*args): ...     sum = 0 ...     for i in args: ...         sum = sum + i ...     return sum ... &gt;&gt;&gt;      위에서 만든 sum_many라는 함수는 입력값이 몇 개든 상관이 없다. *args처럼 입력 변수명 앞에 *을 붙이면 입력값들을 전부 모아서 튜플로 만들어 주기 때문이다.        만약 sum_many(1, 2, 3)처럼 이 함수를 쓰면 args는 (1, 2, 3)이 되고, sum_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)처럼 쓰면 args는 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)이 된다. 여기서 *args라는 것은 임의로정한 변수명이다. *pey, *python처럼 아무 이름이나 써도 된다.  실제로 이 함수를 직접 입력해보자&gt;&gt;&gt; result = sum_many(1,2,3)&gt;&gt;&gt; print(result)6&gt;&gt;&gt; result = sum_many(1,2,3,4,5,6,7,8,9,10)&gt;&gt;&gt; print(result)55  sum_many(1,2,3)으로 함수를 호출하면 6을 리턴하고, sum_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)을 대입하면 55를 리턴한다.함수의 결과값은 언제나 하나이다&gt;&gt;&gt; def sum_and_mul(a, b):... \treturn a+b, a*b  sum_and_mul 함수는 2개의 입력 인수를 받아 더한 값과 곱한 값을 돌려주는 함수이다.이 함수를 다음과 같이 호출하면 어떻게 될까?&gt;&gt;&gt; result = sum_and_mul(3,4)  결과값은 a+b와 a*b 2개인데 결과값을 받아들이는 변수는 result 하나만 쓰였으니 오류가 발생하지 않을까? 당연한 의문이다. 하지만 오류는 발생하지 않는다. 그 이유는 함수의 결과값은 2개가 아니라 언제나 1개라는 데 있다.따라서 result 변수는 다음과 같은 값을 갖게 된다result = (7, 12)  즉, 결과값으로 (7, 12)라는 튜플 값을 갖게 되는 것이다.만약 이 하나의 튜플값을 2개의 결과값처럼 받고 싶다면 다음과 같이 함수를 호출하면 된다!&gt;&gt;&gt; sum, mul = sum_and_mul(3, 4)  이렇게 호출하면 sum, mul=(7,12)가 되어 sum은 7이 되고 mul은 12가 된다.입력 인수에 초깃값 미리 설정하기다음은 인수에 초깃값을 미리 설정해 주는 경우이다!def say_myself(name, old, man=True):     print(\"나의 이름은 %s 입니다.\" % name)     print(\"나이는 %d살입니다.\" % old)     if man:         print(\"남자입니다.\")    else:         print(\"여자입니다.\")  위의 함수를 보면 입력 인수가 name, old, man=True 이렇게 3개다. 그런데 낯선 것이 나왔다. man=True처럼 입력 인수에 미리 값을 넣어 준 것이다. 이것이 바로 함수의 인수 초깃값을 설정하는 방법이다함수 입력 인수에 초깃값을 설정할 때 주의할 사항만약 위에서 본 say_myself 함수를 다음과 같이 만들면 어떻게 될까?def say_myself(name, man=True, old):     print(\"나의 이름은 %s 입니다.\" % name)     print(\"나이는 %d살입니다.\" % old)     if man:         print(\"남자입니다.\")     else:         print(\"여자입니다.\")  이전 함수와 바뀐 부분은 초깃값을 설정한 인수의 위치이다. 결론적으로는 이것은 함수를 실핼할 때 오류가 발생한다.함수 안에서 선언된 변수의 효력 범위함수 안에서 사용할 변수의 이름을 함수 밖에서도 동일하게 사용한다면 어떻게 될까?# vartest.pya = 1def vartest(a):    a = a +1vartest(a)print(a)  당연히 vartest 함수에서 변수 a의 값에 1을 더했으니까 2가 출력되어야 할 것 같지만 프로그램 소스를 작성해서 실행시켜 보면 결과값은 1이 나온다. 그 이유는 함수 안에서 새로 만들어진 변수는 함수 안에서만 사용되는 “함수만의 변수”이기 때문이다. 즉, def vartest(a)에서 입력 인수를 뜻하는 변수 a는 함수 안에서만 사용되는 변수이지 함수 밖의 변수 a가 아니라는 뜻이다.함수 안에서 함수 밖의 변수를 변경하는 방법1. return 이용하기# vartest_return.pya = 1 def vartest(a):     a = a +1     return aa = vartest(a) print(a)  vartest 함수는 입력으로 들어온 값에 1을 더한값을 돌려준다. 따라서 a = vartest(a)라고 대입하면 a가 vartest 함수의 결과값으로 바뀐다.2. global 명령어 사용하기# vartest_global.pya = 1 def vartest():     global a     a = a+1vartest() print(a)  두 번째 방법은 global이라는 명령어를 이용하는 방법이다. 위의 예에서 볼 수 있듯이 vartest 함수 안의 global a라는 문장은 함수 안에서 함수 밖의 a 변수를 직접 사용하겠다는 뜻이다.사용자 입력과 출력우리들이 사용하는 대부분의 완성된 프로그램은 사용자의 입력에 따라 그에 맞는 출력을 내보낸다. 대표적인 예로, 게시판에 글을 작성한 후 “확인”버튼을 눌러야만(입력) 우리가 작성한 글이 게시판에 올라가는(출력)것을 들 수 있다.사용자 입력 » 처리(프로그램, 함수 등) » 출력사용자 입력input의 사용&gt;&gt;&gt; a = input()Life if too short, you need python&gt;&gt;&gt; a'Life is too short, you need python'&gt;&gt;&gt;  input은 입력되는 모든 것을 문자열로 취급한다.프롬프트를 띄워서 사용자 입력 받기사용자에게 입력을 받을 때 “숫자를 입력하세요”라든지 “이름을 입력하세요”라는 안내 문구 또는 질문이 나오도록 하고 싶을 때가 있다. 그럴 때는 input()의 괄호 안에 질문을 입력하여 프롬프트를 띄워주면 된다.input(\"질문 내용\")print 자세히 알기큰따옴표(“)로 둘러싸인 문자열은 + 연산과 동일하다&gt;&gt;&gt; print(\"life\" \"is\" \"too short\") # ①lifeistoo short&gt;&gt;&gt; print(\"life\"+\"is\"+\"too short\") # ②lifeistoo short  위의 예에서 1 과 2 는 완전히 동일한 결과값을 출력한다. 즉, 따옴표로 둘러싸인 문자열을연속해서 쓰면 + 연산을 한 것과 같다.문자열 띄어쓰기는 콤마로 한다&gt;&gt;&gt; print(\"life\", \"is\", \"too short\")life is too short한 줄에 결과값 출력하기&gt;&gt;&gt; for i in range(10):...     print(i, end=' ')...0 1 2 3 4 5 6 7 8 9  한 줄에 결과값을 계속 이어서 출력하려면 입력 인수 end를 이용해 끝 문자를 지정해야 한다.파일 읽고 쓰기파일 생성하기다음 소스 코드를 에디터로 작성해서 저장한 후 실행해 보자. 프로그램을 실행한 디렉터리에 새로운 파일이 하나 생성된 것을 확인할 수 있을 것이다f = open(\"새파일.txt\", 'w')f.close()  파일을 생성하기 위해 우리는 open이라는 파이썬 내장 함수를 사용했다. open 함수는 다음과 같이 “파일 이름”과 “파일 열기 모드”를 입력값으로 받고 결과값으로 파일 객체를 돌려준다.파일 객체 = open(파일 이름, 파일 열기 모드)            파일열기모드      설명                  r      읽기모드 - 파일을 읽기만 할 때 사용              w      쓰기모드 - 파일에 내용을 쓸 때 사용              a      추가모드 - 파일의 마지막에 새로운 내용을 추가 시킬 때 사용        파일을 쓰기 모드로 열게 되면 해당 파일이 이미 존재할 경우 원래 있던 내용이 모두 사라지고, 해당 파일이 존재하지 않으면 새로운 파일이 생성된다파일을 쓰기 모드로 열어 출력값 적기이번에는 에디터를 열고 프로그램의 출력값을 파일에 직접 써 보자.# writedata.pyf = open(\"C:/Python/새파일.txt\", 'w')for i in range(1, 11):    data = \"%d번째 줄입니다.\\n\" % i    f.write(data)f.close()위의 프로그램을 다음 프로그램과 비교해 보자.for i in range(1, 11):    data = \"%d번째 줄입니다.\\n\" % i    print(data)  두 프로그램의 다른 점은 data를 출력하는 방법이다. 두 번째 방법은 우리가 계속 사용해 왔던 모니터 화면에 출력하는 방법이고, 첫 번째 방법은 모니터 화면 대신 파일에 결과값을 적는 방법이다.프로그램의 외부에 저장된 파일을 읽는 여러가지 방법readline()함수 이용하기첫 번째 방법은 readline() 함수를 이용하는 방법이다.# readline.pyf = open(\"C:/Python/새파일.txt\", 'r')line = f.readline()print(line)f.close()  위 예는 f.open(“새파일.txt”, ‘r’)로 파일을 읽기 모드로 연 후 readline()을 이용해서 파일의 첫 번째 줄을 읽어 출력하는 경우이다. 이전에 만들었던 새파일.txt를 수정하거나 지우지 않았다면 위 프로그램을 실행시켰을 때 새파일.txt의 가장 첫 번째 줄이 화면에 출력될 것이다.1번째 줄입니다.readlines() 함수 이용하기f = open(\"C:/Python/새파일.txt\", 'r')lines = f.readlines()for line in lines:    print(line)f.close()read() 함수 이용하기f = open(\"C:/Python/새파일.txt\", 'r')data = f.read()print(data)f.close()  f.read()는 파일의 내용 전체를 문자열로 리턴한다. 따라서 위 예의 data는 파일의 전체 내용이다.파일에 새로운 내용 추가하기# adddata.pyf = open(\"C:/Python/새파일.txt\",'a')for i in range(11, 20):    data = \"%d번째 줄입니다.\\n\" % i    f.write(data)f.close()위 예는 새파일.txt라는 파일을 추가 모드(‘a’)로 열고 write를 이용해서 결과값을 기존 파일에 추가해 적는 예이다. 여기서 추가 모드로 파일을 열었기 때문에 새파일.txt라는 파일이 원래 가지고 있던 내용 바로 다음부터 결과값을 적기 시작한다.with문과 함께 사용하기f = open(\"foo.txt\", 'w')f.write(\"Life is too short, you need python\")f.close()  파일을 열면 위와 같이 항상 close해 주는 것이 좋다. 하지만 이렇게 파일을 열고 닫는 것을 자동으로 처리할 수 있다면 편리하지 않을까?with open(\"foo.txt\", \"w\") as f:    f.write(\"Life is too short, you need python\")  파이썬의 with문이 바로 이런 역할을 해준다. 위의 예는 with문을 이용해서 위 예제를 다시 작성한 모습이다.",
        "url": "/blackruby-code//back/2017/11/29/jump3.html"
      }
      ,
    
      "back-2017-11-29-jump2-html": {
        "title": "Jump to Python - 프로그램의 구조를 쌓는다(제어문)",
        "tags": "Python",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "프로그램의 구조를 쌓는 제어문제어문에는 if, while, for등의 제어문이 있다!if 문프로그래밍에서 조건을 판단하여 해당 조건에 맞는 상황을 수행하는 데 쓰이는 것이 바로 if문이다!&gt;&gt;&gt; money = 1&gt;&gt;&gt; if money:... \tprint(\"택시를 타고 가라\")... else:... \tprint(\"걸어 가라\")...택시를 타고 가라  money에 입력된 1은 참이다. 따라서 if문 다음의 문장이 수행되어 ‘택시를 타고 가라’가 출력 된다.if 문의 기본 구조  다음은 if와 else를 이용한 조건문의 기본 구조이다.if 조건문:\t수행할 문장1\t수행할 문장2\t...else:\t수행할 문장A\t수행할 문장B\t...  조건문을 테스트해서 참이면 if문 바로 다음의 문장(if 블록)들을 수행하고, 조건문이 거짓이면 else문 다음의 문장(else 블록)들을 수행하게 된다. 그러므로 else문은 if문 없이 독립적으로 사용할 수 없다.들여쓰기if문을 만들 때는 if조건문: 바로 아래 문장부터 if문에 속하는 모든 문장에 들여쓰기를 해주어야 한다. 다음과 같이 조건문이 참일 경우 “수행할 문장1”을 들여쓰기 했고, “수행할 문장2”와 “수행할 문장3”도 들여쓰기를 해주었다.if 조건문:\t수행할 문장1\t수행할 문장2\t수행할 문장3  다음과 같이 작성하면 오류가 발생한다. “수행할 문장2”를 들여쓰기 하지 않았기 때문이다.if 조건문:\t수행할 문장1수행할 문장2\t수행할 문장3조건문이란 무엇인가?if 조건문에서 “조건문”이란 참과 거짓을 판단하는 문장을 말한다.            자료형      참      거짓                  숫자      0이 아닌 숫자      0              문자열      “abc”      ””              리스트      [1,2,3]      []              튜플      (1,2,3)      ()              딕셔너리      {“a”:”b”}      {}      비교 연산자            비교 연산자      설명                  x&lt;y      x가 y보다 작다              x&gt;y      x가 y보다 크다              x==y      x와 y가 같다              x != y      x와 y가 같지 않다              x &gt;= y      x가 y보다 크거나 같다              x &lt;= y      x가 y보다 작거나 같다      and, or, not  조건을 판단하기 위해 사용하는 다른 연산자로는 and, or, not가 있다. 각각의 연산자는 다음처럼 동작한다            연산자      설명                  x or y      x와 y 둘중에 하나만 참이면 참이다              x and y      x와 y모두 참이어야 한다              not x      x가 거짓이면 참이다      &gt;&gt;&gt; money = 2000&gt;&gt;&gt; card = 1&gt;&gt;&gt; if money &gt;= 3000 or card:... \tprint(\"택시를 타고 가라\")... else:... \tprint(\"걸어가라\")...택시를 타고 가라  money는 2000이지만 card가 1이기 때문에 money &gt;= 3000 or card이라는 조건문이 참이 된다. 따라서 if문 다음의 “택시를 타고 가라” 문장이 수행된다!x in s, x not in s            in      not in                  x in 리스트      x not in 리스트              x in 튜플      x not in 튜플              x in 문자열      x not in 문자열      &gt;&gt;&gt; pocket = ['paper', 'cellphone', 'money']&gt;&gt;&gt; if 'money' in pocket:...     print(\"택시를 타고 가라\")... else:...     print(\"걸어가라\")...택시를 타고 가라&gt;&gt;&gt;  [‘paper’, ‘cellphone’, ‘money’]라는 리스트 안에 ‘money’가 있으므로 ‘money’ in pocket은 참이 된다. 따라서 if문 다음의 문장이 수행된다.다양한 조건을 판단하는 elif-if와 else만으로는 다양한 조건을 판단하기 어렵다. 다음과 같은 예를 보더라도 if와 else만으로는 조건을 판단하는 데 어려움을 겪게 된다.“주머니에 돈이 있으면 택시를 타고, 주머니에 돈은 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어 가라”      위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 주머니에 돈이 있는지를 판단해야 하고 주머니에 돈이 없으면 다시 카드가 있는지 판단해야 한다.          if와 else만으로 위의 문장을 표현하려면 다음과 같이 할 수 있다.          &gt;&gt;&gt; pocket = ['paper', 'handphone']  &gt;&gt;&gt; card = 1  &gt;&gt;&gt; if 'money' in pocket:  ...     print(\"택시를 타고가라\")  ... else:  ...     if card:  ...         print(\"택시를 타고가라\")  ...     else:  ...         print(\"걸어가라\")  ...  택시를 타고가라  &gt;&gt;&gt;              위의 예제는 산만한 느낌이지만 elif를 사용하면 다음과 같이 수정가능하다.          &gt;&gt;&gt; pocket = ['paper', 'cellphone']  &gt;&gt;&gt; card = 1  &gt;&gt;&gt; if 'money' in pocket:  ...      print(\"택시를 타고가라\")  ... elif card:   ...      print(\"택시를 타고가라\")  ... else:  ...      print(\"걸어가라\")  ...  택시를 타고가라      while문while문의 기본 구조반복해서 문장을 수행해야 할 경우 while문을 사용한다.  다음은 while문의 기본구조이다while &lt;조건문&gt;:    &lt;수행할 문장1&gt;    &lt;수행할 문장2&gt;    &lt;수행할 문장3&gt;    ...      while문은 조건문이 참인 동안에 while문 아래에 속하는 문장들이 반복해서 수행된다!          “열 번 찍어 안 넘어 가는 나무 없다”라는 속담을 파이썬 프로그램으로 만든다면 다음과 같이 될 것이다.          &gt;&gt;&gt; treeHit = 0  &gt;&gt;&gt; while treeHit &lt; 10:  ...     treeHit = treeHit +1  ...     print(\"나무를 %d번 찍었습니다.\" % treeHit)  ...     if treeHit == 10:  ...         print(\"나무 넘어갑니다.\")  ...  나무를 1번 찍었습니다.  나무를 2번 찍었습니다.  나무를 3번 찍었습니다.  나무를 4번 찍었습니다.  나무를 5번 찍었습니다.  나무를 6번 찍었습니다.  나무를 7번 찍었습니다.  나무를 8번 찍었습니다.  나무를 9번 찍었습니다.  나무를 10번 찍었습니다.  나무 넘어갑니다.      while문 직접 만들기다음은 여러가지 선택지 중 하나를 선택해서 입력받는 예제이다.&gt;&gt;&gt; prompt = \"\"\"... 1. Add... 2. Del... 3. List... 4. Quit...... Enter number: \"\"\"&gt;&gt;&gt;  이어서 number라는 변수에 0을 먼저 대입한다. 이렇게 변수를 먼저 설정해 놓지 않으면 다음에 나올 while문의 조건문인 number != 4에서 변수가 존재하지 않는다는 에러가 발생한다.&gt;&gt;&gt; number = 0&gt;&gt;&gt; while number != 4:...     print(prompt)...     number = int(input())...1. Add2. Del3. List4. QuitEnter number:      while문을 보면 number가 4가 아닌 동안 prompt를 출력하고 사용자로부터 번호를 입력받는다. 다음의 결과 화면처럼 사용자가 4라는 값을 입력하지 않으면 계속해서 prompt를 출력한다.          (※ 여기서 number = int(input())는 사용자의 숫자 입력을 받아들이는 것이라고만 알아두자)          Enter number:  1\t  1. Add  2. Del  3. List  4. Quit              4를 입력하면 조건문이 거짓이 되어 while문을 빠져나가게 된다.          Enter number:  4  &gt;&gt;&gt;      while문 강제로 빠져나가기      while문은 조건문이 참인 동안 계속해서 while문 안의 내용을 반복적으로 수행한다. 하지만 강제로 while문을 빠져나가고 싶을 때가 있다.          예를 들어 커피 자판기를 생각해 봤을 때, 자판기 안에 커피가 충분히 있을 때에는 동전을 넣으면 커피가 나온다. 그런데 자판기가 제대로 작동하려면 커피가 얼마나 남았는지 항상 검사해야 한다! 만약 커피가 떨어졌다면 판매를 중단하고 “판매 중지”라는 문구를 사용자에게 보여주어야 한다. 이렇게 판매를 강제로 멈추게 하는 것이 바로 break문이다.      &gt;&gt;&gt; coffee = 10&gt;&gt;&gt; money = 300&gt;&gt;&gt; while money:...     print(\"돈을 받았으니 커피를 줍니다.\")...     coffee = coffee -1...     print(\"남은 커피의 양은 %d개입니다.\" % coffee)...     if not coffee:...         print(\"커피가 다 떨어졌습니다. 판매를 중지합니다.\")...         break...  while문의 내용을 한 번 수행할 때마다 coffee = coffee - 1에 의해서 coffee의 개수가 1개씩 줄어든다. 만약 coffee가 0이 되면 if not coffee:라는 문장에서 not coffee가 참이 되므로 if문 다음의 문장인 “커피가 다 떨어졌습니다. 판매를 중지합니다.”가 수행되고 break문이 호출되어 while문을 빠져나가게 된다.조건에 맞지 않는 경우 맨 처음으로 돌아가기  while문 안의 문장을 수행할 때 입력된 조건을 검사해서 조건에 맞지 않으면 while문을 빠져나간다. 그런데 프로그래밍을 하다 보면 while문을 빠져나가지 않고 while문의 맨 처음(조건문)으로 다시 돌아가게 만들고 싶은 경우가 생기게 된다. 이때 사용하는 것이 바로 continue문이다.&gt;&gt;&gt; a = 0&gt;&gt;&gt; while a &lt; 10:...     a = a+1...     if a % 2 == 0: continue...     print(a)...13579  위의 예는 1부터 10까지의 숫자 중 홀수만을 출력하는 예이다. a가 10보다 작은 동안 a는 1만큼씩 계속 증가한다.무한 루프무한 루프란 무한히 반복한다는 의미이다. 우리가 사용하는 일반적인 프로그램 중에서 무한 루프의 개념을 사용하지 않는 프로그램은 거의 없다. 그만큼 자주 사용된다는 뜻이다.  다음은 무한 루프문의 기본적인 형태이다while True:     수행할 문장1     수행할 문장2    ...for문for문의 기본 구조for문의 기본적인 구조는 다음과 같다for 변수 in 리스트(또는 튜플, 문자열):    수행할 문장1    수행할 문장2    ...  리스트나 튜플, 문자열의 첫 번째 요소부터 마지막 요소까지 차례로 변수에 대입되어 “수행할 문장1”, “수행할 문장2” 등이 수행된다.  전형적인 for문&gt;&gt;&gt; test_list = ['one', 'two', 'three'] &gt;&gt;&gt; for i in test_list: ...     print(i)... one two three  다양한 for문의 사용&gt;&gt;&gt; a = [(1,2), (3,4), (5,6)]&gt;&gt;&gt; for (first, last) in a:...     print(first + last)...3711  위의 예는 a 리스트의 요소값이 튜플이기 때문에 각각의 요소들이 자동으로 (first, last)라는 변수에 대입된다.for문과 continue  while문에서 살펴보았던 continue를 for문에서도 사용할 수 있다. 즉, for문 안의 문장을 수행하는 도중에 continue문을 만나면 for문의 처음으로 돌아가게 된다.for와 함께 자주 사용하는 range함수for문은 숫자 리스트를 자동으로 만들어 주는 range라는 함수와 함께 사용되는 경우가 많다.&gt;&gt;&gt; a = range(10)&gt;&gt;&gt; arange(0, 10)  range(10)은 0부터 10 미만의 숫자를 포함하는 range 객체를 만들어 준다.for와 range를 이용한 구구단의 예&gt;&gt;&gt; for i in range(2,10): ...     for j in range(1, 10): ...         print(i*j, end=\" \") ...     print('') ... 리스트 안에 for문 포함하기리스트 안에 for문을 포함하는 리스트 내포(List comprehension)를 이용하면 좀 더 편리하고 직관적인 프로그램을 만들 수 있다&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; result = []&gt;&gt;&gt; for num in a:...     result.append(num*3)...&gt;&gt;&gt; print(result)[3, 6, 9, 12]  위 예제는 a라는 리스트의 각 항목에 3을 곱한 결과를 result라는 리스트에 담는 예제다&gt;&gt;&gt; result = [num * 3 for num in a]&gt;&gt;&gt; print(result)[3, 6, 9, 12]  리스트 내포를 이용하면 위와 같이 간단히 해결할 수 있다.",
        "url": "/blackruby-code//back/2017/11/29/jump2.html"
      }
      ,
    
      "back-2017-11-29-jump1-html": {
        "title": "Jump to Python - 파이썬 프로그래밍의 기초(자료형)",
        "tags": "Python",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "숫자형숫자형(Number)이란 숫자 형태로 이루어진 자료형이다!            항목      사용 예                  정수      123, -345, 0              실수      123.45, -1234.5, 3.4e10              8진수      0o34, 0o25              16진수      0x2A, 0xFF      숫자형은 어떻게 만들고 사용할까?정수형정수형(integer)란 말 그대로 정수를 뜻하는 자료형을 말한다. 다음은 양의 정수와 음의 정수, 숫자0을 변수 a에 대입하는 예이다.&gt;&gt;&gt; a = 123&gt;&gt;&gt; a = -178&gt;&gt;&gt; a = 0실수형파이썬에서 실수형(Floating-point)은 소수점이 포함된 숫자를 말한다. 다음 예는 실수를 변수 a에 대입하는 예이다&gt;&gt;&gt; a = 1.2&gt;&gt;&gt; a = -3.45위의 방식은 우리가 일반적으로 볼 수 있는 실수형의 소수점 표현 방식이다.&gt;&gt;&gt; a = 4.24E10&gt;&gt;&gt; a = 4.24e-10  위의 방식은 “컴퓨터식 지수 표현 방식”으로 파이썬에서는 4.24e10 또는 4.24E10처럼 표현한다.8진수와 16진수  8진수(Octal)를 만들기 위해서는 숫자가 0o 또는 0O(숫자 0 + 알파벳 소문자 o또는 대문자 O)로 시작하면 된다.&gt;&gt;&gt; a = 0o177  16진수를 만들기 위해서는 0x로 시작하면 된다.&gt;&gt;&gt; a = 0x8ff&gt;&gt;&gt; b = 0xABC숫자형을 활용하기 위한 연산자사칙연산&gt;&gt;&gt; a = 3&gt;&gt;&gt; b = 4&gt;&gt;&gt; a + b7&gt;&gt;&gt; a * b12&gt;&gt;&gt; a / b0.75x의 y제곱을 나타내는 \t**연산자이 연산자는 x ** y처럼 사용되었을 때 x의 y제곱(xy)값을 리턴한다.&gt;&gt;&gt; a = 3&gt;&gt;&gt; b = 4&gt;&gt;&gt; a ** b81나눗셈 후 나머지를 반환하는 %연산자%는 나눗셈의 나머지 값을 반환하는 연산자이다.&gt;&gt;&gt; 7 % 31&gt;&gt;&gt; 3 % 73나눗셈 후 소수점 아랫자리는 버리는 //연산자// 연산자를 이용할때의 주의할점  다음처럼 음수에 //연산자를 적용하는 경우&gt;&gt;&gt; -7 / 4&gt;&gt;&gt; -1.75&gt;&gt;&gt; -7 // 4&gt;&gt;&gt; -2//연산자는 나눗셈의 결과에서 무조건 소수점을 버리는것이 아니라 나눗셈의 결과값보다 작은 정수 중, 가장 큰 정수를 리턴한다.문자열 자료형문자열(String)이란 문자, 단어 등으로 구성된 문자들의 집합을 의미한다. 예를 들어 다음과 같은 것들이 문자열이다.\"Life is too short, You need Python\"\"a\"\"123\"문자열은 어떻게 만들고 사용할까?  큰따옴표로 양쪽 둘러싸기\"Hello World\"  작은따옴표로 양쪽 둘러싸기'Python is fun'  큰따옴표 3개를 연속으로 써서 양쪽 둘러싸기\"\"\"Lifr is too short, You need python\"\"\"  작은따옴표 3개를 연속으로 써서 양쪽 둘러싸기'''Life is too short, You need python'''문자열 안에 짝은 따옴표나 큰따옴표를 포함시키고 싶을 때1) 문자열에 작은따옴표(')포함시키기Python's favorite food is perl위와 같은 문자열을 food라는 변수에 저장하고 싶다고 가정하자. 문자열 중 Python’s에 작은따옴표(‘)가 포함되어 있다.  이럴때는 다음과 같이 문자열을 큰따옴표(“)로 둘러싸야 한다. 큰따옴표 안에 들어 있는 작은 따옴표는 문자열을 나타내기 위한 기호로 인식되지 않는다.&gt;&gt;&gt; food = \"Python's favorite food is perl\"프롬프트에 food를 입력해서 결과를 확인하면, 변수에 저장된 문자열이 그대로 출력된다&gt;&gt;&gt; food\"Python's favorite food is perl\"  다음과 같이 큰따옴표(“)가 아닌 작은따옴표(‘)로 문자열을 둘러싼 후 다시 실행해보면, ‘Python’이 문자열로 인식되어 오류가 발생한다&gt;&gt;&gt; food = 'Python's favorite food is perl'File \"&lt;stdin&gt;\", line 1food = 'Python's favorite food is perl'^SyntaxError: invalid syntax2) 문자열에 큰따옴표(\")포함시키기\"Python is very easy.\" he says.위와 같이 큰따옴표가 포함된 문자열이라면 다음과 같이 작은 따옴표로 둘러싸면 된다&gt;&gt;&gt; say = '\"Python is very easy.\" he says.'  작은따옴표안에 사용된 큰따옴표는 문자열을 만드는 기호로 인식되지 않는다.3) \\(백슬래시)를 이용해서 작은따옴표(')와 큰따옴표(\")를 문자열에 포함시키기&gt;&gt;&gt; food = 'Python\\'s favorite food is perl'&gt;&gt;&gt; say = \"\\Python is very easy.\\\" he says.\"  \\(백슬래시) 뒤의 작은따옴표나 큰따옴표는 문자열을 둘러싸는 기호의 의미가 아니라 문자(‘),(“)그 자체를 뜻하게 된다.여러 줄인 문자열을 변수에 대입하고 싶을 때Life is too shortYou need python1) 줄을 바꾸기 위한 이스케이프 코드 \\n 삽입하기&gt;&gt;&gt; multiline = \"Life is too short\\nYou need python\"2) 연속된 작은따옴표 3개(''')또는 큰따옴표 3개(\"\"\")이용&gt;&gt;&gt; multiline='''... Life is too short... You need python... '''  print(multiline)을 입력해서 출력되는 값&gt;&gt;&gt; print(multiline)Life is too shortYou need python여러줄인 경우 이스케이프 코드를 쓰는 것보다 따옴표를 연속해서 쓰는 것이 훨씬 깔끔하다문자열 연산하기1) 문자열 더해서 연결하기&gt;&gt;&gt; head = \"Python\"&gt;&gt;&gt; tail = \" is fun!\"&gt;&gt;&gt; head + tail'Python is fun!'  head와 tail 변수가 +에 의해 합쳐지게 된다.2) 문자열 곱하기&gt;&gt;&gt; a = \"python\"&gt;&gt;&gt; a * 2'pythonpython'  *는 문자열의 반복을 뜻하는 의미로 사용되었다.문자열 인덱싱과 슬라이싱인덱싱(Indexing)이란 무엇인가를 “가리킨다”는 의미이고, 슬라이싱(Slicing)은 무엇인가를 “잘라낸다”는 의미이다.문자열 인덱싱이란?&gt;&gt;&gt; a = \"Life is too short, You need Python\"위의 코드에서 변수 a에 저장한 문자열의 각 문자마다 번호를 매겨보면 다음과 같다Life is too short, You need Python0         1         2         3 0123456789012345678901234567890123&gt;&gt;&gt; a = \"Life is too short, You need Python\"&gt;&gt;&gt; a[3]'e'  a[3]이 뜻하는 것은 a라는 문자열의 네 번째 문자인 e를 말한다.“파이썬은 0부터 숫자를 센다.”고로 위의 문자열을 파이썬은 다음과 같이 바라본다a[0]:'L', a[1]:'i', a[2]:'f', a[3]:'e', a[4]:' ', ...  a[번호]는 문자열 내 특정한 값을 뽑아내는 역할을 한다. 이러한 것을 인덱싱이라고 한다!문자열 인덱싱 활용하기&gt;&gt;&gt; a = \"Life is too short, You need Python\"&gt;&gt;&gt; a[0]'L'&gt;&gt;&gt; a[12]'s'&gt;&gt;&gt; a[-1]'n'  뒤에서부터 첫 번째 문자를 표시할 때도 0부터 세어 “a[-0]이라고 해야 하지 않을까?”라는 의문이 들 수도 있지만 0 과 -0은 똑같은 것이기 때문에 a[-0]은 a[0]과 똑같은 값을 보여준다&gt;&gt;&gt; a[-0]'L'문자열 슬라이싱이란?“Life is too short, You need Python”이라는 문자열에서 단순히 한 문자열만을 뽑아내는 것이 아니라 ‘Life’또는 ‘You’같은 단어들만 뽑아내려면 다음과 같이 하면된다.&gt;&gt;&gt; a = \"Life is too short, You need Python\"&gt;&gt;&gt; b = a[0] + a[1] + a[2] + a[3]&gt;&gt;&gt; b'Life'  하지만 이것은 슬라이싱 기법으로 다음고 같이 더 간단하게 처리 할 수 있다.&gt;&gt;&gt; a = \"Life is too short, You need Python\"&gt;&gt;&gt; a[0:4]'Life'문자열을 슬라이싱하는 방법&gt;&gt;&gt; a[0:5]'Life'  위의 예는 a[0] + a[1] + a[2] + a[3] + a[4]와 동일하다.슬라이싱할 때 항상 시작 번호가 ‘0’일 필요는 없다.&gt;&gt;&gt; a[0:2]'Li'&gt;&gt;&gt; a[5:7]'is'&gt;&gt;&gt; a[12:17]'short'a[시작 번호:끝 번호]에서 끝 번호 부분을 생략하면 시작번호부터 그 문자열의 끝까지 뽑아낸다.&gt;&gt;&gt; a[19:]'You need Python'a[시작 번호:끝 번호]에서 시작 번호와 끝 번호를 생략하면 문자열의 처음부터 끝까지를 뽑아낸다&gt;&gt;&gt; a[:]'Life is too short, You need Python'슬라이싱에서도 인덱싱과 마찬가지로 마이너스(-) 기호를 사용할 수 있다.&gt;&gt;&gt; a[19:-7]'You need'  위 소스 코드에서 a[19:-7]이 뜻하는 것은 a[19]에서부터 a[-8]까지를 말한다.슬라이싱으로 문자열 나누기다음은 자주 사용하게 되는 슬라이싱 기법 중 하나이다.&gt;&gt;&gt; a = \"20010331Rainy\"&gt;&gt;&gt; date = a[:8]&gt;&gt;&gt; weather = a[8:]&gt;&gt;&gt; date'20010331'&gt;&gt;&gt; weather'Rainy'  위의 예에서는 “20010331Rainy”라는 문자열을 날짜를 나타내는 부분인 ‘20010331’과 날씨를 나타내는 부분인’Rainy’로 나누는 방법을 보여준다!!문자열 포매팅“현재 온도는 18도 입니다”“현재 온도는 20도 입니다”  위의 두 문자열은 모두 같은데 20이라는 숫자와 18이라는 숫자만 다르다. 이렇게 문자열 내의 특정한 값을 바꿔야 할 경우가 있을 때 이것을 가능하게 해주는 것이 바로 문자열 포매팅 기법이다!문자열 포매팅 따라하기1) 숫자 바로 대입&gt;&gt;&gt; \"I eat %d apples.\" % 3'I eat 3 apples.'  위의 예제에서는 문자열 내에 3이라는 정수를 삽입하는 방법을 보여준다!2) 문자열 바로 대입문자열 내에 꼭 숫자만 넣으라는 법은 없다! 숫자 대신 문자열도 가능하다!&gt;&gt;&gt; 'I eat %s apples.\" % \"five\"'I eat five apples.'  숫자를 넣기 위해서는 %d를 사용한다  문자열을 넣기 위해서는 %s를 사용한다(문자열을 대입할 때는 큰따옴표나 작은 따옴표를 반드시 사용해야 한다)3) 숫자 값을 나타내는 변수로 대입&gt;&gt;&gt; number = 3 &gt;&gt;&gt; \"I eat %d apples.\" % number'I eat 3 apples.'  숫자를 바로 대입하나 숫자 값을 나타내는 변수를 대입하나 결과는 같다문자열 포맷 코드            코드      설명                  %s      문자열(String)              %c      문자 1개(character)              %d      정수(Integer)              %f      부동소수(floating-point)              %o      8진수              %x      16진수              %%      Literal%(문자%자체)      포맷 코드와 숫자 함께 사용하기1) 정렬과 공백&gt;&gt;&gt; \"%10s\" % \"hi\"'\t\t\thi'  “%10s”의 의미는 전체 길이가 10개인 문자열 공간에서 hi를 오른쪽으로 정렬하고 그 앞의 나머지는 공백으로 남겨두라는 의미이다.2) 소수점 표현하기&gt;&gt;&gt; \"%0.4f\" % 3.42134234'3.4213'  3.42134234를 소수점 네 번째 자리까지만 나타내고 싶은 경우에는 위와 같이 사용한다!문자열 관련 함수들문자열 자료형은 자체적으로 가지고 있는 함수들이 있다. 이 함수들은 다른말로 문자열 내장함수라고 한다.문자 개수 세기(count)&gt;&gt;&gt; a = \"hobby\"&gt;&gt;&gt; a.count('b')2  문자열 중 b의 개수를 반환한다!위치 알려주기1(find)&gt;&gt;&gt; a = \"Python is best choice\"&gt;&gt;&gt; a.find('b')10&gt;&gt;&gt; a.find('k')-1  문자열 중 문자 b가 처음으로 나온 위치를 반환한다. 만약 찾는 문자나 문자열이 존재하지 않는다면 -1을 반환한다.(*파이썬은 숫자를 0부터 세기 때문에 b의 위치는 11이 아닌 10이 된다)위치 알려주기2(index)&gt;&gt;&gt; a = \"Life is too short\"&gt;&gt;&gt; a.index('t')8&gt;&gt;&gt; a.index('k')Traceback (most recent call last):File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: substring not found  문자열 중 문자 t가 맨 처음으로 나온 위치를 반환한다. 만약 찾는 문자나 문자열이 존재하지 않는다면 오류를 발생시킨다!문자열 삽입(join)&gt;&gt;&gt; a = \",\"&gt;&gt;&gt; a.join('abcd')'a,b,c,d'  abcd라는 문자열의 각각의 문자 사이에 변수 a의 값인’,’를 삽입한다.소문자를 대문자로 바꾸기(upper)&gt;&gt;&gt; a = \"hi\"&gt;&gt;&gt; a.upper()'HI'  upper()함수는 소문자를 대문자로 바꾸어 준다!대문자를 소문자로 바꾸기(lower)&gt;&gt;&gt; a = \"HI\"&gt;&gt;&gt; a.lower()'hi'  lower() 함수는 대문자를 소문자로 바꾸어 준다!왼쪽 공백 지우기(lstrip)&gt;&gt;&gt; a = \" hi \"&gt;&gt;&gt; a.lstrip()'hi '오른쪽 공백 지우기(rstrip)&gt;&gt;&gt; a = \" hi \"&gt;&gt;&gt; a.rstrip()' hi'양쪽 공백 지우기(strip)&gt;&gt;&gt; a = \" hi \"&gt;&gt;&gt; a.strip()'hi'문자열 바꾸기(replace)&gt;&gt;&gt; a = \"Life is too short\"&gt;&gt;&gt; a.replace(\"Life\", \"Your leg\")'Your leg is too short'  문자열 내의 특정한 값을 다른 값으로 치환해준다!문자열 나누기(split)&gt;&gt;&gt; a = \"Life is too short\"&gt;&gt;&gt; a.split()['Life', 'is', 'too', 'short']&gt;&gt;&gt; a = \"a:b:c:d\"&gt;&gt;&gt; a.split(':')['a', 'b', 'c', 'd']리스트 자료형리스트는 어떻게 만들고 사용할까?리스트를 만들 때에는 대괄호([])로 감싸 주고 각 요소값들은 쉼표(,)로 구분해 준다&gt;&gt;&gt; odd = [1, 3, 5, 7, 9]여러가지 리스트의 형태&gt;&gt;&gt; a = [ ]&gt;&gt;&gt; b = [1, 2, 3]&gt;&gt;&gt; c = ['Life', 'is', 'too', 'short']&gt;&gt;&gt; d = [1, 2, 'Life', 'is']&gt;&gt;&gt; e = [1, 2, ['Life', 'is']]  리스트는 a처럼 아무것도 포함하지 않는, 비어있는 리스트([])일 수도 있고 b처럼 숫자를 요소값으로 가질 수도 있고 c처럼 문자열을 요소값으로 가질 수도 있다.(*비어 있는 리스트는 a = list()로 생성할 수도 있다)리스트의 인덱싱과 슬라이싱리스트도 문자열처럼 인덱싱과 슬라이싱이 가능하다.리스트의 인덱싱리스트 역시 문자열처럼 인덱싱을 적용 할 수 있다. 먼저 a 변수에 [1,2,3]이라는 값을 설정한다.&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a[1, 2, 3]a[0]은 리스트 a의 첫번째 요소값을 말한다&gt;&gt;&gt; a[0]1아래의 예는 리스트의 첫번째 요소인 a[0]과 세번째 요소인 a[2]의 값을 더한것이다&gt;&gt;&gt; a[0] + a[2]4  이것은 1 + 3으로 해석되고 4라는 값을 출력한다리스트의 슬라이싱문자열과 마찬가지로 리스트에서도 슬라이싱 기법을 적용할 수 있다!  슬라이싱은 “나눈다”라는 뜻이다&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; a[0:2][1, 2]리스트 연산자리스트 역시 + 기호를 이용해서 더할 수 있고, *기호를 이용해서 반복할 수 있다.1) 리스트 더하기(+)&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [4, 5, 6]&gt;&gt;&gt; a + b[1, 2, 3, 4, 5, 6]2) 리스트 반복하기(*)&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a * 3[1, 2, 3, 1, 2, 3, 1, 2, 3]리스트의 수정, 변경과 삭제1. 리스트에서 하나의 값 수정하기&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a[2] = 4&gt;&gt;&gt; a[1, 2, 4]2. 리스트에서 연속된 범위의 값 수정하기&gt;&gt;&gt; a[1:2][2]&gt;&gt;&gt; a[1:2] = ['a', 'b', 'c']&gt;&gt;&gt; a[1, 'a', 'b', 'c', 4]  a[1:2]를 [‘a’, ‘b’, ‘c’]로 바꾸었으므로 a리스트에서 2라는 값 대신에 [‘a’, ‘b’, ‘c’]라는 값이 대입된다.주의할점만약 전제를 a[1:2]가 아니라 a[1] = [‘a’, ‘b’, ‘c’]로 한다면 a의 출력값은 [1, [‘a’, ‘b’, ‘c’], 4]가 된다!!3. [ ]사용해 리스트 요소 삭제하기&gt;&gt;&gt; a[1:3] = []&gt;&gt;&gt; a[1, 'c', 4]4. del 함수 사용해 리스트 요소 삭제하기&gt;&gt;&gt; a [1, 'c', 4]&gt;&gt;&gt; del a[1]&gt;&gt;&gt; a[1, 4]리스트 관련 함수들리스트에 요소 추가(append)&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a.append(4)&gt;&gt;&gt; a[1, 2, 3, 4]리스트 정렬(sort)&gt;&gt;&gt; a = [1, 4, 3, 2]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4]리스트 뒤집기(reverse)&gt;&gt;&gt; a = ['a', 'c', 'b']&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a['b', 'c', 'a']위치 반환(index)index(x)함수는 리스트에 x라는 값이 있으면 x의 위치값을 리턴한다&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; a.index(3)2&gt;&gt;&gt; a.index(1)0리스트에 요소 삽입(insert)insert(a, b)는 리스트의 a번째 위치에 b를 삽입하는 함수이다.&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a.insert(0, 4)[4, 1, 2, 3]리스트 요소 제거(remove)remove(x)는 리스트에서 첫번째로 나오는 x를 삭제하는 함수이다.&gt;&gt;&gt; a = [1, 2, 3, 1, 2, 3]&gt;&gt;&gt; a.remove(3)[1, 2, 1, 2, 3]리스트 요소 끄집어내기(pop)pop()은 리스트의 맨 마지막 요소를 돌려주고 그 요소는 삭제하는 함수이다!&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; a.pop()3&gt;&gt;&gt; a[1, 2]리스트에 포함된 요소 x의 개수 세기(count)count(x)는 리스트 내에 x가 몇개 있는지 조사하여 그 개수를 돌려준다&gt;&gt;&gt; a = [1,2,3,1]&gt;&gt;&gt; a.count(1)2  1이라는 값이 리스트 a에 2개 들어있으므로 2를 반환한다!리스트 확장(extend)extend(x)에서 x에는 리스트만 올 수 있으며 원래의 a 리스트에 x 리스트를 더하게 된다.&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; a.extend([4,5])&gt;&gt;&gt; a[1, 2, 3, 4, 5]&gt;&gt;&gt; b = [6, 7]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6, 7]튜플 자료형튜플은 어떻게 만들까?  리스트는 [과 ]으로 둘러싸지만 튜플은 (과 )으로 둘러싼다  리스트는 그 값의 생성, 삭제, 수정이 가능하지만 튜플은 그 값을 바꿀 수 없다&gt;&gt;&gt; t1 = ()&gt;&gt;&gt; t2 = (1,)&gt;&gt;&gt; t3 = (1, 2, 3)&gt;&gt;&gt; t4 = 1, 2, 3&gt;&gt;&gt; t5 = ('a', 'b', ('ab', 'cd'))튜플의 요소값을 지우거나 변경하려고 하면 어떻게 될까?튜플의 값을 리스트값을 지우거나 변경하는 것처럼 하면 오류가 발생한다!!튜플의 인덱싱과 슬라이싱, 더하기(+)와 곱하기(*)1. 인덱싱하기&gt;&gt;&gt; t1 = (1, 2, 'a', 'b')&gt;&gt;&gt; t1[0]1&gt;&gt;&gt; t1[3]'b'  문자열, 리스트와 마찬가지로 t1[0], t1[3]처럼 인덱싱이 가능하다2. 슬라이싱하기&gt;&gt;&gt; t1 = (1, 2, 'a', 'b')&gt;&gt;&gt; t1[1:](2, 'a', 'b')3. 튜플 더하기&gt;&gt;&gt; t2 = (3, 4)&gt;&gt;&gt; t1 + t2(1, 2, 'a', 'b', 3, 4)4. 튜플 곱하기&gt;&gt;&gt; t2 * 3(3, 4, 3, 4, 3, 4)딕셔너리 자료형파이썬에서는 자료형을 딕셔너리 라고 하며, Key와 Value값으로 한쌍을 이루는 자료형이다!  예컨대, Key가 “baseball”이라면 Value는 “야구”가 될 것이다!딕셔너리는 어떻게 만들까?Key에는 변하지 않는 값을 사용하고, Value에는 변하는 값과 변하지 않는 값 모두 사용 가능하다!딕셔너리 dic의 정보            key      value                  name      pey              phone      0118888888              birth      1111        다음의 예는 Key로 정수값 1, Value로 ‘hi’라는 문자열을 사용한 예이다&gt;&gt;&gt; a = {1: 'hi'}  다음의 예처럼 Value에 리스트를 넣을 수도 있다.&gt;&gt;&gt; a = {'a': [1,2,3]}딕셔너리 쌍 추가, 삭제하기추가되는 순서는 원칙이 없다!중요한 것은 “무엇이 추가되었는가”이다!1. 딕셔너리 쌍 추가하기&gt;&gt;&gt; a = {1: 'a'}&gt;&gt;&gt; a[2] = 'b'&gt;&gt;&gt; a{2: 'b', 1: 'a'}  {1: ‘a’}라는 딕셔너리에 a[2] = ‘b’와 같이 입력하면 딕셔너리 a에 Key와 Value가 각각 2와 ‘b’인 2: ‘b’라는 딕셔너리 쌍이 추가된다.2. 딕셔너리 요소 삭제하기&gt;&gt;&gt; del a[1]&gt;&gt;&gt; a{'name': 'pey', 3: [1, 2, 3], 2: 'b'}  del 함수를 사용해서 del a[key]처럼 입력하면 지정한 key에 해당하는 {key: value}쌍이 삭제된다!딕셔너리를 사용하는 방법예를 들어, 4명의 사람이 있다고 가정하고 각자의 특기를 표현 할 수 있는 좋은 방법에 대해서 생각해봤을때 리스트나 문자열로는 표현하기가 상당히 까다롭지만 딕셔너리를 사용하면 표현하기가 쉽다!!딕셔너리에서 Key 사용해 Value 얻기&gt;&gt;&gt; grade = {'pey': 10, 'julliet': 99}&gt;&gt;&gt; grade['pey']10&gt;&gt;&gt; grade['julliet']99  위의 예에서, ‘pey’라는 Key의 Value를 얻기 위해 grade[‘pey’]를 사용한 것처럼 어떤 Key의 어떤 Value를 얻기 위해서는 “딕셔너리 변수[Key]”를 사용한다!딕셔너리를 만들 때 주의사항딕셔너리에서 Key는 고유한 값이므로 중복되는 Key값을 설정해놓으면 하나를 제외한 나머지 것들이 모두 무시된다 ( 꼭 어떤것이 무시될지는 알수없다! )  중복되는 Key를 사용하지 말아야한다.&gt;&gt;&gt; a = {1: 'a', 1: 'b'}&gt;&gt;&gt; a{1: 'b'}  Key를 통해서 Value를 얻는 딕셔너리의 특징상, 동일한 Key가 존재한다면 어떤 Key에 해당하는 Value를 불러야 할 지 알 수 없기 때문이다!딕셔너리 관련 함수들Key 리스트 만들기(keys)&gt;&gt;&gt; a = {'name': 'pey', 'phone': '0118384384', 'birth': '1111'}&gt;&gt;&gt; a.keys()dict_keys(['name', 'phone', 'birth'])  a.keys()는 딕셔너리 a의 Key만을 모아서 dict_keys라는 객체를 리턴한다!**dict_keys 객체는 리스트를 사용하는 것과는 차이가 없지만, 리스트 고유의 함수인 append, insert, pop, remove, sort등의 함수를 수행할 수는 없다!&gt;&gt;&gt; for k in a.keys():... \tprint(k)...phonebirthnamedict_keys 객체를 리스트로 변환하려면 다음과 같이 하면 된다!&gt;&gt;&gt; list(a.keys())['phone', 'birth', 'name']Value 리스트 만들기(value)&gt;&gt;&gt; a.values()dict_values(['pey', '0102392392', '1111'])  key를 얻는 것과 마찬가지 방법으로 Value만 얻고 싶다면 a.value()처럼 value함수를 사용하면 된다!Key, Value 쌍 얻기(items)&gt;&gt;&gt; a.items()dict_items([('name', 'pey'), ('phone', '01024242424'), ('birth', '1111')])  item 함수는 key와 value의 쌍을 튜플로 묶은 값을 dict_items 객체로 돌려준다!Key: Value 쌍 모두 지우기(clear)&gt;&gt;&gt; a.clear()&gt;&gt;&gt; a{}  clear() 함수는 딕셔너리 안의 모든 요소를 삭제한다.Key로 Value얻기(get)&gt;&gt;&gt; a = {'name': 'pey', 'phone':'0102222222', 'birth': '1111'}&gt;&gt;&gt; a.get('name')'pey'&gt;&gt;&gt; a.get('phone')'01022222222'  get(x) 함수는 x라는 key에 대응되는 value를 돌려준다해당 Key가 딕셔너리 안에 있는지 조사하기(in)&gt;&gt;&gt; a = {'name':'pey', 'phone':'0102222222', 'birth':'1111'}&gt;&gt;&gt; 'name' in aTrue&gt;&gt;&gt; 'email' in aFalse  ‘name’이라는 문자열은 a 딕셔너리의 key 중 하나이다. 따라서 ‘name’ in a를 호출하면 참(True)을 리턴한다.집합 자료형집합 자료형은 어떻게 만들까?집합(set)은 파이썬 2.3부터 지원되기 시작한 자료형으로, 집합에 관련된 것들을 쉽게 처리하기 위해 만들어진 자료형이다.  집합 자료형은 다음과 같이 set 키워드를 이용해 만들 수 있다.&gt;&gt;&gt; s1 = set([1,2,3])&gt;&gt;&gt; s1{1, 2, 3}집합 자료형의 특징  중복을 허용하지 않는다.  순서가 없다리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있지만 set 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.  만약 set 자료형에 저장된 값을 인덱싱으로 접근하려면 다음과 같이 리스트나 튜플로 변환한 후 사용 가능하다.&gt;&gt;&gt; s1 = set([1,2,3])&gt;&gt;&gt; l1 = list(s1)&gt;&gt;&gt; l1[1, 2, 3]&gt;&gt;&gt; l1[0]1&gt;&gt;&gt; t1 = tuple(s1)&gt;&gt;&gt; t1(1, 2, 3)&gt;&gt;&gt; t1[0]1집합 자료형 활용하는 방법교집합, 합집합, 차집합 구하기set 자료형이 정말 유용하게 사용되는 경우는 다음과 같이 교집합, 합집합, 차집합을 구할 때이다!&gt;&gt;&gt; s1 = set([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; s2 = set([4, 5, 6, 7, 8, 9])1. 교집합s1과 s2의 교집합&gt;&gt;&gt; s1 &amp; s2{4, 5, 6}2. 합집합&gt;&gt;&gt; s1 | s2{1, 2, 3, 4, 5, 6, 7, 8, 9}  4,5,6처럼 중복해서 포함된 값은 한개씩만 표현된다3. 차집합&gt;&gt;&gt; s1 - s2{1, 2, 3}&gt;&gt;&gt; s2 - s1{8, 9, 7}집합 자료형 관련 함수들값 1개 추가하기(add)&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s1.add(4)&gt;&gt;&gt; s1{1, 2, 3, 4}  이미 만들어진 set 자료형에 값을 추가할 수 있다. 1개의 값만 추가(add)할 경우에는 위와 같이 한다.값 여러 개 추가하기(update)&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s1.update([4, 5, 6])&gt;&gt;&gt; s1{1, 2 ,3, 4, 5, 6}특정 값 제거하기(remove)&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s1.remove(2)&gt;&gt;&gt; s1{1, 3}자료형의 참과 거짓자료형에도 참과 거짓이 있다. 이는 매우 중요한 특징이며 실제로도 자주 쓰인다.&gt;&gt;&gt; a = [1, 2, 3, 4]&gt;&gt;&gt; while a:... \ta.pop()... 4321  먼저 a = [1,2,3,4]라는 리스트를 하나 만들었다.while 조건문:\t수행할 문장      조건문이 참인 동안 조건문 안에 있는 문장을 반복해서 수행한다!        위의 예를 보면 a가 참인 경우에 a.pop()을 계속 실행하라는 의미이다. a.pop()이라는 함수는 리스트 a의 마지막 요소를 끄집어내는 함수이므로 a가 참인 동안(리스트 내에 요소가 존재하는 한)\u0010마지막 요소를 계속해서 끄집어낼 것이다.  &gt;&gt;&gt; if [ ]:...\t \tprint(\"True\")... else:... \tprint(\"False\")...False  위의 에제를 보면 쉽게 이해 할 수 있다.&gt;&gt;&gt; if [1, 2, 3]:... \tprint(\"True\")... else:... \tprint(\"False\")...True      위의 코드를 해석하면 이와 같다고 할 수 있다.          만약 [1,2,3]이 참이면, “True”라는 문자열을 출력하고, 그렇지 않다면 “False”라는 문자열을 출력해라!”      위 코드의 [1,2,3]은 요소값이 있는 리스트이기 때문에 참이다!자료형의 값을 저장하는 공간, 변수&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = \"python\"&gt;&gt;&gt; c = [1,2,3]변수를 만들 때는 위의 예처럼 =(assignment)\u0010기호를 사용한다.변수명 = 변수에 저장할 값변수란?&gt;&gt;&gt; a = 3   만약 위의 코드처럼 a = 3이라고 한다면 3이라는 값을 가지는 정수 자료형(객체)이 자동으로 메모리에 생성된다. a는 변수의 이름이며, 3이라는 정수형 객체가 저장된 메모리 위치를 가리키게 된다!a–&gt;3&gt;&gt;&gt; a = 3 &gt;&gt;&gt; b = 3&gt;&gt;&gt; a is bTrue  a가 3을 가리키고 b도 3을 가리킨다. 즉 a = 3 을 입력하는 순간, 3이라는 정수형 객체가 생성되고 변수 a는 3이라는 객체의 메모리 주소를 가리킨다!변수를 만드는 여러가지 방법&gt;&gt;&gt; a, b = ('python', 'life')  위의 예문처럼 튜플로 a,b에 값을 대입 할 수 있다.&gt;&gt;&gt; (a, b) = 'python', 'life'  튜플은 괄호를 생략해도 된다!메모리에 생성된 변수 없애기!!a=3을 입력하면 3이라는 정수형 객체가 메모리에 생성된다고 했다. 그렇다면 이 값을 메모리에서 없앨 수 있을까? 3이라는 객체를 가리키는 변수들의 개수를 레퍼런스 카운트라고 하였는데, 이 레퍼런스 카운트가 0이 되는 순간 3이라는 객체는 자동으로 사라진다. 즉, 3이라는 객체를 가리키고 있는 것이 하나도 없을 때 3이라는 객체는 메모리에서 사라지게 된다! 이것을 어려운 말로 가비지 콜렉션(쓰레기 수집)이라고도 한다!  다음은 특정한 객체를 가리키는 변수를 없애는 것이다&gt;&gt;&gt; a = 3&gt;&gt;&gt; b = 3 &gt;&gt;&gt; del(a)&gt;&gt;&gt; del(b)  변수 a와 b가 3이라는 객체를 가리켰다가 del이라는 파이썬 내장 함수에 의해서 사라진다. 따라서 레퍼런스 카운트가 0이 되어 정수형 객체 3도 메모리에서 사라지게 된다(* 사용한 변수를 del 명령어를 이용하여 일일이 삭제할 필요는 없다. 파이썬이 이 모든 것을 자동으로 해준다)** 리스트를 변수에 넣고 복사하고자 할 때&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[1] = 4&gt;&gt;&gt; a[1, 4, 3]&gt;&gt;&gt; b[1, 4, 3]      b라는 변수에 a가 가리키는 리스트를 대입하였다. 그런 다음 a 리스트의 a[1]을 4라는 값으로 바꾸면 a 리스트만 바뀌는 것이 아니라 b 리스트도 똑같이 바뀐다.                  그렇다면 b변수를 생성할 때 a와 같은 값을 가지도록 복사해 넣으면서 a가 가리키는 리스트와는 다른 리스트를 가리키게 하는 방법은 없을까?                              두가지 방법이 있다.            #### 1. [:]의 이용              &gt;&gt;&gt; from copy import copy  &gt;&gt;&gt; b = copy(a)                        #### 2. copy 모듈 이용              &gt;&gt;&gt; b is a  False                                          ",
        "url": "/blackruby-code//back/2017/11/29/jump1.html"
      }
      ,
    
      "back-2017-11-29-jump-html": {
        "title": "Jump to Python - 파이썬이란 무엇인가?",
        "tags": "Python",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "파이썬이란?파이썬(Python)은 1990년 암스테르담의 귀도 반 로섬이 개발한 인터프리터 언어이다. 귀도는 파이썬이라는 이름을 자신이 좋아하는 코미디 쇼인 “몬티 파이썬의 날아다니는 서커스”에서 따왔다고 한다. 파이썬의 사전적인 의미는 고대신화에 나오는 파르나소스 산의 동굴에 살던 큰 뱀을 뜻하며, 아폴로 신이 델파이에서 파이썬을 퇴치했다는 이야기가 전해진다.파이썬의 특징파이썬은 인간다운 언어이다프로그래밍이란 인간이 생각하는 것을 컴퓨터에 지시하는 행위라고 할 수 있다.  파이썬은 사람이 생각하는 방식을 그대로 표현할 수 있는 언어이다.다음의 소스코드는if 4 in [1,2,3,4]: print(\"4가 있습니다\")  “만약 4가 1,2,3,4중에 있으면 “4 가 있습니다”를 출력한다.”로 해석하여 읽을 수 있다!파이썬은 간결하다귀도는 파이썬을 의도적으로 간결하게 만들었다. 만약 펄(Perl)과 같은 프로그래밍 언어가 100가지 방법으로 하나의 일을 처리할 수 있다면 파이썬은 가장 좋은 방법 1가지만 이용하는 것을 선호한다.# simple.pylanguages = ['python', 'perl', 'c', 'java']for lang in languages:    if lang in ['python', 'perl']:        print(\"%6s need interpreter\" % lang)    elif lang in ['c', 'java']:        print(\"%6s need compiler\" % lang)    else:        print(\"should not reach here\")위의 코드는 프로그래밍 언어를 판별하여 그에 맞는 문장을 출력하는 파이썬 프로그램 코드이다.  파이썬 프로그램은 줄을 맞추지 않으면 실행이 되지 않는다.  줄을 맞추어 코드를 작성하는 행위는 가독성에 크게 도움이 된다.파이썬은 개발 속도가 빠르다“Life is too short, You need python”  인생은 너무 짧으니 파이썬이 필요해!!파이썬으로 무엇을 할 수 있을까?파이썬으로 할 수 있는 일      시스템 유틸리티 제작        GUI 프로그래밍        C/C++와의 결합        웹프로그래밍        수치 연산 프로그래밍        데이터 베이스 프로그래밍        데이터 분석, 사물 인터넷  파이썬으로 할 수 없는일      시스템과 밀접한 프로그래밍 영역        모바일 프로그래밍  파이썬 기초 실습  대화형 인터프리터는 파이썬 쉘(Python shell)이라고도 한다. 3개의 꺾은 괄호(»&gt;)는 프롬프트(prompt)라고 한다.파이썬 기초 문법 따라하기사칙 연산  1 더하기(+)2는 3이라는 값을 출력해보자!. 보통 계산기 사용하듯 더하기 기호만 넣어주면 된다!&gt;&gt;&gt; 1 + 23  나눗셈(/)과 곱셈(*) 역시 예상한 대로 결과값을 보여준다.&gt;&gt;&gt; 3 / 2.41.25&gt;&gt;&gt; 3 * 927우리가 일반적으로 알고 있는 ÷ 기호나 × 기호가 아닌 것에 주의!!변수에 숫자 대입하고 계산하기&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a + b3  a에 1을, b에 2를 대입한 다음 a와 b를 더하면 3이라는 결과값을 보여준다!파이썬은 대소문자를 구분한다. print를 PRINT로 쓰면 정의되지 않았다는 에러 메세지가 나온다조건문 if다음은 조건문 if를 이용한 예제이다.&gt;&gt;&gt; a = 3 &gt;&gt;&gt; if a &gt; 1:... \tprint(\"a is greater than 1\")...a is greater than 1**print문의 앞의’…‘은 아직 문장이 끝나지 않았음을 의미한다!반복문 for다음은 for를 이용해서 [1, 2, 3]안의 값들을 하나씩 출력해 주는 것을 보여주는 예이다&gt;&gt;&gt; for a in [1,2,3]:... \tprint(a)... 123  for문을 이용하면 실행해야 할 문장을 여러 번 반복해서 실행시킬 수 있다. 위의 예는 대괄호([]) 사이에 있는 값들을 하나씩 출력한다.반복문 while다음은 while을 이용하는 예제이다&gt;&gt;&gt; i = 0&gt;&gt;&gt; while i &lt; 3:... \ti=i+1... \tprint(i)...123함수함수는 다음과 같은 형태이다!&gt;&gt;&gt; def sum(a, b):... \treturn a+b...&gt;&gt;&gt; print(sum(3,4))7      파이썬에서 def는 함수를 만들 때 사용하는 예약어이다!        sum(a,b)에서 a,b는 입력값이고, a+b는 결과값이다! 즉, 3, 4가 입력으로 들어오면 3+4를 수행하고 그 결과값인 7을 돌려준다!  ",
        "url": "/blackruby-code//back/2017/11/29/jump.html"
      }
      ,
    
      "code-2017-11-29-base-html": {
        "title": "코딩을 지탱하는 기술",
        "tags": "Code",
        "date": "November 29, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "코딩을 지탱하는 기술프로그래밍 학습에 중요한 포인트 3가지  비교를 통한 학습  역사를 통한 학습  만드는 것을 통한 학습규칙은 언어마다 다르다ex)  C언어에서는 0이 참이지만, ruby에서는 0이 거짓이다. 자바에서는 0이 단순한 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.잘못된 고정관념을 버려야 한다.특정언어에 국한된 지식을 습득할 것이 아니라 모든 언어에 통용 될 수 있는 이해력을 기를 필요가 있다.프로그래머의 삼대 미덕  나태함, 조바심, 자만심프로그래밍 언어는 사람을 편하게 하기 위해서 만들어졌다.  언어는 도구일 뿐이다가상소프트웨어의 선결과제 = 빠른 실행 속도ex)  C++ 은 빠른 실행 속도를 자랑하지만 높은 언어사양을 요구한다.–프로그래밍 언어에 대한 이해력을 확인하기 위해서는 아웃풋(결과물)을 확인해야한다.에러메세지가 발생하면 당황하거나 무서워하지말아야 한다. 내가 만든 것을 언어 처리계가 열심히 읽어서 여기를 모르겠다고 대답해주고 있는 것이다 - 언어 처리계와 제대로된 커뮤니케이션을 하는 방법      아직도 스택 머신(FORTH)은 살아있다.          Python이나 Ruby, Java로 프로그램을 짜면 그 프로그램은 내부적으로 FORTH와 같은 프로그램으로 변환(컴파일)되어 동작하고 있는 것이다.      –언어마다 차이가 생긴 것은…표현 방법이 틀릴뿐. 구문트리는 동일하다!  ‘어떤 문자열을 쓰면 어떤 구문 트리가 생기는가’ = 이것이 규칙이자 문법이다.현재 대부분의 프로그래밍 언어들은 다가가기 쉬운 언어 작성법을 목표로 하고 있다. 하지만 기존의 문법과 마찰되지 않도록하면서 새로운 문법을 추가하는 것은 굉장히 어려운 일이다!–if문if-else 구문의 이점  ‘조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다’ 이것을 간단하고 읽기 쉬운 형태로 볼 수 있게 해준다!else가 반드시 필요한 것은 아니다. 하지만 가독성 측면에서 사용하는 것이 좋다.–###반복문for문으로 가능한 것은 while문으로도 가능하긴 하다.while문 에서는 분산되어 있던 반복 조건문들이 for문에서는 한곳에 모여있기 때문에 루프문 작성자의 의도를 쉽게 파악 할 수 있다.foreach구문은 ‘어떤 대상의 요소 전부에 어떤 처리를 한다’는 코드를 쉽게 쓰기 위해 만들어졌다.Python의 for문은 foreach 구문이다. 역으로, C 언어의 for 문에 대응하는 구문은 없다!for문에서도 조건식으로 제어하고 있지만, 주요 사용 목적은 횟수를 의식한 제어다!ex)  for문은 정해진 범위 내에서 루프  while문은 범위가 없이 루프바꿔 말하자면, for문은 반복수를 알 때 사용한다. while문은 반복수를 모를 때 사용한다.–함수코드가 함수로 나누어져 있는 것은 큰 조직이 부서로 나눠져 있는 것과 같다!!!함수를 만드는 것은 작은 부품을 조립해서 큰 부품을 만드는 것과 같다!  예를 들어 무선 조정 자동차 속에는 모터가 있고 모터 속에는 코일이나 정류자가 들어있다!! = 함수의 개념이다      무선 조정 자동차가 느려지면 알칼리 전지가 약해졌다고 생각 할 수 있다        근처 편의점에 가서 전지를 구해야한다 = 함수의 이해와 같다  함수도 동일하다. 수십 행 수백 행의 코드가 함수로 정리되어 제공되고 있어서 그 함수를 호출해서 사용이 가능하다.프로그램을 만드는 것과 물리적인 것을 만드는 것의 차이 ( 비용의 차이 )      예를 들어 아파트 100세대에 급수기를 설치해야 한다면 100개의 급수기가 필요하다!        프로그램은 100개의 특정 데이터가 있으면 함수만 100회 호출하면 된다!  한계가 없다ex)  1: 110의 점프 명령의 점프 목적지를 3으로 바꾼다  2: 함수를 호출한다 ( 100으로 점프 )  3: 다음 명령.  …  51: 110의 점프 명령의 점프 목적지를 53으로 바꾼다.  52: 함수 호출 ( 100으로 점프 )  53: 다음 명령.  …  100: 함수 처리  …  110: 돌아간다 ( 0으로 점프 )이렇게 해서 함수가 탄생했다함수의 이름메모리상에서의 위치      함수를 사용한 처리에 이름을 붙이는 행위는 ‘처리가 시작되는 메모리상의 위치’를 수치로 표현하는 대신, 알기 쉬운 문자열로 표현하는 행위다.        변수도 마찬가지다. ‘값이 기록된 메모리 위치’를 수치가 아닌 문자열로 표현하기 위해 만들어졌다.  스택 ( Stack ) 영역  복수의 데이터 값을 저장해두는곳  마지막에 넣은 것을 가장 먼저 꺼내는 것에 적합  할당된 메모리 구조는 위에서부터 데이터 - 힙 - 스택 순으로 배치된다. (스택은 가장 아래부분)재귀 함수재귀함수는 함수 X안에서 함수 X 자신을 호출 하는 것이다!  내포 구조를 다루는데 적합하다!–재귀함수의 구조를 이해하기위한 좋은예ex)xs = [1,2,[3,4],5]def total(xs):    result = 0    for x in xs:        if is_integer(x):            result += x        else:            result += total(x)                return result     x는 내포 리스트이기 때문에 total로 안에 든 값을 합산한다!–에러 처리프로그램 실행 시 실패가 발생하는 경우가 많다. 실패 시에 어떻게 하는가(에러처리)는 매우 중요하다!!크게 방법은 두가지이다  반환값을 사용하는 방법  예외를 사용하는 방법반환값으로 실패를 전달하는 방법에 대해서…이 방법은 C 언어를 비롯해서 많은 언어가 사용하고 있는 중이다.그러나2가지 문제점이 있다.  실패를 놓친다.  에러 처리 때문에 코드를 해석하기 어렵다.때문에 점프로 에러를 처리하며 처리에는 goto를 사용한다.C 언어에는 예외기능이 없기 때문이다에러가 발생했을 때 점프할 장소를 사전에 등록해두는 방법이 있다. 이방법이 발전해서 오늘날의 ‘예외 처리’가 된 것이다UNIVAC I의 경우  ‘계산 시 오버플로우가 발생하면 xxx번지에 있는 명령을 실행한다’는 기능이 있었다. 이런 기능을 ‘인터럽트(interrupt)’라고 불렀다. (예로들면 키보드 입력 처리)COBOL의 경우1959년에 두가지 에러처리를 탑재하고 나타났다!      READ로 파일을 읽을 때 ‘AT END’라는 \t구문으로 ‘더 이상 데이터가 없다’ 등의 \t\t에러가 발생했을 때        ADD등으로 수치 계산을 할 때 오버플로우가 발생했을 경우 ‘ON SIZE ERROR’ 구문으로 처리를 표현  PL/I의 경우1964년 FORTRAN, COBOL, ANGOL을 집성해서 설계되었다.새롭게 정의한 실패를 프로그래머가 발생 시킬 수 있었다.프로그래밍은 짝이 되는 처리가 중요하다미술관을 예로들면, 입구에서 빌린 음성 안내기를 출구가 하나라면 제대로 회수 할 수 있지만, 출구가 여러개라면 회수가 어려워 진다.여기서 출구란 ( return )이문제는 finally를 사용해서 짝을 맞춰 줄 수 있으며 해결 할 수 있다.  finally 블록은 처리가 try 블록에서 벗어날 때 반드시 실행된다.Microsoft사에서 처음 도입했으며, 1995년에는 Java도 도입했다. 현재는 Python이나 Ruby에서도 동일한 구문을 지원하고 있다.C++은 finally를 갖고 있지 않다.함수를 벗어날때 함수의 지역 변수에 대해서 자동적으로 소멸자가 호출되어 finally의 역할을 대신한다.어떤 경우에 예외를 던질까?Python과 Ruby는 함수 호출 시점에서 예외를 던진다. 그러나, JavaScript는 인수에 ‘미정의를 의미하는 특수한 값’을 사용해서 처리를 계속한다.예외는 어떤 경우에 사용해야하는가?예외적 상황이란 무엇인지에 대한 정답은 없다프로그래머도 사람인 이상, 실수를 피할 수는 없다.무언가가 이상하다면 빨리 문제를 발견하는 것이 중요하다. 학습이나 개발 단계에서는 틀리면 바로 틀린 것을 발견하는 것이 오히려 이점이 많다.이름과 스코프스코프란 변수나 함수의 이름이 유효한 ‘범위’를 말한다.왜 이름이 필요한가?지금은 있는 것이 당연하다고 느끼는 변수나 함수의 이름은 초기에는 메모리에 번호를 부여해서 해당 값을 찾는 방식이었으나, 이름으로 대상을 지정 할 수 있도록 꾸준히 발전해왔다.이름의 충돌초기 프로그래밍 언어에서는 대응표를 프로그램 전체에서 공유하고 있었다. 회사로 말하면 큰 화이트 보드가 있어서 모두가 메모를 하고 있는 상황과 같았다.  이것은 같은 이름을 지닌 값이 있다면 데이터를 덮어써버려서 충돌을 일으키는 것이 문제였다.충돌 피하기  긴 변수명을 사용하는 방법  스코프를 이용하는 방법스코프란??이름의 유효 범위다.이것은 동적 스코프와 정적 스코프로 나뉜다.      동적 스코프 : 함수 입구에 원래의 값을 기록해두고 함수 출구에서 리턴값을 원래의 값으로 되돌리고 내보내는 것이다.          문제점 : 동적 스코프의 문제점으로는 변수를 변경한 후에 다른 함수를 호출한 경우 호출된 함수에 영향을 미치게 되기 때문에 다루기 힘들다는 점이 있다.            정적 스코프 : 함수가 호출될 때마다 새로운 대응표를 만드는 것과 같다고 할 수 있다. 회사 전체가 공유하고 있는 커다란 화이트 보드에 작성하는 대신, 한명 한명이 자신의 책상에 메모 용지를 갖고 있는 것으로 비유 할 수 있다.  하지만 동적 스코프로 만들어진 대응표는 소스 코드 전역에서 읽고 쓸 수 있다. 정적 스코프와의 가장 큰 차이점이다!  동적 스코프가 만약 참조한 경우에는 가까운 곳부터 순서대로 읽는다정적 스코프는 함수별로 대응표를 나눈다      특정 함수내에서의 이름변경이 함수 밖까지 영향을 주지 못한다. (유효 범위 분할이 가능)          현재는 많은 언어가 정적 스코프를 도입중이다!      그렇다면 정적 스코프는 완성체인가?정적 스코프의 특징이 편리해 보일 수도 있지만 2가지의 문제점을 지니고 있다.      내포 함수의 문제점 : 내포된 것처럼 보이는 함수가 실제로는 내포되지 않은 것이다.                  Python 2.0 을 예로들면, 특정 함수의 지역 스코프에서 찾고자하는 이름을 발견하지 못할 경우, 전역 스코프를 보게 된다.                  이는 소스 코드 상에서 가까이에 있는 정의가 사용되지 않는 예이다. 지금은 가까이에 있는 정의를 사용하도록 수정되었다.                          외부 스코프에 재귀속되는 문제  내포한 스코프의 외부 변수를 변경할 수 없다  함수안에서 대입하면 그 함수의 지역 변수가 되는데, 해당 스코프에 이미 같은 이름의 변수가 있으면 해당 변수를 재귀속 시키고, 없으면 해당 스코프에서 새로운 지역 변수를 작성한다.어느쪽이든 외부 스코프에 영향을 미치지 않게 되므로 이것은 외부 스코프에 있는 변수를 변경할 수 없다.형형이란 수치를 On과 Off로 표현하는 방법이다  컴퓨터 안에서는 On과 Off, 0과 1의 집합으로 모든 값이 표현된다.자릿수의 발명컴퓨터가 탄생하기 1000년 이상 전에 인류는 자릿수 기수법을 발명했다.  하나의 자리에 0에서 9까지 10가지 기호를 사용해서 수를 표현하는 방법이다!7 세그먼트 디스플레이계산기 등에서 수치를 표현하기 위해서 만들어졌다.  7 세그먼트 디스플레이를 사용하면 7개의 램프로 한 자릿수를 표현할 수 있어서, 3자릿수를 표현하기 위해 필요한 램프의 개수는 21개가 되고, 이는 기존의 것 보다 6개를 줄일 수 있었다.주판하지만 더 효율적인 방법이 나타났다.바로 주판이다. 5개로 하나의 자리를 표현하는 방법이다.  3 자릿수를 표현하려면 15개의 램프가 필요하다. 이것으로 6개를 더 줄일 수 있었다.램프 4개로 16가지를 표현할 수 있음에도 불구하고 10가지만 사용한다면 아까운 느낌이 든다. 좀 더 간격을 채워 넣을 방법이 없을까?1의 자리, 10의 자리, 100의 자리(10 x 10), 1000의 자리(10 x 10 x 10)로 자릿수를 맞추는 대신, 1의 자리, 2의 자리, 4의 자리(2 x 2), 8의 자리(2 x 2 x 2)로 맞추자는 발상이다! 이것이 바로 2진수다!2진수를 사용하면 10개의 램프로 0부터 1,023까지 표현이 가능하다8진수8가지 부호를 사용해서 자릿수를 맞추고 있어서 8진수라고 불린다.  한 묶음에 2 x 2 x 2로 8가지 패턴이 존재한다.16진수16가지 부호를 사용해서 자리를 맞추고 있기 때문에 16진수라고 불린다.  8진수 수치의 앞자리에는 0이나 0o를 붙이고, 16진수 수치에는 0x를 붙이는 경우가 많다.실수는 어떻게 표현할까?1.5나 0.001 등 소수점이 있는 ‘실수’는 어떻게 표현할까?두가지 방법이 있다.  고정 소수점      부동 소수점          고정 소수점 ( 소수점을 어디에 붙일지 정한다 )                  예를 들면 ‘이 정수는 소수점을 4자리 이동시켜서 소수점 이하 4자리를 소수부’라고 정하면 1이 0.0001이 되고, 100이 0.0100, 즉, 0.01이 된다. 하지만 0.0001보다 작은 값을 표현 할 수가 없고, 각각의 값에 대해 ‘어디까지 소수부로 정했는지’를 사람이 기억해야 한다.                    부동 소수점 ( 어디부터 소수부인지의 정보 자체를 값에 포함시킨다 )                  소수점을 이동시키는 방법으로 이 방법을 사용하면 1,023 이후에 0이 30개 계속되는 큰 숫자를 표현 할 수 있다.                    현재는 표준화 되어 IEEE 754가 적용되고 있다IEEE 754에서는 ‘지수부’가 소수점 위치에 해당하고, ‘가수부’가 유효 숫자의 소수점 이하 부분에 해당한다.문제점대부분의 경우에는 별 문제가 없지만, ‘3 나누기 10’의 결과를 표현하려고 하면, 10 진수로는 0.3을 사용해 표현 할 수 있지만, 2 진수의 경우 무한 소수가 되어 버린다.–컴퓨터는 비트열만으로 그것을 정수로 해석해야 할 지 부동 소수점으로 해석해야 할 지 알 수가 없다. 따라서, ‘이 값이 어떤 종류인지’ 정보가 별도로 필요한데 이것이 바로 ‘형’이다.초기 FORTRAN의 형변수명에 안에 든 것이 무엇인지 표현하기 위한 규칙을 만들게 되었다. 초기 FORTRAN에서는 변수명 선두가 I ~ N 이면 정수, 그 이외이면 부동 소수점이 들어 있다는 규칙을 사용했다.  다른 한가지 방법은 언어 처리계에 ‘이 변수는 정수다’라고 알려서 사람이 아닌 컴퓨터가 기억해두는 것이다.정수끼리, 부동 소수점끼리의 연산컴퓨터는 형 정보를 참고해서 무엇을 할 지 정한다. x와 y 둘 다 정수인 경우는 정수 덧셈을 하고, x와 y 둘 다 부동 소수점인 경우에는 부동 소수점 덧셈을 한다.한쪽이 정수고 다른 한쪽이 부동 소수점이라면?초기 FORTRAN의 경우 에러 처리를 했다. 하지만 C언어에서는 부동 소수점으로 암묵적 변환을 시킨다.하지만 C언어의 경우, 이것은 프로그래머가 어떤 형인지 기억해두지 않으면, 특정 코드를 보고도 소수점 이하를 버리는지 아닌지를 알 수가 없는 단점이 있다.이러한 설계는 많은 언어가 오랜 시간동안 사용해 왔던 것이기 때문에 ‘원래 그런 것이다’라고 생각하는 프로그래머가 많겠지만 이것은 불변의 물리 법칙이 아닌, 사람이 만든 설계일 뿐이다.형의 다양한 전개원래는 값의 종류를 저장하기 위해 사용되었던 형은 다양하게 응용되고 있다.사용자 정의형과 객체 지향      언어가 가지고 있는 기본적인 형을 조합해서 새로운 형을 만드는 기능        정수 등 ‘데이터’뿐만 아니라 함수 등 ‘데이터’를 처리하는 기능도 형으로 정리          이런 형에 클래스(class)라는 이름을 붙였다. 이것이 제2의 객체 지향의 발명이다.      사양으로서 형공개와 비공개를 나누다  ‘형은 사양이다’라는 개념이 등장했다. 구조체나 클래스를 구성하는 형을 전부 공개하지 않고 최소한만을 공개한다는 것이다. 외부와 작업하는 부분만을 형으로 공개하고, 상세 구현 방법은 숨긴다는 발상이다.인터페이스로 발전  ‘형은 사양이다’라는 개념은 더욱 진화해서 구체적인 구현 방법을 가지고 있지 않는 형이 탄생했다.총칭형, 제네릭스, 템플릿‘일부만 바꾸고 싶은데 전부 다시 정의해야 하는 것은 이상하다. 재사용하고 싶다’라는 필요가 생겨났고, ‘구성 요소의 형을 일부만 바꾸는 형’, 즉 총칭형이 탄생했다. ‘형이 인수를 가지고 형을 만드는 함수’가 탄생한 것이다.ex)  C++의 템플릿(template), Java(generic)등이 그러한 구조이다.동적 형결정‘종류 정보’를 값과 함께 세트로 가지고 있는 것을 ‘동적 형결정’이라고 한다.어떻게 표현하고 있을까?동적 형결정 언어에서 형 선언이 필요 없는 것은 메모리 상에서 동일한 형으로 취급되도록 설계되어 있기 때문이다.  Python에서 값은 정수든 부동 소수점이든 문자열이든 모두 PyObject 형으로 취급되도록 머리 부분이 모두 같은 형태로 되어 있다. 그리고 PyObject 형의 구조 안에는 값의 종류 정보를 저장할 수 있는 공간이 마련되어 있다.이러한 방법으로 값의 종류를 관리하면 종래의 정적 형결정 언어에서는 할 수 없었던 유연한 처리가 가능해지지만, 동적 형결정 언어에서는 형 체크를 할 수 없기 때문에 일부 버그는 실행 전에 찾아낼 수가 없다.형 추론형 추론은 원래 OCaml이나 Haskell 등의 ML계 언어가 잘하는 분야였지만, 최근에는 Java VM 상에서 동작하는 언어인 Scala등 형 추론을 장점으로 부각시키는 언어가 늘고 있다.  현재는 정적 형결정과 동적 형결정과 같이 정보 저장 장소나 사용하는 타이밍이 다른 것까지 포함해서 ‘형’이라 부른다. 이 때문에 형이 무엇인지 더욱 이해하기 어렵게 되었다. 어떤 정보가 어디에 있고 어떤 타이밍에 사용되는지의 관점에서 보아야 이해하기 쉽다.–컨테이너와 문자열무언가를 넣는 상자를 컨테이너라고 부른다고 하자.  언어마다 다양한 컨테이너가 있다.  각각의 컨테이너에는 장단점이있다.컨테이너에 넣은 데이터는 메모리에 저장된다. 메모리에는 정해진 크기의 상자가 정렬되어 있으며, 각 상자는 번호가 부여되어 있는 물품 보관함 같은 것이다  컨테이너 종류에 따라서 메모리 저장 방법이 다르다메모리 : 정해진 크기의 상자가 정렬되어 있고 각 상자에 번호가 부여되어 있다.배열과 연결 리스트두 종류의 컨테이너가 있다.  배열  연결 리스트배열에 값을 삽입하는 경우배열에서는 ‘값을 순서대로 넣는’방법으로 저장한다. 배열에 요소를 삽입 할 때는 삽입된 위치보다 뒤에 있는 요소를 전부 다른 위치로 옮겨야 한다.연결 리스트에 값을 삽입하는 경우연결 리스트에서는 메모리에 순서대로 정렬해있을 필요가 없다. ‘다음 요소가 들어있는 위치’를 메모리 상에 넣어두기 때문이다.ex)  연결 리스트에 삽입 할 때는 상자 두개를 추가하고, 상자 하나만 변경하면 된다.장단점배열에서는 삭제된 요소보다 뒤에 있는 것을 모두 움직여야 하기에 O(n)이 돼버리지만, 연결 리스트에서는 ‘다음 요소는 어딘지’의 정보를 바꾸기만 하면 되기에 O(1)이다.배열에서는 순서대로 나열하고 있기 때문에 금방 n번째 요소를 알 수 있지만, 연결 리스트에서는 각 요소를 자신이 원하는 곳에 넣을 수 있기 때문에 이 방법을 사용 할 수 없다.언어에 따른 차이Java나 Python, Ruby 등 대부분의 언어에서는 배열이 가장 기본적인 컨테이너로 제공되고 있다.사전, 해쉬, 연상 배열‘값을 복수 개 넣는다’는 목적을 위해 배열과 연결 리스트 등 여러 가지 방법이 있었듯이, ‘문자열과 값의 대응을 넣는다’는 목적을 위해서 몇 가지 구현 방법이 있다. 자주 사용되는 것이 해쉬테이블과 트리다.해쉬 테이블문자열을 인수로 받아서 정수를 반환하는 ‘해쉬 함수’를 사용해서 문자열과 값의 대응 관계를 표현하는 방법이다.트리트리는 데이터의 구조체다. ‘왼쪽 자식’, ‘오른쪽 자식’에 두 개의 화살표가 연결된다. 습관적으로 아래를 향해서 뻗어나가기 때문에 나무라기 보단 나무 뿌리처럼 보일 수도 있다.요소를 꺼내는 시간배열에 키와 값을 넣고 어떤 키에 대응하는 값을 찾고자 한다고 하자. 어떤 키가 어디에 있는지 모르기 때문에 배열의 맨 처음부터 순서대로 읽어나간다. 첫 부분에서 찾을 수도 있고, 맨 마지막에서 찾을 수도 있다. 평균적으로 n/2회 체크가 필요하다. 즉, O(n)이 된다.트리의 경우트리의 경우 높이가 하나씩 증가하면 요소 수는 약 2배가 된다. 반대로 말하면, 데이터량이 2배가 될 때마다 필요한 비교 횟수가 1회 증가한다. 즉, 트리에서 꺼내는 처리의 오더는 O(log n)이다.해쉬 테이블의 경우키에 대응하는 값을 꺼내기 위해서는 ‘키를 해쉬 함수로 변환’, ‘배열에 해당 장소에 있는 값을 읽는’ 작업이 필요하다. 이 작업은 데이터량과 관계가 없다. 즉 O(1)이다.  해쉬 테이블의 오더가 가장 작다.  해쉬 테이블은 값을 넣기 위해 큰 배열을 사용하고 있기 때문에 메모리 소모량이 매우 크다.ex)  메모리 절약 » 배열  계산 시간 » 해쉬 테이블만능 컨테이너란 없다절대 정답은 존재하지 않는다. 자신의 상황에 맞게 적합한 균형을 찾는 게 중요하다.–문자란?문자 집합과 문자 부호화 방식부호화 방법을 공유하고 있지 않은 사람과는 작업을 할 수가 없다.컴퓨터 이전 시대의 부호화  모스부호  보 코드      모스부호 : 모스부호는 사람이 스위치를 눌러서 송신하고, 사람이 귀로 들어 수신한다는 규칙으로 만들어진 부호화 방법이었다. 이 방법은 1초 동안 송신할 수 있는 양과 수신할 수 있는 양에 한계가 있다.        보 코드 : 하나의 문자를 On/Off 5개의 조합(5비트)으로 표현하는 것이다. 즉 SOS는 15비트로 표현 할 수 있었다. 모스부호의 절반으로 효율이 좋다.  컴퓨터 시대의 부호화  EDSAC 문자 코드  ASCII와 EBCDIC 시대      EDSAC : 텔렉스와 같이 한 문자에 5비트를 사용했고, 숫자, 문자, 시프트를 사용해서 출력했다. 보 코드와 같은 발상이다. 단지 어떤 문자를 어떤 비트열에 할당할지가 달랐다.        ASCII : ASCII는 한 문자당 7비트를 사용하는 부호화 방식이다. 7비트로 128 종류의 문자를 표현 할 수 있기 때문에 시프트로 변환할 필요가 없어졌다. ASCII가 부호화하는 문자 세트에는 EDSAC보다 많은 기호와 제어 코드, 그리고 소문자 알파벳도 포함되어 있다.  ASCII와 EBDCIC은 알파벳 대소문자나 기호를 부호화하는 기법Unicode에 의한 통일인터넷이 발전하고 다양한 나라에서 만들어낸 데이터가 교환되기 시작하면서 이 문제가 표면 위로 떠올랐다. 여러 나라가 정한 ‘규칙’을 이해하지 않으면 안 되는 상황이 되었다.전 세계의 문자를 부호화하는 방법을 만들자는 움직임이 시작됐고, 1984년에 국제 표준화 기구(ISO)가 작업을 시작하였다. 이렇게 해서 전 세계 문자를 포함한 문자 집합 Unicode가 탄생했다.문자열이란?문자열이란 문자가 정렬해있는 것이다. 하지만 문자에 따라선 문자열을 표현하는 방법은 제 각각이다.길이 정보를 가지고 있는 Pascal 문자열, 가지고 있지 않은 C 문자열C언어와 Pascal은 둘 다 ‘하나의 문자를 8비트’로 정의하고 있다. Pascal 문자열은 제일 앞 부분에 문자열 길이를 기록해둔다는 규칙을 채용하고 있다. 그러나 C언어 문자열은 ‘문자열이 시작되는 메모리 상의 위치’만을 가지고 있다. 길이 정보를 가지고 있지 않아서, 해당 위치에서 어디까지가 문자열인지 알 수 없다.NUL 문자로 문자열의 끝을 표현한다  NUL 문자는 0에 대응하는 문자로, C언어 코드에서는 \\0으로 표현한다.Python은 Java와 같이 16비트 문자열인 ‘Unicode 문자열’과 Pascal과 같은 8비트 문자열 모두를 지원하는 언어다      Python 2.7에서는 Unicode 문자열에 바이트열을 결합할 경우 바이트열이 ASCII로만 이루어진 경우에 한해 성공한다        Python 3.0에서는 Unicode 문자열에 바이트열을 결합하면 항상 실패한다. 명시적으로 Unicode 문자열로 변환하고 나서 결합한다.  Ruby 1.9의 도전Ruby는 독자 노선을 가고 있었다. Ruby 1.9부터 문자열은 8비트로 하고 ‘부호화 방식 정보’를 추가로 보유하도록 했다. 이 방법은 Unicode 문자 집합에 포함되지 않는 문자를 손쉽게 쓸 수 있다는 점이 장점이다.병행처리병행 처리란?복수의 처리를 시간축 상에 오버랩에서 실행하는 것을 병행 처리라고 한다.잘게 분할해서 실행한다사람의 눈으로 보면 프로그램이 계속 동작하고 있는 것처럼 보이지만, 실제로는 잘게 분할해서 실행되고 있는 것이다.처리를 변경하는 2가지 방법‘언제 교대할 것인가?’를 정하는 방법은 크게 두가지로 나눌 수 있다.  협력적 멀티태스크  선점적 멀티태스크      협력적 멀티태스크 : ‘타이밍이 좋은 시점에서 교대하는’방법이다. 처리가 일단락되는 시점에 자발적으로 처리 교대를 하는 방법이다. 이 방법으로 구현된 멀티태스크(multi-task, 병행 처리)를 협력적 멀티태스크라고 한다.        선점적 멀티태스크 ( 일정 시간에 교대한다 ) : 개별 프로그램과 입장이 다른 프로그램(태스크 스케줄러)이 존재한다. 이 프로그램이 일정 시간마다 지금 실행되고 있는 처리를 강제적으로 중단시켜서 다른 프로그램이 실행될 수 있도록 한다.  경합 상태 방지법경합 상태의 3가지 조건평행해서 동작하고 있는 2가지 처리 간에 경합 상태가 발생하기 위해서는 다음 3가지 조건을 모두 만족해야 한다.  2가지 처리가 변수를 공유하고 있다  적어도 하나의 처리가 그 변수를 변경한다  한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.이 3가지 조건 중 하나라도 제거 할 수 있다면 병행 실행 시에도 안정된 프로그램을 만들 수 있다.공유하지 않는다 ( 프로세스와 액터 모델 )  처음부터 아무것도 공유하지 않으면 1.은 발생하지 않기 때문에 경합 상태를 신경 쓸 필요가 없다.프로세스에서는 메모리를 공유하지 않는다UNIX에서는 실행 중의 프로그램을 ‘프로세스’라고 부른다. 서로 다른 프로세스는 메모리를 공유하지 않는다. 때문에 복수의 프로그램이 메모리 상에서 경합 상태를 일으킬 일은 없다. 데이터베이스 접속, 파일 읽고 쓰기 등 무엇인가를 공유했을때만 주의하면 된다.공유하지 않는 접근법은 성공했을까?현재까지도 스레드를 사용해서 공유 메모리를 어떻게 다뤄야 할지 고심해가면서 프로그램이 만들어지고 있다.  액터 모델 : ‘메모리를 공유하지 않는다’는 설계 방침에서의 또 다른 흐름이 바로 액터 모델이다. 1973년에 발표된 병행 처리를 위한 모델이다. ( 병행해서 동작하는 복수의 처리가 정보를 교환하는 방법으로, ‘메모리를 공유한다’가 아닌 ‘메시지를 보낸다’를 제안했다 )변경하지 않는다 - const, val, immutable‘메모리를 공유해도 변경하지 않으면 문제가 없다’는 2.에 대한 대응책도 있다.이 방식을 강하게 어필하고 있는 언어로써, 모든 값이 변경 불가능한 Haskell 등을 들 수 있다.끼어들지 않는다경합 상태가 발생하는 조건 3.인 ‘한 쪽의 처리가 한 단락 마무리 되기 전에 다른 한 쪽의 처리가 끼어들 가능성이 있다’를 방지하기 위해서는 어떻게 하면 좋을까?협력적 스레드의 사용 - 파이버, 코루틴, 그린 스레드파이버나 코루틴, 그린 스레드 등으로 불리는 기법을 사용하는것이 그 방법이다!      스레드가 선점성을 가지고 끼어드는 원인이 되기 때문에 협력적 스레드를 만들면 된다는 생각이다.        협력적 멀티태스크이기 때문에 어떤 스레드가 CPU를 독점하면 다른 스레드의 처리가 멈춘다. 어디까지나 각 스레드가 협력적으로 최적의 순간을 맞춘다는 사실을 전제로 한다.  끼어들면 곤란해지는 처리에 표식을 붙인다 - 락, 뮤텍스, 세마포어‘지금 끼어들면 곤란해’라는 표식을 공유하는 방법이다. 예를 들어, 어떤 메모리 값이 0이 아니면 이것은 ‘다른 스레드가 끼어들면 곤란한 처리를 하고 있어’라고 정해 두는 것이다.락의 문제점과 해결책락의 문제점  교착 상태가 발생한다  합성할 수 없다트랜잭션 메모리이 문제를 해결하려고 하는 것이 트랜잭션 메모리라는 접근법이다. 데이터베이스의 트랜잭션 기법을 메모리에 적용한 것이다. 개념은 ‘실험적으로 해보고, 실패하면 처음부터 다시 고쳐서 하고, 성공하면 변경을 공유한다’이다.트랜잭션 메모리의 역사      하드웨어로 구현          1986년에 Symbolics라는 회사가 트랜잭션을 하드웨어로 구현하려는 아이디어를 제안했다. 상업적으로는 성공하지 못했다.            소프트웨어로 구현          그 후 10년이 지난 1995년에 소프트웨어로 트랜잭션 메모리를 구현하려는 논문이 발표되었다. 그리고 10년 더 지난 후 2005년에 Microsoft가 Concurrent Haskell을 사용해서 소프트웨어적으로 트랜잭션 메모리를 실현하는 논문을 발표했다.      그 전후로 여러 언어에 소프트웨어 트랜잭션 메모리 기능이 탑재되었다.객체와 클래스객체 지향이란?      C++ 설계자인 Bjarne Stroustrup의 경우                  객체 지향 프로그래밍이란 사용자 정의형과 상속을 사용한 프로그래밍이다!                    또한 상태를 가진 객체가 메세지를 주고 받아서 커뮤니케이션하는 프로그램이다!            객체는 현실세계의 모형현실 세계에 있는 ‘사물’의 ‘모형’을 컴퓨터 안에 만들려면 어떻게 하면 될까? 라는 의문을 해결하기 위해 ‘객체 지향’이라는 개념이 탄생했다.클래스란?C++에서는 ‘클래스는 사용자가 정의할 수 있는 형’이다.C++은 정적 형결정 언어이고 Ruby나 Python은 동적 형결정 언어다.단, Java는 예외다. ‘클래스라는 부품을 정의하고, 그것을 조립해나가는 것이 프로그래밍이다’라고 정의하고 있다. 따라서 Java에서는 클래스가 반드시 필요한 조건이다.변수와 함수를 합쳐서 모형을 만드는 법  모듈(Module)  함수도 변수도 동일하게 해쉬에 넣는 방법  클로저(Closure)      모듈 : 함수를 합쳐두기 위한 패키지와 변수를 합쳐두기 위한 해쉬를 연결하는 방식        함수도 변수도 동일하게 해쉬에 넣는 방법 : JavaScript등의 언어가 채용하고 있다.        클로저 : 함수 실행 시의 이름 공간의 변수를 하나로 묶기 위해 사용하는 방법이다.  모듈, 패키지모듈, 패키지란 무엇인가?‘관련성이 높은 함수나 변수의 묶음’이다.모듈은 ‘하나로 모으는 기법’이다.Python이나 Ruby는 ‘모듈’이라 하고, Java나 Perl에서는 ‘패키지’라는 이름으로 부른다Perl 패키지로 객체를 만든다Perl 패키지는 함수나 변수를 하나로 묶어서 그것에 이름을 붙일 수 있는 기능이다.하지만모듈만으로는 부족하다인수로 개별 해쉬를 전달한다Perl에는 사전을 만드는 기능이 언어 처리계 자체에 탑재되어 있다. Perl은 이것은 ‘해쉬’라고 부른다.  해쉬는 함수를 호출 할 때 해쉬를 인수로 전달한다.초기화 처리도 패키지에 넣는다새로운 카운터를 만들 때는 프로그래머가 직접 명시를 해줘야만 한다. 값을 어떻게 초기화할지를사람이 기억하지 않으면 안되는 것이다. 이것은 좋지 않은 설계다. 이런 경우는 ‘초기화 방법’을 함수로 만들어서 패키지에 넣으면 된다.해쉬와 패키지를 연결한다데이터 저장소와 해당 데이터에 대응하는 동작의 집합(모듈)을 연결시킴으로 하나의 묶음으로 정리된 이해하기 쉬운 코드를 만들 수 있다.함수도 해쉬에 넣을 수 있다!퍼스트 클래스JavaScript가 도입하고 있는 방법이다.      ‘변수에 대입한다’, ‘함수의 인수로 전달한다’, ‘함수의 반환값으로 전달한다’ 등이 가능한 값을 ‘퍼스트 클래스값’이라고 부른다.        차별 대상이 아닌 일급 시민을 의미한 표현이다. 최근의 언어 Java나 Perl, Python 등에서 문자열은 퍼스트 클래스 값이다.  JavaScript에서는 함수도 퍼스트 클래스 값이다. 함수를 변수에 대입하거나 함수의 반환값으로 전달하는 것도 가능하다복수 개 카운터를 만든다카운터를 손쉽게 복수 개 만들기 위해서 해쉬로 초기화하기 위한 함수를 만들면 아주 간단하게 만들 수 있다. 단순히 해쉬를 makeCounter 안으로 이동하기만 하면 된다.Perl 패키지와 동일하게 다음 이점들을 가지게 된다.      복수 객체를 만들 수 있다.        하나의 묶음으로 보인다.        초기화 방법을 사람이 기억하지 않아도 된다.  클로저클로저란?이것은 객체적인 것을 만들기 위한 기술이다.  클로저라는 특수한 구문이 있는 것은 아니다. 함수를 함수 안에 정의하고, 내포할 수 있는 정적 스코프가 있어서 함수를 반환값으로 사용하거나 변수에 대입하여 사용한다는 개념이다. 즉, 간단한 내포 구조를 사용함으로 상태 정보를 가진 함수를 만들 수 있다.왜 클로저라고 부를까?왜 이것을 클로저라고 부를까? 그것은 자유 변수를 포함한 식을 ‘열린 식’이라고 부르고, 그 자유 변수의 바인딩을 조합함으로 해당 식을 닫고 있기 때문이다.클래스언어 설계자가 ‘이 언어에서는 이것을 클래스라고 부른다’고 정한 것으로, 다양한 정의가 존재한다.Hoare가 생각한 클래스‘현실 세계의 사물(object)은 편의상 상호 배타적 종류(classes)로 분류될 수 있다’고 기술하고 있다. 그리고 ‘어떤 종류의 사물을 더욱 세분화된 종류(subclasses)로 분류할 수 있으면 편리하다’고 주장하고 있다.      처음 시작은 ‘분류’였던 것이다          현재 사용되고 있는 ‘클래스를 상속한다’, ‘클래스는 인스턴스다’라는 개념이 등장한것은 보다 나중의 이야기다.      C++ 클래스클래스는 타입(type)이다. 이것이 C++을 이루는 아주 중요한 원리다. C++에서 class가 사용자 정의 타입을 의미한다면 왜 그것을 type이라고 부르지 않는가? 내가 class를 선택한 것은 계속 나오는 새로운 용어를 발명하는 것이 귀찮았기 때문이고, Simula의 class라면 아무도 당황하지 않을 것이라 판단했기 때문이다. - « C++로 배우는 프로그래밍의 원리와 설계 »사양으로서 역할C++에게 있어서 클래스(=형)란 사양을 표명한 것이기도 했다. 즉, 클래스는 ‘객체가 어떤 메소드를 갖고 있고, 어떤 메소드를 갖고 있지 않은가’라는 사양을 선언하는 역할도 했다.  그 메세지를 받은 객체가 어떤 동작(무언가를 실행할지, 에러처리할지 아니면 무시할 것인지)을 할지는 수신 객체가 자유롭게 결정 할 수 있다.클래스의 3가지 역할      결합체를 만드는 생성기        어떤 조작이 가능한지에 대한 사양        코드를 재사용하는 단위  객체 지향은 현실세계의 사물 모형을 만들기 위해 만들어졌고, 언어마다 구현 방법이나 ‘객체 지향’이 의미하느 바가 다르다!상속을 통한 재사용상속이란?어떤 클래스에서 선언된 것은 그것을 세분화한 ‘자식 클래스’에게도 자동으로 이어지는 게 좋다. 이것이 ‘상속’이다!!!상속에 관한 다양한 접근법상속은 크게 3가지 측면으로 접근할 수 있다.      일반화/특수화        공통 부분을 추출        차분 구현        일반화/특수화 : ‘부모 클래스로 일반적인 기능을 구현하고, 자식 클래스로 목적에 특화된 기능을 구현한다’는 접근이다.        공통 부분을 추출 : ‘복수 클래스의 공통 부분을 부모 클래스로서 추출하면 좋다’는 접근법이다        차분 구현 : ‘상속 후 변경된 부분만 구현하면 효율이 좋다’는 접근법이다  상속은 양날의 칼‘상속을 많이 사용하면 코드가 복잡해진다. 제어를 추가해야 한다’는 의견이 나오고 있다.  상속을 반복하면, 코드 영향 범위가 넓어져서 이해하기 어렵게 된다. 이해하기 쉽게 하기 위해서는 상속 트리의 깊이를 낮추는 것이 중요하다리스코프의 치환 원칙CLU라는 언어의 설계자인 Liskov가 1987년에 제창한 것으로, 현재는 자식 클래스를 만들 때 주의해야 할 사항으로 자주 언급되는 것이 ‘리스코프의 치환 원칙’이다.다중 상속하나의 사물을 복수로 분류현실세계에서 하나의 사물이 복수의 분류에 해당하는 경우가 있기 때문에 그것을 모델화하는 프로그래밍 언어가 복수의 클래스를 상속할 수 있어야 한다. 이것이 다중 상속이다.코드 재사용에 편리한 다중 상속다중 상속은 코드 재사용 방법으로도 매우 좋은 도구다!  다중 상속이 가능한 언어에서는 단순히 양쪽 클래스를 상속하기만 하면 된다.다중 상속의 문제점 - 거듭되는 충돌다중 상속은 편리한 기능이다. 그런데 다중 상속은 어떻게 메소드의 이름을 해결하고 있는 걸까? 클래스에게 ‘x의 값은 무엇인가?’라고 물으면 어떻게 대답할까? 이름해결의 문제가 발생한다.해결책 1: 다중 상속을 금지한다Java는 클래스 다중 상속을 금지하기로 했다. 클래스 다중 상속을 인정하지 않으면 앞의 경우와 같은 문제가 발생하지 않는다. 다중 상속을 버림으로 문제를 해결했지만, 대신 다중 상속의 편리함 또한 버리게 된다.      위임 : 사용하고 싶은 코드를 가지고 있는 클래스 객체를 만들고, 필요에 따라 해당 클래스에 처리를 맡기는 방법이다. 상속을 사용해서 형이나 이름 공간까지 함께 계승하는 것이 문제의 원인이기 때문에, 단순히 객체를 보유하기만 하면 문제를 막을 수 있다.        인터페이스 : Java는 다중 상속을 금지하고 있다고 설명했지만, Java에도 다중 상속이 가능한 것이 있다. 바로 인터페이스 이다. 인터페이스는 ‘코드를 가지고 있지 않는 클래스’다. ‘인터페이스를 상속한 클래스는 반드시 xx라는 이름의 메소드를 가지고 있다’라는 ‘사양’만 가지고 있다.  해결책 2: 메소드 해결 순서를 고민한다‘자신이 모른다면 앞에 쓰여있는 부모부터 순서대로 확인한다’는 규칙(깊이 우선 탐색)으로 해결될까?      깊이 우선 탐색의 문제점 : 어떤 클래스 Base를 복수의 클래스 derived1, derived2가 상속하고 있다고 하자. 그리고 이 두 클래스를 상속하는 Multi가 있다고 하자. 이 같은 형태의 다중 상속을 ‘마름모 상속’이라고 부른다. 메소드가 재정의(오버라이드)되는 경우가 있다.        C3 선형화로 순서를 정한다                  C3 선형화는 1996년에 제안된 알고리즘으로, 2가지 제약 조건을 만족하도록 클래스에 순서를 매겨서 정렬한다. 그 제약 조건은 다음과 같다.                  부모 클래스는 자식 클래스보다 먼저 탐색되지 않는다.          어떤 클래스가 복수의 부모 클래스를 상속하고 있으면 먼저 만들어진 것이 우선된다.                    해결책 3: 처리를 섞는다어떤 클래스는 선조 클래스까지 도달하는 경로가 여러 개 있는 것이 문제다. 그렇다면 재사용하고 싶은 기능만을 모은 작은 클래스를 만들어서 해당 기능을 추가하고 싶은 클래스에 섞어 넣으면 된다. 이런 설계 방침이나 섞어 넣는 것, 그리고 섞기 위한 작은 클래스를 믹스-인(Mix-in)이라고 한다.해결책 4: 트레이트클래스가 ‘인스턴스를 만들기 위한 것’으로 사용될 때는 재사용 단위로 너무 크다. 그러면 재사용 단위라는 역할에 특화된 보다 작은 구조(트레이트 = 메소드 묶음)를 만드는 것이 좋다. 이것이 트레이트 개념이다.",
        "url": "/blackruby-code//code/2017/11/29/base.html"
      }
      ,
    
      "back-2017-11-27-flask-html": {
        "title": "Flask Heroku(배포)",
        "tags": "Flask, Flasky",
        "date": "November 27, 2017",
        "author": "Yoonkh",
        "category": "",
        "content": "flaskydeploy 과정태스크를 애플리케이션이 설치될 때나 업그레이드될 때 수동으로 실행하면 에러에 취약하고 시간 소모적인 작업이 된다. 따라서 필요한 모든 태스크를 실행하는 커맨드를 manage.py에 추가한다.ex) 17-1 manage.pydef deploy():\t\"\"\"Run deployment tasks.\"\"\"\tfrom flask.ext.migrate import upgrade\tfrom app.models import Role, User\t\t# migrate database to latest revision\tupgrade()\t\t# create user roles\tRole.insert_roles()\t\t# create self-follows for all users\tUser.add_self_follows()이 커맨드에 의해 실행될 함수는 이전에 모두 생성되었으며 일괄적으로 함께 호출된다.  업데이트 함수를 설계함으로써 설치나 업그레이드가 실행될 때마다 deploy 커맨드를 실행하는 것이 가능하다.제품화 과정 중의 에러에 대한 로그디버거는 개발 중에 애플리케이션 문제점들을 디버그하기 위한 훌륭한 툴이지만 제품화 배포에서는 사용할 수 없다. 제품화에서 발생한 에러는 숨겨져 있으며 사용자들은 단지 코드 500 에러 페이지만을 받게 된다.  이러한 에러의 스택 트레이스를 완전히 잃어 버리지는 않는다. 플라스크가 그 에러를 로그 파일(log file)에 작성하기 때문이다.시작하는 동안에 플라스크는 Python의 logging.Logger 클래스의 인스턴스를 생성하고 그것을 애플리케이션 인스턴스의 app.logger로 붙인다.  이 로거는 디버그 모드에서는 콘솔에 작성하지만 제품화 모드에서는 기본적으로 이것을 설정하는 핸들러가 없다. 따라서 핸들러에 로그가 추가되어야 저장이 된다.ex) 17-2 config.py : 애플리케이션 에러에 대해 이메일 전송class ProductionConfig(Config):\t# ...\t@classmethod\tdef init_app(cls, app):\t\tConfig.init_app(app)\t\t\t\t# email errors to the administrators\t\timport logging\t\tfrom logging.handlers import SMTPHandler\t\tcredentials = None\t\tsecure = None\t\tif getattr(cls, 'MAIL_USERNAME', None) is not None:\t\t\tcredentials = (cls.MAIL_USERNAME, cls.MAIL_PASSWORD)\t\t\tif getattr(cls, 'MAIL_USE_TLS', None):\t\t\t\tsecure = ()\tmail_handler = SMTPHandler(\t\tmailhost=(cls.MAIL_SERVER, cls.MAIL_PORT),\t\tfromaddr=cls.FLASKY_MAIL_SENDER,\t\ttoaddrs=[cls.FLASKY_ADMIN],\t\tsubject=cls.FLASKY_MAIL_SUBJECT_PREFIX + ' Application Error',\t\tcredentials=credentials,\t\tsecure=secure)\tmail_handler.setLevel(logging.ERROR)\tapp.logger.addHandler(mail_handler)\t\t이러한 변경 사항은 제품화 모드에서 실행하는 동안 발생하는 에러를 FLASKY_ADMIN에 세팅에 설정되어 있는 관리자 리스트의 이메일로 전송하도록 로깅 핸들러를 설정한다.모든 설정 인스턴스가 create_app()에 의해 호출되는 init_app() 정적 메소드를 갖고 있다는 것을 기억하자!!!ProductionConfig 클래스를 위한 이 메소드의 구현에서 애플리케이션 로거는 이메일 로거로 로그 에러를 설정하도록 되어 있다.  이메일 로거의 로그 레벨은 logging.ERROR로 설정된다. 따라서 단지 심각한 문제만 이메일로 전송된다. 덜 심각한 레벨로 로깅된 메세지는 파일, syslog 혹은 적절한 로깅 핸들러를 추가하여 지원하는 다른 메소드를 사용하여 로그된다. 이러한 메시지를 위해 사용되는 로깅 메소드는 호스팅 플랫폼에 상당히 의존적이다.클라우드 배포가장 최근의 트렌드는 “클라우드”로 호스팅하는 것이다. 이 기술은 애플리케이션 개발자들을 애플리케이션이 실행하게 될 하드웨어와 소프트웨어 플랫폼에 따라 설치와 유지 보수를 해야 하는 기존의 태스크로부터 해방시켜 준다.  헤로쿠(Heroku)는 가장 유명한 PaaS 프로바이더이며 파이썬을 지원한다.헤로쿠 플랫폼헤로쿠는 2007년부터 비즈니스를 시작했다. 헤로쿠 플랫폼은 유연성이 뛰어나며 다양한 프로그래밍 언어를 지원한다.  애플리케이션을 헤로쿠에 배포하기 위해서는 개발자가 Git을 사용하여 애플리케이션을 헤로쿠의 Git 서버에 푸시한다. 서버에서는 git push 커맨드가 자동으로 설치, 설정, 배포를 트리거한다.애플리케이션의 준비헤로쿠에서 작업하기 위해서는 애플리케이션이 Git 저장소에 호스트되어야 한다.헤로쿠 계정의 생성헤로쿠 툴벨트의 설치헤로쿠 애플리케이션을 관리하는 가장 간편한 방법은 헤로쿠 툴벨트(Toolbelt) 커맨드 라인 유틸리티를 이용하는 것이다.      툴벨트는 두 개의 헤로쿠 애플리케이션으로 구성되어 있다.                  heroku : 헤로쿠 클라이언트이며, 애플리케이션을 생성하고 관리하는 데 사용된다.                    foreman : 컴퓨터에 테스트할 목적으로 헤로쿠 환경을 시뮬레이션하는 툴이다.            헤로쿠 클라이언트 유틸리티는 서비스에 연결하기 전에 헤로쿠 계정 자격증을 갖고 있어야 한다ex) heroku login command$ heroku login Enter your Heroku credentials.Email: &lt;your-email-address&gt;Password (typing will be hidden): &lt;your-password&gt;Uploading ssh public key .../id_rsa.pub다음 단계는 헤로쿠 클라이언트를 사용하여 애플리케이션을 생성하는 것이다.이 작업을 하기 위해, 먼저 애플리케이션이 Git 소스 컨트롤에 있는지 확인한 후에 최상위 디렉토리에서 다음의 커맨드를 실행한다.$ heroku create &lt;appname&gt;Creating &lt;appname&gt;...done, stack is cedarhttp://&lt;appname&gt;.herokuapp.com/ | git@heroku.com:&lt;appname&gt;.gitGit remote heroku addred헤로쿠 애플리케이션 이름은 반드시 고유의 이름이어야 하므로 다른 애플리케이션에서 사용하지 않은 이름을 찾아야 한다. create 커맨트의 결과에서 볼 수 있는 것처럼 한 번 배포된 애플리케이션은 http://&lt;appname&gt;.herokuapp.com에서 사용 가능하다.  커스텀 도메인 이름 역시 애플리케이션에 붙일 수 있다.애플리케이션 생성의 부분으로 헤로쿠는 Git 서버를 할당한다git@heroku.com:&lt;appname&gt;.gitcreate 커맨드는 이 서버를 로컬 Git 저장소에 heroku라는 이름을 가진 git remote인 것처럼 추가한다.데이터베이스의 프로비저닝(provisioning)헤로쿠는 Postgre 데이터베이스를 애드온으로 지원한다. 약 10,000개 정도의 행을 갖는 작은 데이터베이스를 무료로 애플리케이션에 추가할 수 있다.$ heroku addons:add heroku-postgresql:devAdding heroku-postgresql:dev on &lt;appname&gt;... done, v3 (free)Attached as HEROKU_POSTGRESQL_BROWN_URLDatabase has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pgbackups:restore.Use 'heroku addons:docs heroku-postgresql:dev' to view documentation.HEROKU_POSTGRESQL_BROWN_URL 레퍼런스는 데이터베이스 URL을 갖고 있는 환경 변수의 이름이다. 이 작업을 하려고 할 때 브라운(brown)과는 다른 컬러를 얻을 수 있다. 헤로쿠는 애플리케이션당 다중 데이터베이스를 지원하며 각각은 URL에서 다른 컬러로 보인다. 데이터베이스는 DATABASE_URL 환경 변수에 자신의 URL을 포함시킨다.  다음 커맨드는 브라운 컬러의 데이터베이스에 대한 처리를 보여준다.$ heroku pg:promote HEROKU_POSTGRESQL_BROWN_URLPromoting HEROKU_POSTGRESQL_BROWN_URL to DATABASE_URL... doneDATABASE_URL 환경 변수의 포맷은 정확하게 SQLAlchemy에서 필요한 것과 동일하다.  정의해 둔 것이 있다면 DATABASE_URL의 값을 사용하는 config.py 스크립트를 기억하자. Postgre 데이터베이스에 대한 연결은 이제 자동으로 진행된다.로깅 설정로깅 설정은 init_app() 정적 메소드에 있는 ProductionConfig 클래스에 추가되지만 이러한 타입의 로깅은 헤로쿠에만 적용되기 때문에 새로운 설정이 플랫폼에 따라 생성될 수 있다. 다른 타입의 제품 플랫폼을 위한 기본 설정으로 ProductionConfig는 남겨둔다. HerokuConfig 클래스는 다음 예와 같다ex) 17-3. config.py : 헤로쿠 설정class HerokuConfig(ProductionConfig):\t@classmethod\tdef init_app(cls, app):\t\tProductionConfig.init_app(app)\t\t\t\t# log to stderr\t\timport logging\t\tfrom logging import StreamHandler\t\tfile_handler = StreamHandler()\t\tfile_handler.setLevel(logging.WARNING)\t\tapp.logger.addHandler(file_handler)애플리케이션을 헤로쿠에 의해 실행하면, 사용해야 할 설정을 알아야 한다. manage.py에서 생성된 애플리케이션 인스턴스는 FLASK_CONFIG 환경 변수로 어떤 설정을 사용해야 할 지 알게되며, 따라서 이 변수는 헤로쿠 환경에 설정되어야 한다. 환경 변수는 헤로쿠 클라이언트의 config:set 커맨드를 사용하여 설정한다.$ heroku config:set FLASK_CONFIG=herokuSetting config vars and restarting &lt;appname&gt;... done, v4FLASK_CONFIG: heroku이메일 설정헤로쿠는 SMTP 서버를 제공하지 않으므로 외부 서버를 설정해 줘야 한다.  스크립트에 로그인 자격 내용을 직접 포함시키게 되면 보안 위험이 있을 수 있기 때문에 지메일 SMTP에 액세스하기 위한 사용자 이름과 패스워드는 다음과 같이 환경변수를 통해 제공한다.$ heroku config:set MAIL_USERNAME=&lt;your-gmail-username&gt;$ heroku config:set MAIL_PASSWORD=&lt;your-gmail-password&gt;제품 웹 서버의 실행헤로쿠는 애플리케이션을 위한 호스트 목적의 웹 서버를 제공하지 않는다. 대신에 애플리케이션이 자신의 서버를 시작하고 환경 변수 PORT에 설정된 포트 번호에서 리스닝할 수 있도록 한다.      플라스크를 사용한 개발 웹 서버는 성능이 매우 좋지 않다. 제품 환경에서 실행되도록 설계된 것이 아니기 때문이다.        플라스크 애플리케이션을 잘 동작시키는 제품화 준비를 마친 두 개의 웹 서버는 구니콘(Gunicorn)과 uWSGI다.  구니콘은 다음과 같이 설치한다.(venv) $ pip install gunicorn구니콘에서 애플리케이션을 실행하려면 다음 커맨드를 사용한다.(venv) $ gunicorn manage:app  구니콘은 포트 8000을 사용한다.필요 파일의 추가헤로쿠는 최상위 폴더에 저장된 requirements.txt 파일에서 패키지 의존성을 로드한다.psycopg2 패키지는 Postgre 데이터베이스와 구니콘 웹 서버 지원을 할 수 있게 한다.ex) 17-4. requirements.txt : 헤로쿠 필요 파일-r requirements/prod.txtgunicorn==18.0psycopg2==2.5.1Procfile의 추가헤로쿠는 애플리케이션을 시작하기 위해 사용하는 커맨드가 무엇인지 알고 있어야 한다. 이 커맨드는 Procfile이라고 하는 특정 파일에 작성되어 있다. 이 파일은 애플리케이션 최상위 폴더에 추가되어야 한다.  다음은 이파일의 콘텐츠를 보여준다.ex) 17-5. Procfile : 헤로쿠 Procfileweb: gunicorn manage:appProcfile의 포맷은 매우 간단하다. 각 라인에는 태스크 이름이 있고, 그 다음에는 콜론, 그 다음에는 태스크를 실행하는 명령어가 온다.포맨을 이용한 테스트헤로쿠 툴벨트는 포맨(Foreman)이라는 두 번째 유틸리티를 포함하고 있다. 이 유틸리티는 테스트 목적으로 Procfile을 통해 애플리케이션을 로컬로 실행하는 데 사용된다.  포맨은 애플리케이션의 최상위 디렉토리에 있는 .env라는 이름의 파일에서 환경변수들을 찾는다. 예를들어, .env 파일은 다음과 같은 변수들을 포함하고 있다.FLASK_CONFIG=herokuMAIL_USERNAME=&lt;your-username&gt;MAIL_PASSWORD=&lt;your-password&gt;.env 파일은 패스워드와 다른 민감한 계정 정보를 포함하고 있기 때문에 Git 저장소에는 절대 추가해서는 안된다포맨의 주요한 두 개의 옵션은 foreman run 과 foreman start다.  run 커맨드는 애플리케이션 환경에서 커맨드를 실행할 때 사용되고, deploy 커맨드는 애플리케이션에서 데이터베이스를 생성할 때 사용된다.start 커맨드는 Procfile이 필요하며 그 안에 있는 모든 태스크를 실행한다.(venv) $ foreman startFlask-SSLify를 이용한 보안 HTTP의 활성화헤로쿠는 헤로쿠 내의 SSL 인증을 사용하는 설정 없이도 모든 애플리케이션이 http://와 https:// 모두에서 가능한 herokuapp.com 도메인을 액세스하도록 해 준다. 이때 필요한 유일한 작업은 애플리케이션이 http:// 인터페이스로 전송하는 리퀘스트를 가로채는 것과 그것을 https://로 리다이렉트하는 것이다. 그리고 이것은 Flask-SSLify 확장이 하는 작업이다.  이러한 확장은 requirements.txt 파일에 추가되어야 한다.ex) 17-6. app/__init__.py : 모든 리퀘스트를 보안 HTTP로 리다이렉트def create_app(config_name):\t# ...\tif not app.debug and not app.testing and not app.config['SSL_DISABLE']:\t\tfrom flask.ext.sslify import SSLify\t\tsslify = SSLify(app)\t# ...ex) 17-7. config.py : SSL의 사용 설정class Config:\t# ...\tSSL_DISABLE = True\tclass HerokuConfig(ProductionConfig):\t# ...\tSSL_DISABLE = bool(os.environ.get('SSL_DISABLE'))  환경변수가 비어 있는 문자열 대신에 다른 것으로 설정되면, 불린으로의 변경은 True를 리턴하며 SSL은 비활성화 된다. 환경변수가 존재하지 않거나 비어 있는 문자열로 설정되면, 불린으로의 변경은 False가 된다. 포맨을 사용할 때 SSL이 활성화되는 것을 막기 위해서는 .env 파일에 SSL_DISABLE=1을 추가해야 한다.헤로쿠를 사용할 때 클라이언트는 호스트한 애플리케이션을 직접 연결하지 않으며 리버스 프록시 서버(reverse proxy server)에 연결한다.  리버스 프록시 서버는 애플리케이션에 리퀘스트를 리다이렉트한다.프록시 서버는 클라이언트로부터 받은 원래의 리퀘스트를 커스텀 HTTP 헤더를 통해 리다이렉트된 웹 서버에 전송하도록 작성된 정보를 넘긴다. 따라서 사용자가 이러한 정보를 바탕으로 SSL을 통해 애플리케이션과 통신할지를 결정할 수 있다.Werkzeug는 WSGI 미들웨어를 제공하는데, 이 미들웨어는 프록시 서버로부터의 커스텀 헤더를 체크하고 그에 맞는 리퀘스트 오브젝트를 업데이트한다. 예를 들어, request.is_secure는 클라이언트가 리버스 프록시 서버에게 전송하는 리퀘스트의 보안성을 반영하며 프록시 서버가 애플리케이션에 전송하는 리퀘스트는 반영하지 않는다.  다음은 애플리케이션에 ProxyFix 미들웨어를 추가하는 방법을 보여준다ex) 17-8. config.py : 프록시 서버의 지원class HerokuConfig(ProductionConfig):\t# ...\t@classmethod\tdef init_app(cls, app):\t\t# ...\t\t\t\t# handler proxy server headers\t\tfrom werkzeug.contrib.fixers import ProxyFix\t\tapp.wsgi_app = ProxyFix(app.wsgi_app)Git push를 이용한 배포모든 변경 사항이 로컬 Git 저장소에 커밋된 것을 확인한 후에 git push master를 사용하여 애플리케이션을 heroku 리모트에 업로드한다.$ git push heroku master이제 애플리케이션이 배포되고 실행된다. 그러나 이 과정이 정상적으로 진행된것 같지는 않다. 그 이유는 deploy 커맨드를 아직 실행하지 않았기 때문이다.$ heroku run python manage.py deploy  데이터 베이스 테이블이 생성되고 설정된 후에, 애플리케이션은 깔끔하게 시작하기 위해 재시작한다.$ heroku restart애플리케이션은 이제 배포되었고 https://&lt;appname&gt;.herokuapp.com에서 액세스가 가능하다.로그 검토애플리케이션에서 생성한 로그 출력은 헤로쿠에서 캡쳐 할 수 있다. 로그 내용을 보기 위해서는 logs 커맨드를 사용한다$ heroku logs  테스트를 하는 동안 로그 파일의 가장 최신 내용을 보는 것이 편리하며 다음과 같이 작업한다$ heroku logs -t배포와 업그레이드헤로쿠 애플리케이션은 반복되어야 하는 동일한 프로세스를 업그레이드해야 한다.$ heroku maintenance:on$ git push heroku master$ heroku run python manage.py deploy$ heroku restart$ heroku maintenance:off  maintanence 옵션은 업그레이드가 진행되는 동안 애플리케이션을 오프라인에서 사용하게 하며 사이트가 재개될 것이라는 정보를 사용자에게 알려주는 정적 페이지를 보여주게 된다.",
        "url": "/blackruby-code//back/2017/11/27/flask.html"
      }
      
    
  };
</script>

<script src="/blackruby-code/assets/js/lunr.min.js"></script>
<script src="/blackruby-code/assets/js/search.js"></script>
</section>
</article>

      <!-- </div>      -->
    </div>
    
<script src="/blackruby-code/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
